# 概念

- **JDK**：Java Development Kit， 是一个跨平台的软件开发环境，包括 JRE、Java API、编译器、调试器、 jdb，javah，jmp等工具；
- **JRE**：是 Java语言的运行环境，包含了核心类库、JVM，但是没有编译器和调试器；
- **Java Hotspot**：是Sun JDK和Open JDK中虚拟机的实现技术，也是目前使用范围最广的 Java虚拟机；
- **Server模式**：JVM的启动模式，启动速度较慢，一旦运行起来后，性能将会有很大的提升，使用C2的编译器，使用 -server 参数；
- **client模式**：client 模式启动比较快，但性能和内存管理效率不如 server 模式，通常用于客户端应用程序，使用C1的轻量级编译器，使用 -client 参数；
- **前端编译器**：把 java 文件编译成 class 文件；
- **JIT编译器**：把字节码转变成机器码；
- **AOT编译器**：直接把程序编译成与目标机器指令集相关的二进制代码（如：Jaotc、GNU Compiler for the Java（GCJ）、 Excelsior JET）；
- **访问控制修饰符**：public、protected、private这些修饰符，可以用来限定访问作用域；
- **多态**：不同类有相同的方法或实现相同接口，且方法的实现不同，会产生不同的执行结果；
- **继承**：是指子类继承并具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法；
- **封装**：将Java对象中数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互；
- **抽象类**：使用 abstract 关键字修饰的类就是抽象类，抽象类包含抽象方法，抽象方法用 abstrct 修饰且只有方法名没有方法体；
- **重写**：是指在子类中重写父类方法，重写的方法和被重写的方法必须具有相同方法名称、参数、返回值；
- **重载**：是指在类中可以创建多个方法，且方法名相同，但具有不同的参数；
- **单行注释**：以双斜杠 // 表示注释一行内容；
- **多行注释**：包含在 /* 和 */ 之间，可注释多行内容；
- **包装类型**：是指基本数据类型对应的引用类型，所有的包装类型都是不可变的。比如 Integer 是 int 的包装类；
- **向上转型**：是指一个父类引用指向其子类的对象；
- **向下转型**：是指一个子类对象指向其父类引用；
- **JavaBean**：是指在对象中有 private 修饰的实例变量，且变量有对应的 public 修饰的 setter、getter 实例方法；
- **函数式接口**：就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口；



------



# 标识符

可以在[标识符命名辅助工具CODELF](https://unbug.github.io/codelf/)中输入变量的中文名，会得到一些比较贴近的英文变量名；



## 命名规则

- 由数字、英文字母、美元符号、下划线以及 Unicode 字符集中符号大于 `0xC0` 的所有符号组合构成；
- 第一个字符可以是字母、下划线和美元符号，但不能以数字开头；
- 区分大小写；
- 不能使用关键字；
- 不能使用方法名；



## 驼峰命名法

英文 Camel，也叫小驼峰命名法，第一个单词全部小写，其余的单词也全部小写，但首字母要大写，一般用于命名变量与方法。



## 帕斯卡命名法

英文 Pascal，也叫大驼峰命名法，单词全部小写，但每个单词的第一个字母要大写外，一般用于命名类与接口。



## 匈牙利命名法

英文 Hungarian，命名规则：属性前缀（小写）+ 类型 + 描述，多个属性可同时使用，顺序是先成员变量、再指针、再简单数据类型、再加上其他。

| 属性前缀    | 说明                    |
| ----------- | ----------------------- |
| m_          | 类的成员变量            |
| g_          | 全局变量                |
| c_          | 常量                    |
| s_          | 静态变量                |
| p           | 指针（Pointer）         |
| lp          | 长指针（Long Pointer）  |
| np          | Near Pointer            |
| a           | 数组（Array）           |
| b           | 布尔值（Boolean）       |
| by          | 字节（Byte）            |
| ch（或c）   | 有符号字符（Char）      |
| cnt（或c）  | 计数                    |
| cb          | 无符号字符              |
| d           | 双精度浮点              |
| n           | 短整型（Short Int）     |
| i           | 整型                    |
| l           | 长整型（Long Int）      |
| u           | 无符号                  |
| s           | 字符串型                |
| sz          | 字符串                  |
| w           | 字                      |
| dw          | 双字                    |
| r           | 实型                    |
| cr          | 颜色参考值 (ColorRef)   |
| cx,cy       | 坐标差（长度 ShortInt） |
| fn          | 函数                    |
| h           | Handle（句柄）          |
| dest        | 目的对象                |
| src         | 源对象                  |
| temp（或t） | 临时变量                |
| init        | 初始化                  |
| min         | 最小值                  |
| max         | 最大值                  |

例如：

```java
int m_lpszStr;  // 表示指向一个以0字符结尾的字符串的长指针成员变量
```



## 下划线命名法

英文 UnderScoreCase，下划线命名法与帕斯卡、及驼峰命名法的区别就是逻辑断点用的是下划线隔开。

例如：

```java
show_message();
string user_name;
```



------



#  关键字

也叫保留字，关键字是 Java语言保留的标识符，仅供内部使用，不能把关键字作为变量名或方法名来使用。

| 关键字     | 关键字  | 关键字    | 关键字    | 关键字     | 关键字       |
| ---------- | ------- | --------- | --------- | ---------- | ------------ |
| abstract   | assert  | boolean   | break     | byte       | case         |
| catch      | char    | class     | const     | continue   | default      |
| do         | double  | else      | extends   | final      | finally      |
| float      | for     | goto      | if        | implements | import       |
| instanceof | int     | interface | long      | native     | new          |
| null       | package | private   | protected | public     | return       |
| short      | static  | strictfp  | super     | switch     | synchronized |
| this       | throw   | throws    | transient | try        | void         |
| volatile   | while   |           |           |            |              |



## final

如果final关键字修饰类，则类不能被继承，但是该类可以有父类。

final修饰成员变量：成员变量必须在其所在类对象创建之前被初始化（且只能被初始化一次）。

final修饰局部变量，变量在定义时可以不被初始化，但是使用之前，必须完成初始化且只能初始化一次。



## native

用来修饰本地原生方法，被修饰的方法一般由 C++ 实现。



## strictfp

读音 ['striktef'pi:]，精确浮点（FP-strictfp），是指要对关键字strictfp修饰的浮点型数值做精确运算，可用来修饰类、接口、方法。

需求：

编译器和虚拟机默的认计算方式不精确（不同平台得到的结果不一致），但是其运算速度会更快。

关键字strictfp可以确保在任何平台中浮点计算结果都精确相同，都符合IEEE-754规范，但会影响运算速度。

修饰方法时，方法中所有的float和double表达式，都严格遵守FP-strict的限制，但不能修饰在接口中的方法上。

修饰类或接口时，该类中的所有代码（包括内部类中的代码）都严格遵守FP-strict的限制。



## transient

读音 [ˈtrænziənt]，被transient关键字修饰的实例变量不能被序列化。



## volatile

读音 [ˈvɔlətail]，[详见volatile机制章节](##volatile机制)



## instanceof

判断操作符instanceof左侧的对象是否属于操作符右侧类（或其子类）的实例对象。



------



# 数据类型



## 二进制形式

二进制是指 0 和 1 两个值，内存中的数据都是以二进制补码形式表示的。

位（Bit）：存储一个二进制数 0 或 1，是存储信息的最小单位。

字节（Byte）：一个字节是由 8 个位组成。



**为什么要用补码？**

补码（complemental code）可以将减法按加法来处理，将符号位和其他位统一处理，提高计算速度。

补码过程：只有负数需要补码，先将负数取绝对值，计算绝对值的二进制值，按位取反（包括符号位），再加 1。

比如 3 - 3 = 0 的计算过程如下：

1. 将公式看作 3 + (-3)；
2. 公式中 3 的二进制值是：00000011；
3. 公式中 -3 的二进制补码：绝对值 3 的二进制值是 00000011，按位取反得到 11111100，再 + 1 得到 11111101；
4. 将二进制值导入公式：00000011 + 11111101 == 100000000；
5. 二进制计算结果是 9 位，对于一个字节单元来说，左边的 1 是溢出的，会被自动舍弃，因此结果就变成了 00000000；



**十进制小数转二进制**

使用乘二取整法，比如十进制的 0.125 转为二进制值过程：

1. 将小数部分 0.125 乘以 2 得 0.25，然后取整数部分 0。即 0.125 * 2 = 0.25 → 0；
2. 再将小数部分 0.25 乘以 2 得0.5，然后取整数部分0。即 0.25 * 2 = 0.5 → 0；
3. 再将小数部分 0.5 乘以 2 得1，然后取整数部分1。即 0.5 * 2 = 1 → 1；
4. 一直重复乘二取整运算，直到无小数位出现为止；
5. 根据以上运算结果，得到的二进制值是 0.001；



## 八进制

八进制需要以 0 开头，比如 `012` 对应十进制的 10。



## 十六进制

十六进制需要以 0x 或 0X 开头，比如 `0x12` 对应十进制的 18。



## 基础数据类型

包括四个整数型（int、short、long、byte）、两个浮点型（float、double）、字符类型（char）与布尔型（boolean）。

基础数据类型都有对应的**包装类**（Wrapper Classes），将基本数据类型转换为包装类的过程称为**装箱**，包装类变为基本数据类型的过程称为**拆箱**。

|  类型   | 字节 | 位数 | 符号 |                最小值                |                最大值                | 默认值 | 说明                                                         |
| :-----: | ---- | :--: | :--: | :----------------------------------: | :----------------------------------: | :----: | ------------------------------------------------------------ |
|  byte   | 1    |  8   |  有  |            -128（-2^7^）             |            127（2^7^-1）             |   0    | 二进制补码表示的整数；                                       |
|  short  | 2    |  16  |  有  |           -32768（-2^15^）           |           32767（2^15^-1）           |   0    | 二进制补码表示的整数；                                       |
|   int   | 4    |  32  |  有  |       -2,147,483,648<br>-2^31^       |       2,147,483,647<br>2^31^-1       |   0    | 二进制补码表示的整数；                                       |
|  long   | 8    |  64  |  有  | -9,223,372,036,854,775,808<br>-2^63^ | 9,223,372,036,854,775,807<br>2^63^-1 |   0L   | 二进制补码表示的整数；<br/>`long b = 100L;`<br/>符号 L 理论上不分大小写，但是写成 l 容易与数字 1 混淆，不容易分辩，所以最好大写； |
|  float  | 4    |  32  |  有  |               1.4E-45                |             3.4028235E38             |  0.0F  | 单精度浮点数；<br/>需要添加后缀F/f<br>`float f1 = 234.5f;`   |
| double  | 8    |  64  |  有  |               4.9E-324               |        1.7976931348623157E308        |  0.0d  | 双精度浮点数；<br/>需要添加后缀D/d<br/>`double   d1  = 7D ;`<br/>`double   d2  = 7.;`  <br/>`double   d3  =  8.0;`  <br/>`double   d4  =  8.D;`  <br/>`double   d5  =  12.9867;` |
| boolean |      |  1   |  无  |                false                 |                 true                 | false  |                                                              |
|  char   | 2    |  16  |  无  |          \u0000<br/>十进制0          |       \uffff<br>2^16^-1=65535        |   0    | 使用Unicode字符；<br>`char c = '\u030A';`                    |



## 引用数据类型

是指一个引用变量（类似于 C 语言指针）指向一个对象或数组，引用数据类型的默认值都是 null；



## 科学计数法

格式：\[ ± ] **3.14** E \[ ± ] 指数

- 符号位（Sign）：数值的正负符号；
- 尾数（Mantissa）：上述的 **3.14** 就是尾数，整数部分只能有一位，小数部分至少有一位；
- 基（Base）：是指计算法中的 **E**，默认是 10； 
- 指数（Exponent）：是指 **E** 右侧的数值；
- 指数符号位（Exponent Sign）：用于表示指数的正负符号；

例如：

$3.14e+3$ 表示 $3.14×10^3 = 3140$，尾数是3.14、基数是10、指数是3、指数符号是加号；

$3.14e-3$ 表示 $3.14×10^{-3} = 0.00314$，尾数是3.14、基数是10、指数是3、指数符号是减号；



## 浮点型内存结构

浮点型数值分为 float 与 double，其内存结构如下表所示。

| 浮点型     | 符号占位（S） | 指数符号占位（ES） | 指数占位（E） | 尾数占位（M） | 总计 |
| ---------- | ------------- | ------------------ | ------------- | ------------- | ---- |
| **float**  | 1             | 1（0正，1负）      | 7             | 23            | 32   |
| **double** | 1             | 1（0正，1负）      | 10            | 52            | 64   |

比如一个十进制的 6.5 的内存结构如下：

- 整数部分 6 转化为二进制形式是 110；
- 小数部分 0.5 转化为二进制形式是 0.1；
- 所以 6.5 的二进制形式为 110.1；
- 将 110.1 转化为科学计数法形式，得 1.101 x 2^2^，符号位是 0，指数符号位是 0，指数是 2，尾数是 101；
- 6.5 在内存中的结构就是 `0 0 000001 000000000000000000000101` 



## 浮点型计算误差

例如：

```java
public class TestFloatError {
	
	public static void main(String[] args) {
		float f = 0.1f;
		double d = 1.0 / 10;
		System.out.println(f == d); // 期待返回 true

		float d1 = 423432423f;
		float d2 = d1 + 1;
		System.out.println(d1 == d2); // 期待返回 false
	}
}
```

输出结果：

```java
false
true
```

返回值与期待值不符，问题在于要将浮点数转为二进制存储在内存中，但其小数部分要用乘2取整法计算二进制值，此时会有误差产生。

结论：因为浮点数的存储存在误差，所以不能用 float/double 来执行计算、比较、表示金额，用 BigDecimal 替代 float/double 可完美解决误差问题。



## 浮点型精度损失

将 int 转 float、long 转 float、long 转 double 时可能会造成精度损失。

例如：

```java
public class TestFloatError {
	
	public strictfp static void main(String[] args) {
		float f = 0.1f;
		double d = 1.0 / 10;
		System.out.println(f == d); // false
		
		float d1 = 423432423f;
		float d2 = d1 + 1;
		System.out.println(d1 == d2); // true
	}
}
```

输出结果为 9.8765434E8，因为在虚拟机中使用科学计数法来存储 float（有效位为23位，精度为24位），整数 987654321 转换成二进制是 `111010110111100110100010110001` 共有30位，取前24位得到 `111010110111100110100010`，舍入处理为 `111010110111100110100011`，其实也就是 `111010110111100110100011000000`，转为十进制是 987654336，这就是导致精度损失的原因；



## 数据类型转换

是指在赋值的数值类型和被变量接收的数据类型不一致时发生的，需要从一种数据类型转换成另外一种数据类型。数据类型的转换可以分为隐式转换和显式转换。



### 隐式转换

也叫自动类型转换，

？？？？？



### 显式转换

也叫强制类型转换



------



# 运算符



## 算术运算符

| 算术运算符 | 描述         |
| :--------: | ------------ |
|     +      | 加法运算符   |
|     -      | 减法运算符   |
|     *      | 乘法运算符   |
|     /      | 除法运算符   |
|     ％     | 取余运算符   |
|     ++     | 自增一运算符 |
|     --     | 自减一运算符 |



## 关系运算符

| **关系运算符** |                                                     |
| :------------: | --------------------------------------------------- |
|       ==       | 如果两个操作数的值相等，则返回 true                 |
|       !=       | 如果两个操作数的值是否不等，则返回 true             |
|       >        | 如果左操作数的值大于右操作数的值，则返回 true       |
|       <        | 如果左操作数的值小于右操作数的值，则返回 true       |
|       >=       | 如果左操作数的值大于或等于右操作数的值，则返回 true |
|       <=       | 如果左操作数的值小于或等于右操作数的值，则返回 true |



## 位运算符

| **位运算符** |                                                              |
| :----------: | ------------------------------------------------------------ |
|      ＆      | 按位与操作符 <br/>参与运算的两个操作数的二进制值，按位进行与运算 |
|      \|      | 按位或操作符 <br/>参与运算的两个操作数的二进制值，按位进行或运算 |
|      ^       | 按位异或操作符 <br/>参与运算的两个操作数的二进制值，按位异或运算，值不同则为 1 ，相同则为 0 |
|      〜      | 按位取反运算符 <br/>翻转操作数的二进制值中的每一位，把 0 变成 1，1 变成 0 |
|      <<      | 按位左移运算符 <br/>`m<<n` 表示把数字 m 在无溢出的前提下乘以 2^n^ <br/>`1<<5=32` |
|      >>      | 按位右移运算符 <br/>`m>>n` 表示把数字 m 除以2^n^；<br/>原来是正数的还是正数，负数还是负数；<br/>如果操作符左侧是奇数，则结果是整数的商（整数除以整数所得的值）；<br/>`10>>1=5` <br/>`-10>>1=-5` <br/>`1>>5=0` |
|     >>>      | 无符号右移运算符 <br/>先把数字转换为二进制值，然后进行右移位操作，如果是负数则结果会变成正数；<br/>`-2>>>1=2147483647` |



## 逻辑运算符

| **逻辑运算符** |                                                              |
| :------------: | ------------------------------------------------------------ |
|       &&       | 逻辑与运算符 <br/>两个操作数同时为 true 时返回 true，否则返回 false |
|     \| \|      | 逻辑或操作符 <br/>两个操作数中任何一个为 true 时返回 true，否则返回 false |
|       ！       | 逻辑非运算符 <br/>用来反转操作数的逻辑状态                   |



## 赋值运算符

| 运算符 |                                                              |
| :----: | ------------------------------------------------------------ |
|   =    | 赋值运算符 <br/>将右操作数的值赋给左侧操作数                 |
|   +=   | 先执行加法运算，再执行赋值操运算 <br/>先把左操作数和右操作数相加，再将结果赋值给左操作数 |
|   -=   | 先执行减法运算，再执行赋值操运算 <br/>先把左操作数和右操作数相减，再将结果赋值给左操作数 |
|   *=   | 先执行乘法运算，再执行赋值操运算 <br/>先把左操作数和右操作数相乘，再将结果赋值给左操作数 |
|   /=   | 先执行除法运算，再执行赋值操运算 <br/>先把左操作数和右操作数相除，再将结果赋值给左操作数 |
|  ％=   | 先执行取模运算，再执行赋值操运算 <br/>先把左操作数和右操作数取模，再将结果赋值给左操作数 |
|  <<=   | 左移位赋值运算符                                             |
|  >>=   | 右移位赋值运算符                                             |
|  ＆=   | 按位与赋值运算符                                             |
|   ^=   | 按位异或赋值操作符                                           |
|  \|=   | 按位或赋值操作符                                             |



## 条件运算符

| **条件运算符** |                                                              |
| :------------: | ------------------------------------------------------------ |
|       ?:       | 三元运算符，如果条件表达式为 true ，则执行冒号左侧的表达式，否则执行冒号右侧的表达式 |
|   instanceof   | 如果运算符的左操作数是否其右操作数（类/接口）的实例对象，返回 true |



## 运算符优先级

| **类别** | 操作符                                     | 优先级   |
| -------- | ------------------------------------------ | -------- |
| 后缀     | () [] . （点操作符）                       | 左到右   |
| 一元     | expr++ expr--                              | 从左到右 |
| 一元     | ++expr --expr + - ～ ！                    | 从右到左 |
| 乘性     | * /％                                      | 左到右   |
| 加性     | + -                                        | 左到右   |
| 移位     | >> >>>  <<                                 | 左到右   |
| 关系     | > >= < <=                                  | 左到右   |
| 相等     | == !=                                      | 左到右   |
| 按位与   | ＆                                         | 左到右   |
| 按位异或 | ^                                          | 左到右   |
| 按位或   | \|                                         | 左到右   |
| 逻辑与   | &&                                         | 左到右   |
| 逻辑或   | \| \|                                      | 左到右   |
| 条件     | ？：                                       | 从右到左 |
| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ，                                         | 左到右   |



# 包（package）

包机制是区别类名的命名空间，包名和类名构成了类的全限定名称，包对于类，相当于文件夹对于文件的作用，把功能相似的类与接口放在同一个包中。



## 定义包

在类中的第一句非注释代码，使用 package + 包名（域名倒着写即可，再加上模块名）。

例如：

```java
package java.util.List;
```



## 导入包

想使用其他包中的类，需要使用 import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。

虚拟机会默认导入 java.lang包下所有的类，因此这些类可以直接使用。

如果导入两个同名的类，只能用包名 + 类名来显示调用相关类。

例如：

```java
import java.sql.Date;
import java.util.*; // 导入包下所有的类，不会影响程序运行速度

public class TestImport {
	public static void main(String[] args) {
		Date d0; // 这里指的是java.sql.Date
		java.util.Date d1 = new java.util.Date(); // java.util.Date因为和java.sql.Date类同名，需要完整路径
		System.out.println(d1);
		List<String> list = new ArrayList<String>(); // java.util包的非同名类不需要完整路径
	}
}
```



## 静态导入

英文 static import，是Java5新特性，可以只导入指定类的静态属性和静态方法。

例如：

```java
import static java.lang.Math.*; // 导入Math类的所有静态属性
import static java.lang.Math.PI; // 导入Math类的PI属性

public class TestImport1 {
    public static void main(String [] args){
        System.out.println(PI);
        System.out.println(random()); // 使用静态方法
    }
}
```



------



# 变量

变量就是代表一个可操作的存储空间，可通过变量名来访问对应的存储空间。

格式：

```java
type  varName [=value][,varName[=value]...]; 
数据类型  变量名  [=初始值] [,变量名  [=初始值]…];
```



## 实例变量

也叫成员变量、字段、属性，是指在类中没有被 static 关键字修饰的变量。



## 静态变量

也叫类变量与静态字段，是指在类中以 static 关键字声明的变量，在类加载时就完成了内存空间分配。



## 常量

是指用 final 修饰的变量，一旦被初始化后就不能再更改其值。



## 字面量

用于表示固定的值，可以分为整型字面值、浮点字面值、字符和字符串字面值、特殊字面值、null；



## 直接量

是指在程序中通过源代码直接给出的值，例如在 `int a = 5;` 代码中，为变量 a 所分配的初始值 5 就是一个直接量。

能指定直接量的只有三种类型：基本数据类型、字符串、null。



------



# 方法

方法是从属于类和对象的，用于定义类和实例对象的行为特征与功能实现。

方法由修饰符、方法名、方法体、返回值类型、参数列表组成：

```java
[修饰符1 修饰符2 …] [返回值类型] 方法名(形式参数列表) {
	…
}
```

形参：在方法声明时用于接收外界传入的数据；

实参：调用方法时实际传给方法的数据；

如果实参是基本数据类型，则传递的是基本数据类型的副本值；

如果实参是引用数据类型，则传递的是该对象的引用，并不是改对象本身；

可变参数：是Java5新特性，是指方法中参数的个数是不确定的，但必须定义在参数列表的最后；



## 构造方法

是一种特殊的实例方法，在创建对象时调用执行初始化操作，构造方法名与类名一致且没有返回值。



## 实例方法

也叫成员方法，是指在类中没有被 static 修饰的方法。



## 析构方法

是指 Object中 finalize() 方法，可以用来执行释放资源操作，在一个对象被GC回收前，虚拟机会调用析构方法。



## 静态方法

是指使用 static 关键字修饰的方法，其方法体中只能访问静态变量和静态方法。



## 虚拟扩展方法

是Java8新特性，英文 Virtual extension methods，使用default关键字修饰接口中的方法，被修饰的方法可以直接写方法体。

在接口或其实现类中可以重写default方法，也可以不重写；

如果一个类实现了多个接口，且接口中有同名的 default 方法，此时实现类编译会报错，解决方法就是在实现类中重写接口中同名的default方法。

```java
public interface List<E> extends Collection<E> {
    ...
      
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.ORDERED);
    }
}
```



# 接口（Interface）



## 普通接口

接口以 interface关键字来声明，是抽象方法的集合，不可以有方法的实现（但 default方法即虚拟扩展方法除外），可以有静态变量，不可以有实例变量；

接口中每一个方法也是抽象的，接口中的抽象方法会被隐式的指定为 `public abstract`。

接口中可以含有变量，但是接口中的变量会被隐式的指定为 `public static final` 变量。



## 标记接口

英文 Marker Interface，也叫标签接口（Tag Interface），是一个空接口（不包含任何方法与变量），被标记的类支持某种特定的功能或操作。

| 标记接口               | 说明                                              |
| ---------------------- | ------------------------------------------------- |
| java.io.Serializable   | 被标记的类支持序列化与反序列化操作                |
| java.lang.Cloneable    | 被标记的类支持深拷贝操作，即重写了 clone() 方法   |
| java.util.RandomAccess | 被标记的类支持快速随机访问，即使用for循环遍历最快 |
| java.rmi.Remote        | 被标记的类中方法可以从非本地虚拟机上调用          |



------



# 类（class）

类是一个模板，用于描述一类对象的行为和状态。



## 内部类（Inner Class）

内部类是一个独立的类，编译后内部类会被编译成独立的 class 文件，class 文件名使用外部类的类名+符号\$+内部类名（如 Outer\$Inner.class）。



### 成员内部类

也叫非静态内部类，是指没有用 static 修饰的内部类，是所属外部类中的一个成员，角色与外部类中的成员变量（实例变量）相同。

例如：

```java
public class TestMemberInnerClass {
	private static String NAME = "age is "; // 内部类能访问 静态变量
	private int value = 77; // 内布类能访问 实例变量
	
	public class MemberInner { // 成员内部类
		public void test() {
			System.out.println(NAME + value);
		}
	}
	
	public static void main(String[] args) {
		new TestMemberInnerClass().new MemberInner().test();
	}
}
```



### 静态内部类

静态内部类是指使用 static 修饰的内部类，不能访问所属类的实例变量，只能访问静态变量。

例如：

```java
class TestStaticOuter {
	public static int VAR = 0;
	
	static class StaticInner { // 静态内部类
		public void test() {
			System.out.println(TestStaticOuter.VAR); // 只能访问静态变量
		}
	}
	
	public static void main(String[] args) {
		new TestStaticOuter.StaticInner().test();
	}
}
```



### 局部内部类

是指定义在方法中或作用域里面的内部类，能访问所属类中的实例变量、实例方法中的局部变量。

例如：

```java
public class TestLocalInnerClass {
	
	private int value = 55; // 内部类可以访问 实例变量
	private static int m = 22; // 内部类可以访问 静态变量
	
	public void test() {
		final int var = 100; // 内部类可以访问 final修饰的局部变量
		String name = "age is "; // 内部类可以访问 局部变量
		
		class LocalInner { // 局部内部类
			public void test(int n) {
				value = 55;
				m = 22;
				System.out.println(name + (var + n + value + m)); // age is 277
			}
		}
		
		new LocalInner().test(100);
	}
	
	public static void main(String[] args) {
		new TestLocalInnerClass().test();
	}
}
```



### 匿名内部类

又叫匿名类，是指没有名字的内部类，只能使用 new 关键字创建，不能有构造方法、不能定义静态变量与静态方法。

```java
public class TestNonameInnerClass {
	
	public static void main(String[] args) {
		Runnable r = new Runnable() { // 匿名类
			// 不能有构造方法
      // 不能定义静态变量与静态方法
      
			@Override
			public void run() {
				System.out.println("运行线程 ..");
			}
		};
		new Thread(r).start();
	}
}
```



### 记录类

领域模型类或 POJO 类，是Java14新特性。

Java编译器将为 record 类型生成 equals()，hashCode()，toString() 方法，以及生成适当的构造方法，并且为所有字段生成 getter 和 setter 。

```java
record Point(int x, int y) {}
```



------



# 字节码

[字节码详解](https://blog.csdn.net/laokerr/article/details/108966375)

？？？？？





## javap

用于反编译 class 字节码文件

javap -c VerifyTest.class





## 符号引用与直接引用



### 符号引用（Symbolic References）

在编译阶段，编译器并不知道已引用类的实际地址，只能使用符号引用（任何形式的字面量，只要能无歧义的定位到目标即可）来代替实际地址；

在 Java虚拟机规范的Class文件格式中说明了符号引用的字面量定义，因此各种虚拟机内存布局的实现可能不同，但符号引用都是一致的；



### 直接引用（Direct References）

直接引用对象可以是：

- 直接指向目标的指针（例如：指向Class对象、类变量、类方法的直接引用）；

- 相对偏移量（比如：指向实例变量、实例方法的直接引用都是偏移量）；

- 只要使用时能无歧义的定位到目标即可；



# 对象（Object）

Java对象是类的实例，有状态和行为，对象在内存中由三部分组成：对象头、实例数据、对齐填充。



## 对象头

对象头又分为：Mark Word（标记字段）、Class Pointer（类型指针）、数组长度（如果是数组）。



### Mark Word

标记字段，里面存储了对象的 hashcode、锁状态标识、持有锁的线程ID、GC分代年龄等；

在32为的虚拟机中，Mark Word的组成如下图所示：

<img src="./01.Java_part1.assets/734446-20221021101846594-410642132.png" alt="image" style="zoom:67%;" />



### Class Pointer

类型指针，用于存储对象所对应的Class对象的指针；

指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位；

64位的JVM会比32位的JVM多耗费50%的内存，可使用`-XX:+UseCompressedOops`开启指针压缩（oop即ordinaryobject pointer普通对象指针）；



### 数据长度

如果对象是一个数组，则表示数组长度；



## 实例数据

是对象实际有效信息，包括本类信息和父类信息等；



## 对齐填充

因为在《Java虚拟机规范》中要求对象起始地址必须是 8 字节的整数倍，所以这部分仅作为对齐使用，无特殊用途；



------



# 字符串



## 字符（Char）

字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字符号、控制符号等。



## 字符集（Charset）

是指多个字符的集合。不同的字符集包含的字符个数不一样、包含的字符不一样、对字符的编码方式也不一样。



### ASCII

ASCII码用7位表示，只能表示128个字符。



### ISO-8859-1

又称Latin-1或“西欧语言”，是单字节编码，但这是一个8位的容器，能表示256个字符。因为ASCII只能表示128个字符，显示字符有限，所以ISO-8859-1扩展了ASCII编码，在ASCII编码之上又增加了西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号，是向下兼容ASCII编码的。



### Unicode

Unicode字符集兼容ASCII字符集，分为基本字符（Classic characters）和补充字符（supplementary characters）。

Unicode字符集被分为17个区域，一个区域叫一个平面（plane），每个平面共有 216 = 65536 个字符，共有 17 × 65536 = 1114112 个代码点，代码点的范围是 `0`～`0x10FFFF`（= 1114111），`0x10FFFF` 最高两位是 `0x10`，由`0`到`0x10`，刚好17个平面，这些代码点只被定义使用了一小部分，其中第一个平面的范围是`0x000000`到`0x00FFFF`，叫做基本多语言平面（BMP），包含了最常用的字符和符号、第二、三、四平面作补充了一些字符、第五到十四个平面尚未分配、第十五个平面主要包含非图形化字符、第十六、十七个平面叫做私有使用区域平面（PUA），供第三方自定义。



## 字符集编码（Charset Encoding）

字符编码是指一种映射规则，根据这个映射规则可以将某个字符映射成其他形式的数据以便在计算机中存储和传输，每种字符集都有自己的字符编码规则。



### GBK

英文 Chinese Internal Code Specification，即汉字内码扩展规范，于1995年制定。主要扩展了GB2312，在GB2312的基础上又加了更多的汉字，一共收录了21003个汉字，GBK是向下兼容GB2312编码的。



### GBK18030

GB18030全称汉字内码扩展规范，是现在最新的内码字集于2000年发布，并于2001年强制执行，包含了中国大部分少数民族的语言字符，收录汉字数超过70000余个。主要采用单字节、双字节、四字节对字符编码，向下兼容GB2312和GBK的。



### UTF-8编码

因为Unicode代码点值的范围是`0`～`0x10FFF`，那么可以直接用3个字节来表示。但使用定长的3个字节存储一个代码点太浪费存储空间。UTF-8编码使用8bit作为一个代码单元，是变长的字符集编码。

**FSS-UTF (1992) / UTF-8 (1993)**

| Number of bytes | First code point | Last code point |  Byte 1  |  Byte 2  |  Byte 3  |  Byte 4  |  Byte 5  |  Byte 6  |
| :-------------: | :--------------: | :-------------: | :------: | :------: | :------: | :------: | :------: | :------: |
|        1        |      U+0000      |     U+007F      | 0xxxxxxx |          |          |          |          |          |
|        2        |      U+0080      |     U+07FF      | 110xxxxx | 10xxxxxx |          |          |          |          |
|        3        |      U+0800      |     U+FFFF      | 1110xxxx | 10xxxxxx | 10xxxxxx |          |          |          |
|        4        |     U+10000      |    U+1FFFFF     | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |          |          |
|        5        |     U+200000     |    U+3FFFFFF    | 111110xx | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |          |
|        6        |    U+4000000     |   U+7FFFFFFF    | 1111110x | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |

可以看出，Unicode中代码点可以用7bit表示的字符在UTF-8中均用1字节表示，代码点可以分别用8到11（8、9、10、11）bit表示的字符在UTF-8中均用2字节表示，依次类推。总的来说UTF-8与Unicode兼容，但是可以表示比目前的Unicode更多的字符。

下面举例说明UTF-8与Unicode的映射方式。

汉字“你”的Unicode代码点是`Ox4F60`，其二进制形式如下所示（下划线用于优化阅读体验，无特殊意义）

```ini
0100_1111 0110_0000
```

至少需要15bit才能表示“你”，所以其对应的UTF-8编码需要3字节：

```ini
1110_0100 10_111101 10_100000
```

即 `E4BDA0`，把每个下划线后的bit位提取出来放在一起，就是Unicode中对应的代码点了。



### UTF-16

java平台内部统一使用UTF-16编码。UTF-16使用16bit作为一个代码单元，是变长编码。



### UCS-2

定长编码，使用2个字节表示字符，是UTF-16的子集，只能表示Unicode中代码点位于`0x0000`～`0xFFFF`中字符。



## 代码点（Code Point）

也叫码点、内码、码值，是指在某个字符集中，根据某种编码规则将字符编码后得到的值。

ASCII字符集中，字母A的编号是65，这个65就是字符A在ASCII字符集中的代码点。

Unicode字符集中，字符 “严” 的代码点是 `U+0x4E25`。

```java
public class TestcodePoint1 {
	public static void main(String[] args) {
		String str = "\uD83D\uDE03"; // 第一个字符与第二个字符合起来作为一个代码点，😀
		int length = str.length(); // 字符个数
		int count = str.codePointCount(0, str.length()); // 代码点个数
		System.out.println(str + ", " + length + ", " + count); // 2, 1
	}
}
```



## 代码单元（Code Unit）

用来存储代码点，是编码时使用的最小单元。



## String类

| 方法                                                         | 返回值        | 说明                                                         |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ |
| String()                                                     |               | 初始化一个空字符串                                           |
| String(<br/>String original<br/>)                            |               | 使用指定的字符序列初始化一个字符串                           |
| String(<br/>char value[]<br/>)                               |               | 将一个字符数组转为字符串                                     |
| String(<br/>char value[], <br/>int offset, <br/>int count<br/>) |               | 将一个字符数组转为字符串                                     |
| String(<br/>int[] codePoints, <br/>int offset, <br/>int count<br/>) |               | 使用代码点数组初始化一个字符串                               |
| String(<br/>byte bytes[], <br/>int offset, <br/>int length, <br/>String charsetName<br/>) |               | 将一个字节数组转为一个字符串；<br/>bytes：字节数组；<br/>offset：起始位置；<br/>length：字节数；<br/>charsetName：字符集编码； |
| String(<br/>byte bytes[], <br/>int offset, <br/>int length, <br/>Charset charset<br/>) |               | 将一个字节数组转为一个字符串；<br/>bytes：字节数组；<br/>offset：起始位置；<br/>length：字节数；<br/>charset：字符集编码； |
| String(<br/>byte bytes[], <br/>String charsetName<br/>)      |               | 将一个字节数组转为一个字符串；<br/>bytes：字节数组；<br/>charsetName：字符集编码； |
| String(<br/>byte bytes[], <br/>Charset charset<br/>)         |               | 将一个字节数组转为一个字符串；<br/>bytes：字节数组；<br/>charset：字符集编码； |
| String(<br/>byte bytes[], <br/>int offset, <br/>int length<br/>) |               | 将一个字节数组转为一个字符串；<br/>bytes：字节数组；<br/>offset：起始位置；<br/>length：字节数； |
| String(<br/>byte bytes[]<br/>)                               |               | 将一个字节数组转为一个字符串；<br/>bytes：字节数组；         |
| String(<br/>StringBuffer buffer<br/>)                        |               | 将参数转为一个字符串                                         |
| String(<br/>StringBuilder builder<br/>)                      |               | 将参数转为一个字符串                                         |
| length()                                                     | int           | 返回字符个数                                                 |
| isEmpty()                                                    | boolean       | 返回 true表示字符个数为零                                    |
| charAt(int index)                                            | char          | 返回字符串中制定位置上的字符；<br/>index：位置信息，其范围从 `0` 到 `length()-1`； |
| codePointAt(int index)                                       | int           | 返回指定索引处的字符（Unicode 代码点）<br/>index：位置信息，其范围从 `0` 到 `length()-1`； |
| codePointBefore(int index)                                   | int           |                                                              |
| codePointCount(<br/>int beginIndex, <br/>int endIndex<br/>)  | int           | 返回字符串中代码点的个数                                     |
| offsetByCodePoints(<br/>int index, <br/>int codePointOffset<br/>) | int           | 返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引；<br/>index：要偏移的索引；<br/>codePointOffset：代码点中的偏移量； |
| void getChars(<br/>int srcBegin, <br/>int srcEnd, <br/>char dst[], <br/>int dstBegin<br/>) | void          | 从字符串的srcBean位置开始复制字符，到srcEnd位置结束，将字符数组复制到第三个参数数组中 |
| getBytes(<br/>String charsetName<br/>)                       | byte[]        | 将字符串转为字节数组；<br/>charsetName：字符集编码；         |
| getBytes(<br/>Charset charset<br/>)                          | byte[]        | 将字符串转为字节数组                                         |
| getBytes()                                                   | byte[]        | 将字符串转为字节数组                                         |
| contentEquals(<br/>StringBuffer buf<br/>)                    | boolean       | 将此字符串与指定的StringBuffer进行比较。当且仅当此字符串表示与指定的StringBuffer相同的字符序列时，结果为true。此方法在StringBuffer上同步。 |
| contentEquals(<br/>CharSequence cs<br/>)                     | boolean       | 将此字符串与指定的StringBuffer进行比较。当且仅当此字符串表示与指定的StringBuffer相同的字符序列时，结果为true。此方法在StringBuffer上同步。 |
| equalsIgnoreCase(<br/>String anotherString<br/>)             | boolean       | 在忽略大小写的前提下判断字符串是否相等                       |
| compareToIgnoreCase(<br/>String str<br/>)                    | int           | 按字典顺序比较两个字符串，忽略字符的大小写                   |
| regionMatches(<br/>int toffset, <br/>String other, <br/>int ooffset,<br/>int len<br/>) | boolean       | 判断两个字符串区域是否相等；<br/>toffset：当前字符串中范围的的起始偏移量；<br/>other：字符串参数；<br/>ooffset：字符串参数 other 中范围的的起始偏移量；<br/>len：要比较的字符数； |
| regionMatches(<br/>boolean ignoreCase, <br/>int toffset,<br/>String other, <br/>int ooffset, <br/>int len<br/>) | boolean       | 判断两个字符串区域是否相等；<br/>ignoreCase：true 表示忽略大小写；<br/>toffset：当前字符串中范围的的起始偏移量；<br/>other：字符串参数；<br/>ooffset：字符串参数 other 中范围的的起始偏移量；<br/>len：要比较的字符数； |
| startsWith(<br/>String prefix, <br/>int toffset<br/>)        | boolean       | 判断字符串中指定位置上是否与第一个参数相等                   |
| startsWith(<br/>String prefix<br/>)                          | boolean       | 判断字符串中开始位置上是否与第一个参数相等                   |
| endsWith(<br/>String suffix<br/>)                            | boolean       | 判断字符串是否以第一个参数结尾                               |
| indexOf(<br/>int ch<br/>)                                    | int           | 返回指定字符第一次出现的字符串内的索引                       |
| indexOf(<br/>int ch, <br/>int fromIndex<br/>)                | int           | 返回指定字符（第一个参数）首次出现在字符串内的索引位置；<br/>ch：字符；<br>fromIndex：开始搜索的位置； |
| lastIndexOf(<br/>int ch<br/>)                                | int           | 返回指定字符（第一个参数）最后一次出现在字符串内的索引位置；<br/>ch：开始搜索的位置； |
| lastIndexOf(<br/>int ch, <br/>int fromIndex<br/>)            | int           | 返回指定字符（第一个参数）最后一次出现在字符串内的索引位置；<br/>ch：开始搜索的位置；<br/>fromIndex：开始搜索的位置； |
| indexOf(<br/>String str<br/>)                                | int           | 搜索字符串中第一个参数出现的位置                             |
| indexOf(<br/>String str, <br/>int fromIndex<br/>)            | int           | 从字符串的指定位置开始搜索第一个参数出现的位置               |
| lastIndexOf(<br/>String str<br/>)                            | int           | 从字符串右侧开始，向左搜索参数字符串出现的位置               |
| lastIndexOf(<br/>String str, <br/>int fromIndex<br/>)        | int           | 从字符串右侧指定位置开始，向左搜索第一个参数出现的位置       |
| substring(<br/>int beginIndex<br/>)                          | String        | 从字符串的指定位置开始截取字符串                             |
| substring(<br/>int beginIndex, <br/>int endIndex<br/>)       | String        | 从字符串中的指定位置开始截取，直到endIndex-1为止； <br/>截取后的字符串长度为 endIndex-beginIndex； |
| subSequence(<br/>int beginIndex, <br/>int endIndex<br/>)     | CharSequence  | 从字符串中的指定位置开始截取，直到endIndex-1为止； <br/>截取后的字符串长度为 endIndex-beginIndex； |
| concat(<br/>String str<br/>)                                 | String        | 将字符串参数拼接到当前字符串的右端                           |
| replace(<br/>char oldChar, <br/>char newChar<br/>)           | String        | 使用第二个参数替换字符串中的第一个参数                       |
| contains(<br/>CharSequence s<br/>)                           | boolean       | 判断字符串中是否包含参数字符串，返回true表示包含，返回false表示不包含。 |
| replaceFirst(<br/>String regex, <br/>String replacement<br/>) | String        | 用第二个参数替换字符串中与regex匹配的内容；<br/>regex - 要匹配此字符串的正则表达式；<br/>replacement - 要替换每个匹配的字符串； |
| replaceAll(<br/>String regex, <br/>String replacement<br/>)  | String        | 用第二个参数来替换字符串中与regex匹配的内容；<br>regex：要匹配此字符串的正则表达式；<br/>replacement：要替换每个匹配的字符串； |
| replace(<br/>CharSequence regex,<br/>CharSequence replacement<br/>) | String        | 用第二个参数来替换字符串中与regex匹配的内容；<br/>regex：要匹配此字符串的正则表达式；<br/>replacement：要替换每个匹配的字符串； |
| join(<br/>CharSequence delimiter,<br/>CharSequence... elements<br/>) | static String | 将第一个参数作为分隔符，把参数数组中的元素拼成一个字符串     |
| join(<br/>CharSequence delimiter,<br/>Iterable<? extends CharSequence> elements<br/>) | static String | 将第一个参数作为分隔符，把参数数组中的元素拼成一个字符串     |
| toLowerCase(<br/>Locale locale<br/>)                         | String        | 将字符串转为小写                                             |
| toLowerCase()                                                | String        | 将字符串转为小写                                             |
| toUpperCase(<br/>Locale locale<br/>)                         | String        | 将字符串转为大写                                             |
| toUpperCase()                                                | String        | 将字符串转为大写                                             |
| trim()                                                       | String        | 删除字符串二端的空格字符                                     |
| toCharArray()                                                | char[]        | 将字符串转为一个字符数组                                     |
| format(<br/>String format, <br/>Object... args<br/>)         | static String | 使用指定格式与参数，来格式化当前字符串                       |
| format(<br/>Locale l, <br/>String format, <br/>Object... args<br/>) | static String | 使用指定区域、格式与参数，来格式化当前字符串                 |
| valueOf(<br/>Object obj<br/>)                                | static String | 将字符数组转为一个字符串                                     |
| valueOf(<br/>char data[]<br/>)                               | static String | 将字符数组转为一个字符串                                     |
| valueOf(<br/>char data[], <br/>int offset, <br/>int count<br/>) | static String | 将字符数组转为一个字符串                                     |
| copyValueOf(<br/>char data[], <br/>int offset, <br/>int count<br/>) | static String | 将字符数组转为一个字符串                                     |
| copyValueOf(<br/>char data[]<br/>)                           | static String | 将字符数组转为一个字符串                                     |
| valueOf(<br/>char c<br/>)                                    | static String | 将字符转为一个字符串                                         |
| intern()                                                     | String        | 返回字符串的规范表示形式；<br/>字符串池最初为空，由String类单独维护；<br/>当调用intern方法时，如果池中已经包含一个由equals（object）方法确定的与此string对象相等的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。<br/>因此，对于任意两个字符串s和t，s.intern()==t.intern()为真，当且仅当s.equals(t)为真。<br/>所有文字字符串和字符串值常量表达式都是内部的。 |



------



# 数值型



## BigDecimal

不可变的、任意精度的有符号十进制数，实现了任意精度的浮点运算。

scale 表示保留的小数位。

| 方法                                                         | 返回值       | 说明                                                         |
| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ |
| ROUND_UP                                                     |              | 向上取整                                                     |
| ROUND_DOWN                                                   |              | 向下取整，直接删除多余的小数位，如2.35会变成2.3              |
| ROUND_FLOOR                                                  |              | 向负无穷方向舍入                                             |
| ROUND_CEILING                                                |              | 向正无穷方向舍入                                             |
| ROUND_HALF_UP                                                |              | 四舍五入 2.35 变成 2.4                                       |
| ROUND_HALF_DOWN                                              |              | 向（距离）最近的一边舍入                                     |
| ROUND_HALF_EVEN                                              |              | 银行家舍入；<br>四舍六入五考虑，五后非零就进一，<br/>五后为零看奇偶，五前为偶应舍去，五前为奇要进一 |
| ROUND_UNNECESSARY                                            |              | 断言请求的操作具有精确的结果，因此不需要舍入。               |
| BigDecimal(char[] in, int offset, int len)                   |              | 构造方法                                                     |
| BigDecimal(char[] in, int offset, int len, MathContext mc)   |              | 构造方法                                                     |
| BigDecimal(char[] in)                                        |              | 构造方法                                                     |
| BigDecimal(char[] in, MathContext mc)                        |              | 构造方法                                                     |
| BigDecimal(String val)                                       |              | 构造方法                                                     |
| BigDecimal(String val, MathContext mc)                       |              | 构造方法                                                     |
| BigDecimal(double val)                                       |              | 构造方法                                                     |
| BigDecimal(double val, MathContext mc)                       |              | 构造方法                                                     |
| BigDecimal(BigInteger val)                                   |              | 构造方法                                                     |
| BigDecimal(BigInteger val, MathContext mc)                   |              | 构造方法                                                     |
| BigDecimal(BigInteger unscaledVal, int scale)                |              | 构造方法                                                     |
| BigDecimal(BigInteger unscaledVal, int scale, MathContext mc) |              | 构造方法                                                     |
| BigDecimal(int val)                                          |              | 构造方法                                                     |
| BigDecimal(int val, MathContext mc)                          |              | 构造方法                                                     |
| BigDecimal(long val)                                         |              | 构造方法                                                     |
| BigDecimal(long val, MathContext mc)                         |              | 构造方法                                                     |
| valueOf(long unscaledVal, int scale)                         | BigDecimal   | 静态方法                                                     |
| valueOf(long val)                                            | BigDecimal   | 静态方法                                                     |
| valueOf(double val)                                          | BigDecimal   | 静态方法                                                     |
| add(BigDecimal augend)                                       | BigDecimal   | 加法运算                                                     |
| add(BigDecimal augend, MathContext mc)                       | BigDecimal   |                                                              |
| subtract(BigDecimal subtrahend)                              | BigDecimal   | 减法运算                                                     |
| subtract(BigDecimal subtrahend, MathContext mc)              | BigDecimal   |                                                              |
| multiply(BigDecimal multiplicand)                            | BigDecimal   | 乘法运算                                                     |
| multiply(BigDecimal multiplicand, MathContext mc)            | BigDecimal   |                                                              |
| divide(BigDecimal divisor, int scale, int roundingMode)      | BigDecimal   | 除法运算                                                     |
| divide(BigDecimal divisor, int scale, RoundingMode roundingMode) | BigDecimal   |                                                              |
| divide(BigDecimal divisor, int roundingMode)                 | BigDecimal   |                                                              |
| divide(BigDecimal divisor, RoundingMode roundingMode)        | BigDecimal   |                                                              |
| divide(BigDecimal divisor)                                   | BigDecimal   | 除法运算                                                     |
| divide(BigDecimal divisor, MathContext mc)                   | BigDecimal   |                                                              |
| divideToIntegralValue(BigDecimal divisor)                    | BigDecimal   |                                                              |
| divideToIntegralValue(BigDecimal divisor, MathContext mc)    | BigDecimal   |                                                              |
| remainder(BigDecimal divisor)                                | BigDecimal   | 当前浮点数除以参数，得到余数                                 |
| remainder(BigDecimal divisor, MathContext mc)                | BigDecimal   |                                                              |
| divideAndRemainder(BigDecimal divisor)                       | BigDecimal[] | 当前浮点数除以参数，得到商和余数；                           |
| divideAndRemainder(BigDecimal divisor, MathContext mc)       | BigDecimal[] |                                                              |
| pow(int n)                                                   | BigDecimal   | 求当前浮点数的 n 次方，即 $a^n$                              |
| pow(int n, MathContext mc)                                   | BigDecimal   |                                                              |
| abs()                                                        | BigDecimal   | 返回绝对值                                                   |
| abs(MathContext mc)                                          | BigDecimal   |                                                              |
| negate()                                                     | BigDecimal   | 正负号取反                                                   |
| negate(MathContext mc)                                       | BigDecimal   |                                                              |
| plus()                                                       | BigDecimal   |                                                              |
| plus(MathContext mc)                                         | BigDecimal   |                                                              |
| signum()                                                     | int          | 返回1表示正号；<br/>返回0表示零；<br/>返回-1表示负号；       |
| scale()                                                      | BigDecimal   |                                                              |
| precision()                                                  | BigDecimal   |                                                              |
| unscaledValue()                                              | BigDecimal   |                                                              |
| round(MathContext mc)                                        | BigDecimal   |                                                              |
| setScale(int newScale, RoundingMode roundingMode)            | BigDecimal   |                                                              |
| setScale(int newScale, int roundingMode)                     | BigDecimal   | 设置浮点数的小数位数与舍入模式；<br/>newScale：保留小数位数；<br/>roundingMode：舍入模式；<br/>返回新的浮点数对象 |
| setScale(int newScale)                                       | BigDecimal   |                                                              |
| movePointLeft(int n)                                         | BigDecimal   |                                                              |
| movePointRight(int n)                                        | BigDecimal   |                                                              |
| scaleByPowerOfTen(int n)                                     | BigDecimal   |                                                              |
| stripTrailingZeros()                                         | BigDecimal   |                                                              |
| min(BigDecimal val)                                          | BigDecimal   | 返回最小值                                                   |
| max(BigDecimal val)                                          | BigDecimal   | 返回最大值                                                   |
| toEngineeringString()                                        | String       |                                                              |
| toPlainString()                                              | String       |                                                              |
| toBigInteger()                                               | BigInteger   |                                                              |
| toBigIntegerExact()                                          | BigInteger   |                                                              |
| fractionOnly()                                               | boolean      |                                                              |
| longValueExact()                                             | long         |                                                              |
| ulp()                                                        | BigDecimal   |                                                              |



## BigInteger

不可变的大整数，实现了任意精度的整数运算；

| 方法                                                 | 返回值       | 说明                                                         |
| ---------------------------------------------------- | ------------ | ------------------------------------------------------------ |
| BigInteger(byte[] val)                               |              | 构造方法；<br/>将包含 BigInteger 的二进制补码表示的字节数组转换为BigInteger；<br>可以使用 toByteArray() 方法生成 BigInteger 字节数组； |
| BigInteger(int signum, byte[] magnitude)             |              | 构造方法；<br/>将包含 BigInteger 的二进制补码表示的字节数组转换为BigInteger；<br/>可以使用 toByteArray() 方法生成 BigInteger 字节数组；<br/>signum：可以是 1，0，-1 分别表示正数、零、负数； |
| BigInteger(String val, int radix)                    |              | 构造方法；<br/>val：数字字符串，一定要与 radix 参数匹配；<br/>radix：几进制数； |
| BigInteger(String val)                               |              | 构造方法；<br/>val：十进制数的字符串；                       |
| BigInteger(int numBits, Random rnd)                  |              | 构造方法；<br/>随机生成一个正BigInteger，整数可能是质数；<br/><br/>numBits：整数二进制值的最长位数；<br/>rnd：随机比特源，选择用来进行质数测试的候选数； |
| BigInteger(int bitLength, int certainty, Random rnd) |              | 构造方法；<br/>随机生成一个正BigInteger，整数可能是质数<br/><br/>bitLength：整数二进制值的位数；<br/>certainty：调用方允许的不确定性的度量；<br/>rnd：随机比特源，选择用来进行质数测试的候选数； |
| probablePrime(int bitLength, Random rnd)             | BigInteger   | 静态方法；<br/>可能创建一个质数；<br/>bitLength：指定整数的二进制值的位数；<br/>rnd：表示要检查质数的随机位列表； |
| nextProbablePrime()                                  | BigInteger   | 返回下一个可能大于当前整数的质数                             |
| valueOf(long val)                                    | BigInteger   | 静态方法；<br/>将浮点数转为整数                              |
| add(BigInteger val)                                  | BigInteger   | 加法操作                                                     |
| subtract(BigInteger val)                             | BigInteger   | 减法操作                                                     |
| multiply(BigInteger val)                             | BigInteger   | 乘法操作                                                     |
| divide(BigInteger val)                               | BigInteger   | 除法操作                                                     |
| divideAndRemainder(BigInteger val)                   | BigInteger[] | 当前整数除以参数得到商和余数；<br/>返回数组中第一个值是除法的商值；<br/>返回数组中第二个值是除法的余数； |
| remainder(BigInteger val)                            | BigInteger   | 当前整数除以参数，返回余数                                   |
| pow(int n)                                           | BigInteger   | 返回当前整数的 n 次方，即 pow(n) = a^n^;                     |
| gcd(BigInteger val)                                  | BigInteger   | 返回两个整数的最大公约数                                     |
| abs()                                                | BigInteger   | 返回绝对值                                                   |
| negate()                                             | BigInteger   | 正负符号取反                                                 |
| signum()                                             | int          | 如果整数小于零，返回 -1 <br/>如果整数等于零，返回 0 <br/>如果整数大于零，返回 1 |
| mod(BigInteger m)                                    | BigInteger   | 当前整数除以参数，返回余数                                   |
| modPow(BigInteger exponent, BigInteger m)            | BigInteger   | 将当前整数取exponent的指数，再除以参数，返回余数；<br>即 pow(b) / m = a^b^ / m; |
| modInverse(BigInteger m)                             | BigInteger   | 用扩展欧几里得算法求乘法逆元                                 |
| shiftLeft(int n)                                     | BigInteger   | 整数的二进制值向左移动n个位置，相当于 a*2                    |
| shiftRight(int n)                                    | BigInteger   | 整数的二进制值向右移动n个位置，相当于 a/2                    |
| and(BigInteger val)                                  | BigInteger   | 当前整数与参数，执行按位与运算                               |
| or(BigInteger val)                                   | BigInteger   | 当前整数与参数，执行按位或运算                               |
| xor(BigInteger val)                                  | BigInteger   | 当前整数与参数，执行按位异或运算                             |
| not()                                                | BigInteger   | 当前整数按位取反                                             |
| andNot(BigInteger val)                               | BigInteger   | 先对参数val执行按位取反操作，将结果与当前整数按位与运算      |
| testBit(int n)                                       | boolean      | 判断整数指定二进制位上是否为1；<br/>比如14 二进制值 1110 <br/>index为0，最后一位是0，返回false；<br/>index为1、2、3，二进制位上都是1，返回true |
| setBit(int n)                                        | BigInteger   | 设置整数指定二进制位为1                                      |
| clearBit(int n)                                      | BigInteger   | 将整数指定二进制位上的值变为0                                |
| flipBit(int n)                                       | BigInteger   | 将整数中指定二进制位上的值进行翻转，0变1，1变0               |
| getLowestSetBit()                                    | int          | 当前整数二进制值的最右侧是1的位的索引；<br/>返回值从0开始    |
| bitLength()                                          | int          | 返回当前整数二进制值的总位数，但不包括符号位<br/>30 的二进制值 11110，bitLength() 等于 5 |
| bitCount()                                           | int          | 返回当前整数二进制值中位是1的个数，但不包括符号位<br/>30 的二进制值 11110，bitCount() 等于 4 |
| isProbablePrime(int certainty)                       | boolean      | 如果当前整数可能是质数，返回 true；<br/>如果当前整数一定是合数，返回 false；<br/>如果 certainty <= 0，则返回 true；<br/>certainty：对调用者愿意容忍的不确定性的度量； |
| compareTo(BigInteger val)                            | int          | 判断当前整数与参数的大小                                     |
| min(BigInteger val)                                  | BigInteger   | 返回最小值                                                   |
| max(BigInteger val)                                  | BigInteger   | 返回最大值                                                   |
| toByteArray()                                        | byte[]       | 将当前整数转换成二进制反码保存在byte数组中                   |
| toString(int radix)                                  | String       | 将整数转为几进制的字符串                                     |

例如：

```java
public class TestBigInteger {
	
	public static void main(String[] args) {
		BigInteger[] a = new BigInteger("10").divideAndRemainder(new BigInteger("2"));
		System.out.println("10 / 2，商值 = " + a[0] + ", 余数：" + a[1]);
		System.out.println("10 除以 3 = " + new BigInteger("10").remainder(new BigInteger("3")));
		System.out.println("10 除以 3 = " + new BigInteger("10").mod(new BigInteger("3")));
		System.out.println("10^2 = " + new BigInteger("10").pow(2));
		System.out.println("10和5的最大公约数 = " + new BigInteger("10").gcd(new BigInteger("5")));
		System.out.println("2.modPow(2,3)  = " + new BigInteger("2").modPow(new BigInteger("2"), new BigInteger("3")));
		System.out.println("100.modInverse(3) = " + new BigInteger("100").modInverse(new BigInteger("3")));
		System.out.println("100.shiftLeft(1) = " + new BigInteger("100").shiftLeft(1));
		System.out.println("100.shiftRight(1) = " + new BigInteger("100").shiftRight(1));
		System.out.println("2.and(4) = " + new BigInteger("2").and(new BigInteger("4")));
		System.out.println("2.andNot(4) = " + new BigInteger("2").andNot(new BigInteger("4")));
		System.out.println("2.getLowestSetBit() = " + new BigInteger("2").getLowestSetBit());
		System.out.println("30.bitLength() = " + new BigInteger("30").bitLength()); // 30 - 11110
		System.out.println("30.bitCount() = " + new BigInteger("30").bitCount()); // 30 - 11110
		System.out.println("11.nextProbablePrime() = " + new BigInteger("11").nextProbablePrime());
		System.out.println(BigInteger.probablePrime(5, new Random()));
		System.out.println(new BigInteger(5, new Random()).toString(2));
	}
}
```

输出结果：

```java
10 / 2，商值 = 5, 余数：0
10 除以 3 = 1
10 除以 3 = 1
10^2 = 100
10和5的最大公约数 = 5
2.modPow(2,3)  = 1
100.modInverse(3) = 1
100.shiftLeft(1) = 200
100.shiftRight(1) = 50
2.and(4) = 0
2.andNot(4) = 2
2.getLowestSetBit() = 1
30.bitLength() = 5
30.bitCount() = 4
11.nextProbablePrime() = 13
23
11010
```



## Number

所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类，实现了 Serializable 接口。

| 方法          | 返回值 | 说明                                                |
| ------------- | ------ | --------------------------------------------------- |
| intValue()    | int    | 以整数形式返回指定数字的值，这可能涉及舍入或截断。  |
| longValue()   | long   | 以 long形式返回指定数字的值，这可能涉及舍入或截断。 |
| floatValue()  | float  | 以浮点形式返回指定数字的值，这可能涉及舍入。        |
| doubleValue() | double | 以双精度形式返回指定数字的值，这可能涉及舍入。      |
| byteValue()   | byte   | 以字节形式返回指定数字的值，这可能涉及舍入或截断。  |
| shortValue()  | short  | 将指定数字的值作为短值返回，这可能涉及舍入或截断。  |



## Math

Math 中包含基本数学运算静态方法，如基本指数、对数、平方根和三角函数。

符号 % 被称为取余，符号 / 被称为取模。

| 方法                                      | 返回值 | 说明                                                         |
| ----------------------------------------- | ------ | ------------------------------------------------------------ |
| *E*                                       | double | 对数基数，2.7182818284590452354                              |
| *PI*                                      | double | 圆周率，3.14159265358979323846                               |
| sin(double a)                             | double | 求参数的正弦值；<br/>正弦值是在直角三角形中，对边与斜边的比，sinA=a/c<br/>![img](./01.Java_part1.assets/a9d3fd1f4134970a05c7581f96cad1c8a7865d4d.jpg) |
| cos(double a)                             | double | 求参数的余弦值；<br/>余弦值是在直角三角形中，邻边与斜边的比，cosA=b/c |
| tan(double a)                             | double | 求参数的正切值；<br/>正切值是在直角三角形中，对边与邻边的比，tanA=a/b |
| asin(double a)                            | double | 求参数的反正弦值，是正弦函数 y=*sin*x 的反函数 *sin*y=x      |
| acos(double a)                            | double | 求参数的反余弦值，是余弦函数 y=*cos*x 的反函数 *cos*y=x      |
| atan(double a)                            | double | 求参数的反正切值；<br/>atan中的参数a一般传y/x，也就是斜率<br/><img src="./01.Java_part1.assets/1177632-20211216160635765-123395969.png" alt="atan2-1"  /><br/>值域为$[-\frac π2,\frac π2]$ |
| atan2(double y, double x)                 | double | 将指定的直角坐标(x, y) 转换为极坐标 (r, θ)，并返回弧度θ；<br/>该方法通过计算 y/x 的反正切值来计算弧度θ，值域为(-π, π]；<br/>给定一个点 P(2, 2)，利用 θ=atan2(2, 2) 函数求得的 θ（为图中所示的角）<br/>可以直观看出θ是P与原点O所连直线和x轴的夹角；<br/><img src="./01.Java_part1.assets/1177632-20211216160635765-123395969.png" alt="atan2-1"  /> |
| toRadians(double angdeg)                  | double | 将角度转换为弧度，公式：弧度=角度×(π÷180 )                   |
| toDegrees(double angrad)                  | double | 将参数转化为角度，公式：角度=弧度 * 180.0÷PI                 |
| exp(double a)                             | double | 求自然数底数e的幂，即 e^2^=e*e                               |
| log(double a)                             | double | 求以 e 为底，参数的对数值，即 $\log e^a$                     |
| log10(double a)                           | double | 求以 10 为底，参数的对数值，即  $\log 10^a$                  |
| sqrt(double a)                            | double | 求参数的平方根，即 sqrt(4) = 2                               |
| cbrt(double a)                            | double | 求参数的立方根，即 cbrt(8) = 2                               |
| IEEEremainder(double f1, double f2)       | double | IEEE 754标准的求参数1与参数2的余数；<br/>余数值在数学上等于f1-f2×n，其中n是最接近商f1/f2的精确数学值的数学整数，<br/>如果两个数学整数同样接近f1/f2，则n是偶数；<br/>如果余数为零，则其符号与第一个参数的符号相同；<br/>Math.IEEEremainder(10, 4) = 2<br/>Math.IEEEremainder(3, 2) = -1 |
| ceil(double a)                            | double | 返回大于等于（>=）给定参数的最小整数                         |
| floor(double a)                           | double | 返回小于等于（<=）给定参数的最大整数                         |
| rint(double a)                            | double | 返回与参数最接近的整数；<br/>Math.rint(1.5)=2.0<br/>Math.rint(1.2)=1.0 |
| pow(double a, double b)                   | double | 返回第一个参数的第二个参数的幂次方                           |
| round(float a)                            | int    | 四舍五入；<br>算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整；<br/>所以 Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为 -11 |
| random()                                  | double | 返回一个大于等于 0 且小于等于 1 的随机数                     |
| addExact(int x, int y)                    | int    | 求参数的之和                                                 |
| subtractExact(int x, int y)               | int    | 求参数的差值                                                 |
| multiplyExact(int x, int y)               | int    | 求参数的乘积                                                 |
| incrementExact(int a)                     | int    | 将参数递增1                                                  |
| decrementExact(int a)                     | int    | 将参数递减1                                                  |
| negateExact(int a)                        | int    | 给参数添加一个负号                                           |
| toIntExact(long value)                    | int    | 将参数强制转换为整数                                         |
| floorDiv(int x, int y)                    | int    | 计算x/y并向下取整；<br/>如果参数的正负符号不同，且结果值不是零，则向下取整即 (x/y)--<br/>Math.floorDiv(10, 3)=3<br/>Math.floorDiv(10, -3)=-4 |
| floorMod(int x, int y)                    | int    | 取模运算；<br/>通过a/b得到的商，向负无穷方向舍弃小数，之后再计算a-b*(a/b)<br/>公式：x - *floorDiv*(x, y) * y <br/>Math.floorMod(10, 3)=1<br/>Math.floorMod(10, -3)=-2<br/>[![符号不同的结果](./01.Java_part1.assets/2056265-20200725101204834-1316309550.png)](https://img2020.cnblogs.com/blog/2056265/202007/2056265-20200725101204834-1316309550.png) |
| abs(int a)                                | int    | 返回参数的绝对值                                             |
| max(int a, int b)                         | int    | 返回两个参数中的最大值                                       |
| min(int a, int b)                         | int    | 返回两个参数中的最小值                                       |
| ulp(double d)                             | double | 返回参数的最后位置的单位大小（unit in the last place, ulp)；<br/>对于一个double值来说，就是该浮点数跟比其大的下一个double值之间的距离。 |
| signum(double d)                          | double | 返回所给参数的符号数。<br/>若参数为负数则返回 -1；<br/>参数为 0 则返回 0；<br/>参数为正数则返回 1； |
| sinh(double x)                            | double | 返回参数x的双曲正弦函数值；<br/>计算公式为 (e^x^ - e^-x^)/2  |
| cosh(double x)                            | double | 返回参数x的双曲余弦函数值；<br/>计算公式为：(e^x^ + e^-x^)/2 |
| tanh(double x)                            | double | 返回参数x的双曲正切函数值；<br/>计算公式为：(e^x^ - e^-x^)、(e^x^ + e^-x^) |
| hypot(double x, double y)                 | double | 返回 sqrt(x^2^+y^2^)，没有中间上溢或下溢                     |
| expm1(double x)                           | double | 返回e^x^-1<br/>对于接近 0 附近的 x，expm1(x)+1的值比 exp(x) 更加接近 e^x^ 的真实值 |
| log1p(double x)                           | double | 返回x+1的自然对数；<br/>对于很小的x值，log1p(x)的计算结果比log(x+1)的计算结果更加接近于真实的ln(x+1) |
| copySign(double magnitude, double sign)   | double | 返回一个值与第一个参数的数值相等，与第二个参数的符号相同     |
| getExponent(float f)                      | int    | 返回参数的无偏值数值；<br/>返回值与输入参数f之间的关系为2^exp^<=f |
| nextAfter(double start, double direction) | double | 返回第二个参数direction方向上第一个参数start紧邻的数值。<br/>如果两个参数相等，那么直接返回第二个参数 |
| nextUp(double d)                          | double | 返回正方向上与所给参数紧邻的数值；<br/>此方法等效于nextAfter(d, Double.POSITIVE_INFINITY)/nextAfter(f, Float.POSITIVE_INFINITY)<br/>但是 nextUp() 的实现可能比其等效的 nextAfter() 运行更快 |
| nextDown(double d)                        | double | 是Java8特性；<br/>返回负方向上与所给参数紧邻的数值。<br/>此方法等效于nextAfter(d, Double.NEGATIVE_INFINITY)/nextAfter(f, Float.NEGATIVE_INFINITY)，<br/>但是nextUp()的实现可能比其等效的nextAfter()运行更快 |
| scalb(double d, int scaleFactor)          | double | 返回 d*2^scaleFactor^                                        |
| multiplyFull(int x, int y)                | long   | 是Java9新特性<br/>计算两个参数的乘积正确值（不考虑结果溢出） |
| multiplyHigh(long x, long y)              | long   | 是Java9新特性<br/>计算两个参数的 128 位乘积，并返回结果的高 64 位 |
| fma(double a, double b, double c)         | double | 是Java9新特性<br/>返回三个参数的融合乘法加法（fused multiply add），即a*b+c |

例如：

```java
public class TestMath {
	public static void main(String[] args) {
		System.out.println(Math.PI);
		System.out.println(Math.E);
		
		System.out.println("90度的正弦值：" + Math.sin(Math.PI / 2));
		System.out.println("0度的余弦值：" + Math.cos(0));
		System.out.println("60度的正切值：" + Math.tan(Math.PI / 3));
		System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI / 2));
		
		System.out.println("Math.floorDiv(10, 3)=" + Math.floorDiv(10, 3));
		System.out.println("Math.floorDiv(10, -3)=" + Math.floorDiv(10, -3));
		System.out.println("Math.floorMod(10, 3)=" + Math.floorMod(10, 3));
		System.out.println("Math.floorMod(10, -3)=" + Math.floorMod(10, -3));
		System.out.println("求e的幂 ：Math.exp(2)=" + Math.exp(2) + " = e * e");
		System.out.println("求平方根：Math.sqrt(4)=" + Math.sqrt(4));
		System.out.println("求立方根：Math.cbrt(8)=" + Math.cbrt(8));
		System.out.println("Math.toDegrees()=" + Math.toDegrees(10));
		System.out.println("Math.IEEEremainder(10,4)=" + Math.IEEEremainder(10, 4));
		System.out.println("Math.IEEEremainder(3,2)=" + Math.IEEEremainder(3, 2));
		System.out.println("Math.()=" + Math.sqrt(10));
		System.out.println("Math.()=" + Math.sqrt(10));
		System.out.println("Math.()=" + Math.sqrt(10));
		System.out.println("Math.()=" + Math.sqrt(10));
		System.out.println("Math.()=" + Math.sqrt(10));
		System.out.println("Math.log(Math.E)=" + Math.log(Math.E));
		System.out.println("Math.log10(100)=" + Math.log10(100));
		System.out.println("Math.floor(1.4)=" + Math.floor(1.4));
		System.out.println("Math.round(1.6)=" + Math.round(1.6));
		System.out.println("Math.ceil(1.5)=" + Math.ceil(1.5));
		System.out.println("Math.rint(1.5)=" + Math.rint(1.5));
		System.out.println("Math.rint(1.2)=" + Math.rint(1.2));
		
		System.out.println("Math.atan2(2, 2)=" + Math.atan2(2, 2)); // 0.7853981633974483
		System.out.println("Math.atan(2 / 2)=" + Math.atan(2 / 2)); // 0.7853981633974483
		System.out.println("Math.atan2(3 - 1, 4 - 2)=" + Math.atan2(3 - 1, 4 - 2)); // 0.7853981633974483
		System.out.println("Math.atan((3 - 1) / (4 - 2))=" + Math.atan((3 - 1) / (4 - 2))); // 0.7853981633974483
		System.out.println("Math.atan2(1 - 3, 2 - 4)=" + Math.atan2(1 - 3, 2 - 4)); // -2.356194490192345
		System.out.println("Math.atan((1 - 3) / (2 - 4))=" + Math.atan((1 - 3) / (2 - 4))); // 0.7853981633974483
		
		System.out.println("Math.addExact(100, 1000)=" + Math.addExact(100, 1000));
		System.out.println("Math.signum(10)=" + Math.signum(10));
		System.out.println("Math.signum(0)=" + Math.signum(0));
		System.out.println("Math.signum(-10)=" + Math.signum(-10));
		System.out.println("Math.copySign(-10, 20)=" + Math.copySign(-10, 20));
	}
}
```

输出结果：

```java
3.141592653589793
2.718281828459045
90度的正弦值：1.0
0度的余弦值：1.0
60度的正切值：1.7320508075688767
π/2的角度值：90.0
Math.floorDiv(10, 3)=3
Math.floorDiv(10, -3)=-4
Math.floorMod(10, 3)=1
Math.floorMod(10, -3)=-2
求e的幂 ：Math.exp(2)=7.38905609893065 = e * e
求平方根：Math.sqrt(4)=2.0
求立方根：Math.cbrt(8)=2.0
Math.toDegrees()=572.9577951308232
Math.IEEEremainder(10,4)=2.0
Math.IEEEremainder(3,2)=-1.0
Math.()=3.1622776601683795
Math.()=3.1622776601683795
Math.()=3.1622776601683795
Math.()=3.1622776601683795
Math.()=3.1622776601683795
Math.log(Math.E)=1.0
Math.log10(100)=2.0
Math.floor(1.4)=1.0
Math.round(1.6)=2
Math.ceil(1.5)=2.0
Math.rint(1.5)=2.0
Math.rint(1.2)=1.0
Math.atan2(2, 2)=0.7853981633974483
Math.atan(2 / 2)=0.7853981633974483
Math.atan2(3 - 1, 4 - 2)=0.7853981633974483
Math.atan((3 - 1) / (4 - 2))=0.7853981633974483
Math.atan2(1 - 3, 2 - 4)=-2.356194490192345
Math.atan((1 - 3) / (2 - 4))=0.7853981633974483
Math.addExact(100, 1000)=1100
Math.signum(10)=1.0
Math.signum(0)=0.0
Math.signum(-10)=-1.0
Math.copySign(-10, 20)=10.0
```



------



# 语句



## for循环语句

```java
for (初始表达式; 布尔表达式; 迭代因子) {
	循环体;
}
```



## foreach语句

```java
for(元素类型 元素变量 : 遍历对象) {
	循环体;
}
```



## while循环语句

```java
while (布尔表达式) {
	循环体;
}
```



## do-while 循环语句

```java
do {
	循环体;
} while (布尔表达式);
```



## if-else 语句

```java
if(条件表达式) {
 	语句块;
} else {
	语句块;
}
```



## If-else-if 多条件语句

```java
if (条件表达式) {
	语句块1;
} else if (条件表达式) {
	语句块2;
} else if (条件表达式) {
	语句块3;
} else {
	语句块4;
}
```



## switch语句

switch语句中 case 标签可以是：byte、short、int、 char；<br/>在Java5新特性中引入枚举；<br/>在Java7新特性中引入字符串字面量；

```java
switch (值) {
	case 值1: 
		语句序列1;
		break;
    
	case 值2:
 		语句序列2;
		break;
    
	default:
    默认语句;
    break;
}
```



## try-catch-finally语句

1. 异常处理语法结构中只有 try 块是必需的，也就是说，如果没有 try 块，则不能有后面的 catch 块和 finally 块；
2. 不能只有 try 块，既没有 catch 块，也没有 finally 块；
3. 可以有多个 catch 块，捕获父类异常的 catch 块必须位于捕获子类异常的后面；
4. 先执行return，再执行finally代码块，return把值暂存到栈中，当finally中也有return时，会用新的值覆盖栈中的值，方法彻底结束后，返回栈中的值；

```java
try {
    // 可能会发生异常的语句
} catch(ExceptionType1 e1) {
    // 处理异常语句
} catch(ExceptionType2 e2) {
    // 处理异常语句
} finally {
  // 最后执行的语句
}
```



## try-catch多异常捕获语句

多异常捕获语句，是Java7新特性，多种异常类型之间用竖线分隔，异常对象是隐式 final 修饰。

```java
try{
	// 可能会发生异常的语句
} catch (IOException | ParseException e) {
	// 处理异常语句
}
```



## try-with-resources语句

自动资源管理语句，是Java7新特性。

1. try 语句中声明的资源被隐式声明为 final，资源的作用局限于带资源的 try 语句；
2. 可以在一条 try 语句中声明或初始化多个资源，每个资源以`;`隔开即可；
3. 需要关闭的资源必须实现了 AutoCloseable 或 Closeable 接口；

```java
try (需要关闭的资源对象) {
	// 可能会发生异常的语句
} catch(异常类型 e) {
	// 处理异常语句
} catch(异常类型 e) {
	// 处理异常语句
}
```



## break和continue语句

break语句：是指立即结束 break 关键字所在的循环体。

continue语句：是指立即结束本次循环，开始执行下一次循环。

例如：

```java
public class TestBreakContinueTag {
	
	public static void main(String[] args) {
		for (int j = 1; j <= 10; j++) {
			if (j % 4 == 0) {
				System.out.println("数字 " + j + " 是 4 的倍数!");
				continue;
			}
			if (j % 5 == 0) {
				System.out.println("数字 " + j + " 是 5 的倍数, 退出循环!");
				break;
			}
			System.out.println("数字 " + j);
		}
	}
}
```

输出结果：

```java
数字 1
数字 2
数字 3
数字 4 是 4 的倍数!
数字 5 是 5 的倍数, 退出循环!
```



## 带标签的break和continue语句

定义标签：是指一个标签名右侧加一个半角冒号（如 label:）。

带标签的 break：是指 break 关键字右侧加一个已定义的标签，表示直接退出标签所在的循环。

带标签的 continue：是指 continue 关键字右侧加一个已定义的标签，表示立即结束本次循环，并返回到标签所在的循环。

例如：

```java
public class TestBreakTag {
	
	public static void main(String[] args) {
		lable1: for (int i = 1; i <= 2; i++) {
			System.out.println("第 " + i + " 次循环 ..");
			for (int j = 1; j <= 8; j++) {
				if (j % 4 == 0) {
					System.out.println("数字 " + j + " 是 4 的倍数!");
					break lable1; // 直接跳出 lable1 标签所在的循环
				}
				System.out.println("数字 " + j);
			}
		}
	}
}
```

输出结果：

```java
第 1 次循环 ..
数字 1
数字 2
数字 3
数字 4 是 4 的倍数!
```

```java
public class TestContinueTag {
	
	public static void main(String[] args) {
		lable1: for (int i = 1; i <= 2; i++) {
			System.out.println("第 " + i + " 次循环 ..");
			for (int j = 1; j <= 8; j++) {
				if (j % 4 == 0) {
					System.out.println("数字 " + j + " 是 4 的倍数!");
					continue lable1;
				}
				System.out.println("数字 " + j);
			}
		}
	}
}
```

输出结果：

```java
第 1 次循环 ..
数字 1
数字 2
数字 3
数字 4 是 4 的倍数!
第 2 次循环 ..
数字 1
数字 2
数字 3
数字 4 是 4 的倍数!
```



## 语句块

也叫复合语句，是指用花括号扩起来的代码，语句块确定了变量的作用域。语句块作为一个整体被一起执行。块也可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中定义的变量。

```java
public class TestStatementBlock {
	
	public static void main(String[] args) {
		int n;
		int m;
		{
			int p;
			int n; // 编译错误：不能重复定义变量n
		} // 变量 p 的作用域到此为止
	}
}
```



## 静态代码块

是指在类中定义的 `static{..}` 代码块，在对类执行类加载操作的时候，会按静态代码块在类中定义的顺序，逐个执行。



------



# 正则表达式（java.util.regex）

[正则表达式](https://dcx.sap.com/1101/zh/dbreference_zh11/rf-sqllanguage-s-4915351.html)也叫规则表达式，由字面值字符和特殊符号组成，可以用来匹配、替换和拆分字符串。

正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别，可以使用[在线工具](https://regex101.com)来调试正则表达式。

https://wangwl.net/static/projects/visualRegex#



## 语法

|  特殊字符   | 说明                                                         |
| :---------: | :----------------------------------------------------------- |
|      \      | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符；<br>例如， **n**匹配字符 **n**。**\n** 匹配换行符。序列 **\\\\** 匹配 **\\** ，**\\(** 匹配 **(** |
|      ^      | 匹配输入字符串开始的位置；<br/>如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 还会与 "\n" 或 "\r" 之后的位置匹配； |
|      $      | 匹配输入字符串结尾的位置；<br/>如果设置了 **RegExp** 对象的 **Multiline** 属性，$ 还会与 "\n" 或 "\r" 之前的位置匹配； |
|      *      | 零次或多次匹配前面的字符或子表达式；<br/>例如：zo* 匹配 "z" 和 "zoo"。* 等效于 {0,}； |
|      +      | 一次或多次匹配前面的字符或子表达式；<br/>例如："zo+" 与 "zo" 和 "zoo" 匹配，但与 "z" 不匹配，+等效于 {1,} |
|      ?      | 零次或一次匹配前面的字符或子表达式；<br/>例如："do(es)?" 匹配 "do" 或 "does" 中的 "do"，?等效于 {0,1} |
|     {n}     | n 是非负整数。正好匹配 n 次；<br/>例如："o{2}" 与 "Bob" 中的 "o" 不匹配，但与 "food" 中的两个 "o" 匹配； |
|    {n,}     | n 是非负整数，至少匹配 n 次；<br/>例如："o{2,}" 不匹配 "Bob" 中的"o"，而匹配 "foooood" 中的所有 o；<br/>"o{1,}" 等效于 "o+"。"o{0,}" 等效于 "o*" |
|    {n,m}    | m 和 n 是非负整数，其中 n <= m；<br/>匹配至少 n 次，至多 m 次；<br/>例如："o{1,3}"匹配"fooooood"中的头三个 o；<br/>'o{0,1}' 等效于 'o?'；<br/>注意：您不能将空格插入逗号和数字之间； |
|      ?      | 当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是"非贪心的"；<br/>"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串；<br/>例如，在字符串 "oooo" 中，"o+?" 只匹配单个 "o"，而 "o+" 匹配所有 "o"； |
|      .      | 匹配除"\r\n"之外的任何单个字符；<br/>若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式； |
|  (pattern)  | 表示捕获组<br/>通过一对小括号来创建一个分组，如果表达式匹配了多个分组，按从左到右的顺序来编号；<br/>例如：<br/>在正则表达式 `((A)(B(C)))` 中共有4个分组，顺序如下：<br/>((A)(B(C))) <br/>(A) <br/>(B(C)) <br/>(C)<br/>可使用 1 到 9 之间的数字获取对应的分组；<br/>数字 0 表示获取整个正则表达式匹配的内容；<br/>可使用**命名捕获组**，比如 `(?<NAME1>pattern)` 定义了一个叫 NAME1 的分组；<br/><br/>小括号是特殊字符，若要匹配小括号的话可使用 "(" 和 ")" |
| (?:pattern) | 表示非捕获组；<br/>`(?:pattern)` 中 pattern 表示一个无特殊意义的纯文本；<br/>一般用与符号 | 联合使用，例如：<br/>`industr(?:y\|ies)` 可以匹配字符串 industry 或 industries |
| (?=pattern) | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串；<br/>是一个非捕获匹配，即不能捕获供以后使用的匹配；<br/>例如：'Windows (?=95\|98\|NT\|2000)' 匹配 "Windows 2000" 中的 "Windows"，但不匹配 "Windows 3.1" 中的 "Windows"；<br/>预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后； |
| (?!pattern) | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串；<br/>它是一个非捕获匹配，即不能捕获供以后使用的匹配；<br/>例如：'Windows (?!95\|98\|NT\|2000)' 匹配 "Windows 3.1" 中的 "Windows"，但不匹配 "Windows 2000" 中的 "Windows"；<br/>预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后； |
|    x\|y     | 匹配 x 或 y；<br/>例如：'z\|food' 匹配 "z" 或 "food"；<br/>'(z\|f)ood' 匹配 "zood" 或 "food"； |
|    [xyz]    | 字符集<br/>匹配包含的任一字符；<br/>例如："[abc]" 匹配 "plain" 中的 "a"； |
|   [^xyz]    | 反向字符集；<br/>匹配未包含的任何字符；<br/>例如，"\[^abc]" 匹配 "plain" 中 "p"，"l"，"i"，"n"； |
|    [a-z]    | 字符范围；<br/>匹配指定范围内的任何字符；<br/>例如："[a-z]" 匹配 "a" 到 "z" 范围内的任何小写字母 |
|   [^a-z]    | 反向范围字符；<br/>匹配不在指定的范围内的任何字符；<br/>例如，"\[^a-z]" 匹配任何不在 "a" 到 "z" 范围内的任何字符 |
|     \b      | 匹配一个字边界，即字与空格间的位置；<br/>例如："er\b" 匹配 "never" 中的 "er"，但不匹配 "verb" 中的 "er"；<br>// 只有首尾位置匹配<br/>console.log('0aZ'.replace(/\b/g, '.'))  // .0aZ.<br/><br/>// +不是\w，所以它的左右间隙都可以被匹配<br/>console.log('a+a'.replace(/\b/g, '.'))  // .a.+.a.<br/><br/>// 空格也不是\w，所以它的左右间隙都可以被匹配<br/>console.log('a a'.replace(/\b/g, '.'))  // .a. .a. |
|     \B      | 非字边界匹配；<br/>"er\B" 匹配 "verb" 中的 "er"，但不匹配 "never" 中的 "er" |
|     \cx     | 匹配 x 指示的控制字符；<br/>例如：\cM 匹配 Control-M 或回车符；<br/>x 的值必须在 A-Z 或 a-z 之间；<br/>如果不是这样，则假定 c 就是 "c" 字符本身 |
|     \d      | 匹配数字字符；<br/>等效于 [0-9]                              |
|     \D      | 匹配非数字字符；<br/>等效于 \[^0-9]                          |
|     \f      | 匹配换页符；<br/>等效于 \x0c 和 \cL                          |
|     \n      | 匹配换行符；<br/>等效于 \x0a 和 \cJ                          |
|     \r      | 匹配一个回车符；<br/>等效于 \x0d 和 \cM                      |
|     \s      | 匹配任何空白字符，包括空格、制表符、换页符等；<br/>与 [ \f\n\r\t\v] 等效； |
|     \S      | 匹配任何非空白字符；<br/>与 \[^ \f\n\r\t\v] 等效；           |
|     \t      | 匹配制表符；<br/>与 \x09 和 \cI 等效；                       |
|     \v      | 匹配垂直制表符；<br/>与 \x0b 和 \cK 等效；                   |
|     \w      | 匹配一个英文字母、数字、下划线；<br/>与 "[A-Za-z0-9_]" 等效； |
|     \W      | 匹配与任何非单词字符；<br/>与 "\[^A-Za-z0-9_]" 等效；        |
|     \xn     | 匹配 n，此处的 n 是一个十六进制转义码；<br/>十六进制转义码必须正好是两位数长；<br/>例如："\x41" 匹配 "A"；<br/>"\x041" 与 "\x04" & "1" 等效；<br/>允许在正则表达式中使用 ASCII 代码； |
|     num     | 匹配 num，此处的 num 是一个正整数；<br/>到捕获匹配的反向引用；<br/>例如："(.)\1"匹配两个连续的相同字符 |
|      n      | 标识一个八进制转义码或反向引用；<br/>如果 n 前面至少有 n 个捕获子表达式，那么 n 是反向引用；<br/>否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码 |
|     nm      | 标识一个八进制转义码或反向引用；<br/>如果 nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用；<br/>如果 nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m；<br/>如果两种前面的情况都不存在，则 nm 匹配八进制值 nm，其中 n 和 m是八进制数字（0-7） |
|    \nml     | 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml |
|     \un     | 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符；<br/>例如：\u00A9 匹配版权符号 (©) |



## 相关类



### String类

| String中与正则表达式相关方法                                 |  返回值  | 说明                                                         |
| ------------------------------------------------------------ | :------: | ------------------------------------------------------------ |
| matches(<br/>String regex<br/>)                              | boolean  | 判断字符串是否与正则表达式匹配；<br>regex：正则表达式；<br>返回true表示匹配；<br>返回false表示不匹配； |
| replaceAll(<br>String regex, <br/>String replacement<br/>)   |  String  | 替换字符串中所有与正则表达式匹配的子串；<br>regex：正则表达式；<br/>replacement：字符串；<br/>返回替换之后的字符串； |
| replaceFirst(<br/>String regex, <br/>String replacement<br/>) |  String  | 替换字符串中第一个与正则表达式匹配的子串；<br/>regex：正则表达式；<br/>replacement：字符串；<br/>返回替换之后的字符串； |
| split(<br/>String regex<br/>)                                | String[] | 用正则表达式匹配字符串中的内容，并将匹配的内容作为分隔符，把字符串分隔成多个子串；<br/>返回分隔之后的子串数组（不包含正则表达式匹配的内容）； |



### Pattern类

| 方法                                                         |  返回值  | 说明                                                         |
| ------------------------------------------------------------ | :------: | ------------------------------------------------------------ |
| Pattern.CANON_EQ                                             |   int    | 正则表达式匹配模式：规范等价模式；？？？                     |
| Pattern.CASE_INSENSITIVE                                     |   int    | 正则表达式匹配模式：忽略（英文字母）分大小写模式；<br>会导致轻微的性能损失；<br/>也可在正则表达式中使用`(?i)`来开启不区分大小写的匹配； |
| Pattern.COMMENTS                                             |   int    | 正则表达式匹配模式：注释模式；<br>允许在正则表达式中存在空格、tab、回车，这些字符会被忽略；<br/>忽略字符串中以#开头的注释，直到行尾为止；<br/>也可在正则表达式中使用`?x`来启用忽略空格和注解； |
| Pattern.DOTALL                                               |   int    | 正则表达式匹配模式：原点模式；<br/>会更改半角句号'.'匹配的规则：可匹配任何字符，包括行终止符；<br/>默认情况下，半角句号不能匹配行终止符；<br/>也可在正则表达式中使用`?s`来启用； |
| Pattern.LITERAL                                              |   int    | 正则表达式匹配模式：文字分析模式；<br>在分析模式下，转义字符和元字符不再有特殊含义，作为普通的文本；<br/>即在正则表达式中的`^$\d`等字符将失去特殊含义； |
| Pattern.MULTILINE                                            |   int    | 正则表达式匹配模式：多行模式；<br>在多行模式下，\^和$可以匹配字符串中所有行的开始和结束位置；<br/>默认情况下，\^和\$仅能匹配字符串的开始与结束位置；<br/>也可在正则表达式中使用`?m`来开启多行模式； |
| Pattern.UNICODE_CASE                                         |   int    | 启用**Unicode**大小写模式；<br>功能与**CASE_INSENSITIVE**类似，用来忽略**Unicode**字符的大小写；<br/>此模式可能会导致性能下降；<br/>可在正则表达式中使用`?u`来启用忽略Unicode大小写； |
| Pattern.UNICODE_CHARACTER_CLASS                              |   int    | 正则表达式匹配模式：使用Unicode版本的**预定义字符类**和**POSIX**字符类；<br>如果使用该模式，则默认也使用了`UNICODE_CASE`模式；<br>指定此标志可能会造成性能损失；<br>元字符（`\b`、`\d`、`\s`、`\w`、`\B`、`\D`、`\S`、`\W`）；<br/>`\d`默认表示的是ASCII中的数字，但在该模式下，表示Unicode里的数字；<br>`\s`默认表示的是ASCII中的空白，但在该参数下，表示Unicode里的WHITE_SPACE；<br>`\w`默认表示的是ASCII中的`[A-Za-z0-9_]`，但在该参数下，表示Unicode里的字符； |
| Pattern.UNIX_LINES                                           |   int    | 正则表达式匹配模式：**Unix**行模式；<br>在这个模式下，只有 '\n' 才会被识别成换行符，且与 '.'、'^'、'$'匹配；<br>也可以在正则表达式中使用`?d`来启用**Unix**行模式； |
| Pattern.compile(<br/>String regex<br/>)                      | Pattern  | 静态方法；<br/>创建一个正则表达式对象；<br>regex：正则表达式；<br>默认使用任何模式；<br>返回一个Pattern对象； |
| Pattern.compile(<br/>String regex, <br/>int flags<br/>)      | Pattern  | 静态方法；<br/>创建一个正则表达式对象；<br/>regex：正则表达式；<br/>flags：匹配模式值；<br/>返回一个Pattern对象； |
| Pattern.matches(<br/>String regex,<br/>CharSequence input<br/>) | boolean  | 静态方法；<br/>判断字符串参数是否与正则表达式匹配；<br>regex：正则表达式；<br/>input：字符串参数；<br/>返回true表示匹配，false表示不匹配； |
| Pattern.quote(<br/>String s<br/>)                            |  String  | 静态方法；<br/>将输入字符串参数中的**元字符或转义序列**转为没有特殊含义的字符串；<br/>s：转义前的字符串；<br/>返回转义之后的字符串； |
| pattern()                                                    |  String  | 返回创建Pattern对象时，使用的正则表达式；                    |
| flags()                                                      |   int    | 返回创建Pattern对象时，使用的匹配模式值；                    |
| matcher(<br/>CharSequence input<br/>)                        | Matcher  | 创建一个匹配器，将正则表达式与字符串匹配；<br/>input：要与正则表达式匹配的字符串；<br>返回一个新匹配器； |
| split(<br/>CharSequence input,<br/>int n<br/>)               | String[] | 使用正则表达式分割字符串，并将分割后的字段保存到数组中；<br>input：要被分割的字符串；<br/>n：结果阈值；<br/>如果n大于0，则最多分割n-1次，数组长度不大于n，最后的元素将包含剩余所有；<br/>如果n是负数，那么模式将被应用到尽可能多的次数，并且数组可以有任何长度；<br/>如果n为0，则模式将被应用尽可能多次，数组可以有任何长度，并且尾随的空字符串将被丢弃；<br/>返回分割后的数组，例如：<br/><img src="./01.Java_part1.assets/JavaRegex_1.png" alt="截屏2022-12-23 01.15.42" style="zoom:33%;" /> |
| split(<br/>CharSequence input<br/>)                          | String[] | 使用正则表达式分割字符串中的字段<br/>input：被分割的字符串；<br/>返回分割后的数组；<br><img src="./01.Java_part1.assets/JavaRegex_2.png" alt="截屏2022-12-23 01.15.02" style="zoom:33%;" /> |



### MatchResult接口

| 方法             | 返回值 | 说明                                                 |
| ---------------- | ------ | ---------------------------------------------------- |
| end()            | int    | 返回匹配的结束位置                                   |
| end(int group)   | int    | 返回指定捕获组在匹配期间捕获的元素最后一个字符的位置 |
| group()          | String | 返回上一个捕获组                                     |
| group(int group) | String | 返回指定捕获组在匹配期间捕获的元素                   |
| groupCount()     | int    | 返回匹配器中的捕获组的数量                           |
| start()          | int    | 返回匹配的起始位置                                   |
| start(int group) | int    | 返回指定捕获组在匹配期间捕获的元素第一个字符的位置   |



### Matcher类

表示字符串匹配器

| 方法                                                         |    返回值    | 说明                                                         |
| ------------------------------------------------------------ | :----------: | ------------------------------------------------------------ |
| pattern()                                                    |   Pattern    | 返回匹配器所属的Pattern对象；                                |
| usePattern(<br/>Pattern newPattern<br/>)                     |   Matcher    | 匹配器更换正则表达式Pattern对象，并使用新对象匹配字符串；    |
| toMatchResult()                                              | MatchResult  | 返回匹配结果；<br/>详见**MatchResult**接口                   |
| reset()                                                      |   Matcher    | 重设此匹配器；                                               |
| reset(<br/>CharSequence input<br/>)                          |   Matcher    | 重置此匹配器；<br>input：下一次与正则表达式匹配的字符串；<br>返回匹配器对象本身； |
| group()                                                      |    String    | 该方法与group(0)方法效果相同；<br>代表整个表达式，但该组不包括在groupCount方法的返回值中； |
| start()                                                      |     int      | 返回此次匹配的开始位置；<br>如果匹配不成功，会抛出IllegalStateException异常； |
| end()                                                        |     int      | 返回此次匹配的结束位置（即最后一个字符的下标加一）；<br/>如果匹配不成功，会抛出IllegalStateException异常； |
| group(<br/>int group<br/>)                                   |    String    | 返回捕获组中指定分组匹配的结果；<br>group(0)返回与正则表达式匹配的字符串；<br/>group(1)返回捕获组中第一个分组匹配到的结果；<br/>如果捕获组未能成功匹配， 则返回为null； |
| group(<br/>String name<br/>)                                 |    String    | 返回指定捕获组匹配的结果；<br/>name：表示捕获组名称，在正则表达式中小括号内用`?<NAME1>`定义捕获组名；<br>如果组未能匹配输入的一部分， 则返回为null； |
| groupCount()                                                 |     int      | 返回捕获组中分组的数量；                                     |
| start(<br/>int group<br/>)                                   |     int      | 返回捕获组中指定分组匹配结果的起始位置；<br/>group：捕获组中元素的位置信息，从1开始；<br>start(0)相当于start() |
| start(<br/>String name<br/>)                                 |     int      | 返回捕获组中指定分组匹配结果的起始位置；<br/>name：表示捕获组名称，在正则表达式中小括号内用`?<NAME1>`定义捕获组名；<br>如果捕获组没有匹配成功，则返回-1； |
| end(<br/>int group<br/>)                                     |     int      | 返回捕获组中指定分组匹配结果的结束位置；<br/>group：捕获组中元素的位置信息，从1开始；<br/>start(0)相当于start() |
| end(<br/>String name<br/>)                                   |     int      | 返回捕获组中指定分组匹配结果的结束位置；<br/>name：表示捕获组名称，在正则表达式中小括号内用`?<NAME1>`定义捕获组名；<br/>如果捕获组没有匹配成功，则返回-1； |
| lookingAt()                                                  |   boolean    | 判断**输入字符串**的前缀是否与**正则表达式**匹配；<br>与matches()方法一样从开头开始匹配，但不要求整个区域匹配；<br/>返回true表示匹配成功； |
| matches()                                                    |   boolean    | 返回true，表示正则表达式与整个字符串匹配；<br>返回false，表示不匹配；<br>例如：正则表达式 "hello" 与字符串 "hellohellohello" 不匹配；<br>注意matches()方法与find()方法不同； |
| find()                                                       |   boolean    | 返回true表示在字符串中能找到正则表达式匹配的内容；<br>如果匹配成功可以通过start，end和group方法来获得；<br/>注意matches()方法与find()方法不同；<br/>例如：正则表达式 "hello" 与字符串 "hellohellohello" 可以用 find() 方法匹配三次； |
| find(<br/>int start<br/>)                                    |   boolean    | 先重置匹配器；<br/>再从字符串中的指定位置开始，搜索正则表达式能匹配的内容；<br>如果匹配成功可以通过start，end和group方法来获得；<br/>注意matches()方法与find()方法不同；<br/>start - 开始搜索的位置；<br>返回true表示已匹配到字符串的一部分； |
| quoteReplacement(<br/>String s<br/>)                         |    String    | 静态方法；<br>将字符串参数转义为字面意义上的字符串； <br>比如：将字符串中的特殊符号（斜杠和美元等）转为字面意义的字符；<br/>s：字符串； |
| appendReplacement(<br/>StringBuffer buf,<br/>String replacement<br/>) |   Matcher    | 会把匹配到的内容替换为 replacement，<br/>且把从上次替换的位置到这次替换位置之间的字符串也拿到，<br/>然后，加上这次替换后的结果一起追加到StringBuffer里；<br/>假如这次替换是第一次替换，那就是只追加替换后的字符串； |
| appendTail(<br/>StringBuffer s<br/>)                         | StringBuffer | 将最后一次匹配后剩余的字符串添加到一个 StringBuffer 对象里；<br>s：字符串缓冲区；<br>返回参数s对象； |
| replaceAll(<br/>String replacement<br/>)                     |    String    | 替换输入字符串中与正则表达式匹配的每个子字符串；<br>replacement：替换字符串；<br>返回替换之后的字符串； |
| replaceFirst(<br/>String replacement<br/>)                   |    String    | 替换输入字符串中首个与正则表达式匹配的子字符串；<br/>replacement：替换字符串；<br/>返回替换之后的字符串； |
| region(<br/>int start,<br/>int end<br/>)                     |   Matcher    | 设置匹配器使用的区域边界；<br/>调用此方法会重置匹配器；<br>start （含）和 end（不含）； |
| regionStart()                                                |     int      | 返回区域边界的开始位置； <br/>regionStart （含）和regionEnd （不含）； |
| regionEnd()                                                  |     int      | 返回区域边界的结束位置（不包含）； <br/>regionStart （含）和regionEnd （不含）； |
| hasTransparentBounds()                                       |   boolean    | 返回 true 表示匹配器的区域边界透明；<br>返回 false 表示匹配器的区域边界不透明； |
| useTransparentBounds(<br/>boolean b<br/>)                    |   Matcher    | 设置匹配器的区域边界的透明度；<br>如果使用 region 方法来限定被匹配字符串的范围；<br/>透明度设置为true时，regex就看得见边界前面的字符串；<br/>true：表示边界透明，不能忽略边界前的字符串；<br/>false：表示边界不透明，自动忽略边界前的字符串； |
| hasAnchoringBounds()                                         |   boolean    | 返回匹配器的区域边界的锚定规则；<br>false：表示匹配器不使用区域边界匹配诸如\^和\$之类的锚点；<br>true：表示匹配器使用区域边界匹配诸如\^和\$之类的锚点； |
| useAnchoringBounds(<br/>boolean b<br/>)                      |   Matcher    | 使用匹配器的区域边界作为锚定边界；<br/>如果使用 region 方法来限定被匹配字符串的范围；<br><br/>使用锚定边界，则匹配器在区域边界内，匹配诸如\^和\$之类的锚点；<br/>不使用锚定边界，则匹配器不在区域边界内，匹配诸如\^和\$之类的锚点；<br/><br/>b：true表示使用设定的区域边界，false表示不使用设置的区域边界；<br>默认为false，匹配器不使用区域边界匹配诸如\^和\$之类的锚点； |
| hitEnd()                                                     |   boolean    | 如果在此匹配器执行的最后一次匹配操作（matcher()方法）中命中了字符串的结尾，则返回true； |
| requireEnd()                                                 |   boolean    | ？？？                                                       |



### PatternSyntaxException类

是一个非检查型异常，表示正则表达式的语法错误；

| 方法             | 返回值 | 说明                                                         |
| ---------------- | ------ | ------------------------------------------------------------ |
| getDescription() | String | 获取错误的描述                                               |
| getIndex()       | int    | 获取错误的索引                                               |
| getPattern()     | String | 获取错误的正则表达式模式                                     |
| getMessage()     | String | 返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示 |



## 使用案例

**find 和 group方法**

```java
public class TestRegex {
	public static void main(String[] args) {
		Pattern pattern = Pattern.compile("^(?<NAME1>\\d+)(?<NAME2>[\\+|\\-|\\*|\\/])(?<NAME3>\\d+)$", Pattern.MULTILINE);
		Matcher matcher = pattern.matcher("11+22");
		if (matcher.find()) {
			System.out.println("完整匹配: " + matcher.group(0));
			for (int i = 1; i <= matcher.groupCount(); i++) {
				System.out.println("组 " + i + ": " + matcher.group(i) + " " + matcher.group("NAME" + i));
			}
		} else {
			System.out.println("NO MATCH");
		}
	}
}
```

输出结果：

```http
完整匹配: 11+22
组 1: 11
组 2: +
组 3: 22
```

**matches 和 lookingAt方法**

```java
public class TestRegex1 {
	public static void main(String[] args) {
		boolean match = Pattern.matches(".*runoob.*", "I am noob from runoob.com.");
		System.out.println("字符串中是否包含了 'runoob' 子字符串? " + match);
		
		Pattern p1 = Pattern.compile("foo");
		Matcher m1 = p1.matcher("fooooooooooooooooo");
		Matcher m2 = p1.matcher("ooooofoooooooooooo");
		System.out.println("lookingAt(): " + m1.lookingAt()); // 正则表达式只匹配字符串前缀
		System.out.println("matches(): " + !m1.matches()); // 不能匹配
		System.out.println("lookingAt(): " + !m2.lookingAt()); // 不能匹配
		
		Pattern p3 = Pattern.compile("hello");
		Matcher m3 = p3.matcher("hellohellohello");
		System.out.println("find(): " + m3.find() + " " + m3.group() + " " + m3.start() + " - " + m3.end()); // 用正则表达式逐个匹配
		System.out.println("find(): " + m3.find() + " " + m3.group() + " " + m3.start() + " - " + m3.end());
		System.out.println("find(): " + m3.find() + " " + m3.group() + " " + m3.start() + " - " + m3.end());
		System.out.println("matches(): " + !m3.matches()); // 匹配整个字符串
	}
}
```

输出结果：

```http
字符串中是否包含了 'runoob' 子字符串? true
lookingAt(): true
matches(): true
lookingAt(): true
find(): true hello 0 - 5
find(): true hello 5 - 10
find(): true hello 10 - 15
matches(): true
```

**replaceFirst 和 replaceAll 方法**

```java
public class TestRegex2 {
	public static void main(String[] args) {
		Pattern p = Pattern.compile("woman");
		Matcher m = p.matcher("The woman says hello. All woman say hello.");
		System.out.println(m.replaceAll("person"));
	}
}
```

输出结果：

```http
The person says hello. All person say hello.
```

**appendReplacement 和 appendTail 方法**

```java
public class TestRegex3 {
	public static void main(String[] args) {
		Pattern p = Pattern.compile("a*b");
		Matcher m = p.matcher("aabfooaabfooabfoobkkk");
		StringBuffer buf = new StringBuffer();
		while (m.find()) {
			m.appendReplacement(buf, "-");
		}
		m.appendTail(buf);
		System.out.println(buf);
	}
}
```

输出结果：

```http
-foo-foo-foo-kkk
```

**region、 regionStart 和 regionEnd 方法**

```java
public class TestRegex4 {
	public static void main(String[] args) {
		Pattern p = Pattern.compile("(\\w+)%(\\d+)");
		Matcher m = p.matcher("ab%12-cd%34");
		m.region(0, 4);
		while (m.find()) {
			System.out.println("group():" + m.group()); // ab%1
			System.out.println("regionStart():" + m.regionStart()); // 0
			System.out.println("regionEnd():" + m.regionEnd()); // 4
		}
	}
}
```

输出结果：

```http
group(): ab%1
regionStart(): 0
regionEnd(): 4
```

**useTransparentBounds方法**

```java
public class TestRegex5 {
	public static void main(String[] args) {
		String text = "Madagascar is best seen by car or bike.";
		Matcher m = Pattern.compile("\\bcar\\b").matcher(text);
		m.region(7, text.length());
//		region区域从index=7开始，Madagascar也就是从car开始，匹配器无法感知region区域外的字符，因此第一个car被匹配。
		m.useTransparentBounds(false);
		m.find();
		System.out.println("Matches starting at character " + m.start()); // 7
		
		m.reset();
//		region区域从index=7开始，Madagascar也就是从car开始，匹配器可以感知region区域外的字符，因此第一个car不被匹配。
		m.useTransparentBounds(true);
		m.find();
		System.out.println("Matches starting at character " + m.start()); // 27
	}
}
```

输出结果：

```java
Matches starting at character 7
Matches starting at character 27
```

**useAnchoringBounds方法**

```java
public class TestRegex6 {
	public static void main(String[] args) {
		String text = "Madagascar is best seen by car or bike.";
		Matcher m = Pattern.compile("^car").matcher(text);
		m.region(7, text.length());
		
		m.useAnchoringBounds(true);
		m.find();
		System.out.println("Matches starting at character " + m.start());
		
		m.reset();
		m.useAnchoringBounds(false);
		m.find();
		System.out.println("Matches starting at character " + m.start());
	}
}
```

输出结果：

```java
Matches starting at character 7
Exception in thread "main" java.lang.IllegalStateException: No match available
	at java.util.regex.Matcher.start(Matcher.java:343)
	at test.indi.lvzhaojun.test.TestRegex6.main(TestRegex6.java:19)
```

**usePattern方法**

```java
public class TestRegex7 {
	public static void main(String[] args) {
		Pattern pattern = Pattern.compile("[#%&*]");
		Matcher matcher = pattern.matcher("#*mypassword&");
		int count = 0;
		while (matcher.find()) {
			count++;
		}
		System.out.println(count);
		
		Pattern newPattern = Pattern.compile("\\A(?=\\w{6,15}\\z)");
		matcher = matcher.usePattern(newPattern);
		if (matcher.find()) {
			System.out.println("Given input contain 6 to 15 characters");
		} else {
			System.out.println("Given input doesn't contain 6 to 15 characters");
		}
	}
}
```

输出结果：

```java
3
Given input doesn't contain 6 to 15 characters
```

**toMatchResult方法**

```java
public class TestRegex8 {
	public static void main(String[] args) {
		Pattern pattern = Pattern.compile("[#]");
		Matcher matcher = pattern.matcher("#This #is #a #sample #text");
		while (matcher.find()) {
			System.out.println(matcher.toMatchResult());
		}
	}
}
```

输出结果：

```java
java.util.regex.Matcher[pattern=[#] region=0,26 lastmatch=#]
java.util.regex.Matcher[pattern=[#] region=0,26 lastmatch=#]
java.util.regex.Matcher[pattern=[#] region=0,26 lastmatch=#]
java.util.regex.Matcher[pattern=[#] region=0,26 lastmatch=#]
java.util.regex.Matcher[pattern=[#] region=0,26 lastmatch=#]
```

**使用模式匹配**

```java
public class TestRegex9 {
	public static void main(String[] args) {
		// 忽略字符串中的大小写，且正则表达式中的特殊字符作为普通文本
		Pattern p0 = Pattern.compile("^EXAMPLE$", Pattern.LITERAL | Pattern.CASE_INSENSITIVE);
		Matcher m0 = p0.matcher("HERE IS A SIMPLE ^examplE$ ");
		System.out.println(m0.find() + " " + m0.group(0));
		
		// 忽略字符串中的大小写，将字符串看作是多个行组成的，匹配每行中的内容
		Pattern p1 = Pattern.compile("^apple$", Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);
		Matcher m1 = p1.matcher("HERE \napple\nman\nwoman\n");
		System.out.println(m1.find() + " " + m1.group(0));
		
		// 忽略字符串中的大小写，将忽略空格字符与注释内容
		Pattern p2 = Pattern.compile("^a pple", Pattern.COMMENTS | Pattern.CASE_INSENSITIVE);
		Matcher m2 = p2.matcher("#apple");
		System.out.println(!m2.find());
		
		// 启用规范等价模式
		char c1 = '\u00E9';
		char c2 = '\u0065';
		char c3 = '\u0301';
		Pattern p3 = Pattern.compile("\u00E9", Pattern.CANON_EQ);
		Matcher m3 = p3.matcher("\u0065\u0301");
		System.out.println(m3.find() + " " + c1 + " 匹配 " + c2 + c3);
		
		// 忽略字符串中的大小写，只使用 \n 作为换行符
		Pattern p4 = Pattern.compile("^apple$", Pattern.MULTILINE | Pattern.CASE_INSENSITIVE | Pattern.UNIX_LINES);
		Matcher m4 = p4.matcher("HERE \rapple\nman\nwoman\n");
		System.out.println(!m4.find());
		
		// 忽略字符串中Unicode字符的大小写，希腊字母Ω的小写就是ω，Υ的小写字母是υ
		Pattern p5 = Pattern.compile("^ΥappleΩ$", Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE);
		Matcher m5 = p5.matcher("υApplEω");
		System.out.println(m5.find());
		
		// 忽略字符串中Unicode字符的大小写，匹配Unicode字符中的空白与字母，即\w原来匹配英文字母，现在可以匹配中文
		Pattern p6 = Pattern.compile("^Υ\\w+Ω$", Pattern.UNICODE_CHARACTER_CLASS | Pattern.CASE_INSENSITIVE);
		Matcher m6 = p6.matcher("υ吕钊军ω");
		System.out.println(m6.find());
	}
}
```



------



# 引用（java.lang.ref）



## 强引用

英文 StrongReference，使用 new 关键字创建的对象都是强引用，对应的是 Finalizer 类。



## 软引用

英文 SoftReference，如果内存不⾜的时候执行GC，软引⽤对象会被回收，对应 SoftReference 类。

软引用一般用作缓存。



## 弱引用

英文 WeakReference，⽆论内存是否⾜够，只要执行GC，弱引用对象都会被回收，对应 WeakReference 类。

WeakHashMap 类中键是弱引用。

ThreadLocal.ThreadLocalMap 类的键是弱引用。



## 虚引用

英文 PhantomReference，任何时候都可能被GC回收，对应 PhantomReference 类。

虚引用的 get() 方法总是返回 null。




------



# 断言（assert）

断言是一种常用的调试方式，可以在开发和测试期间启用一些断言语句，但在生产环境中要禁用这些断言语句。



## 启用/禁用

启用或禁用断言是类加载器的功能，当断言被禁用后，类加载器将跳过断言代码，所以启用或禁用断言不会降低程序的运行速度。

可使用 `-enableassertions` 或 `-ea` 选项来开启断言机制，默认是关闭的。

```shell
# 启用断言
java -ea MyApp

# 针对指定类和指定包下的类，启用断言
java -ea:MyApp -ea:test.spring MyApp
```

可使用 `-disableassertions` 或 `-da` 选项来禁用断言机制。

```shell
# 禁用断言
java -da MyApp

# 针对指定类和指定包下的类，禁用断言
java -da:MyApp -da:test.spring MyApp
```



## 语法格式

- assert booleanExpression

  如果booleanExpression表达式值为 true 时，程序从断言语句处继续执行；

  如果booleanExpression表达式值为 false 时，程序从断言语句处停止执行；

- assert booleanExpression:messageExpression

  求值为字符串类型的表达式；

  如果booleanExpression表达式值为true时，程序从断言语句处继续执行；

  如果booleanExpression表达式值为false时，程序从断言语句处停止执行，并输出messageException表达式的值作为异常的描述信息；



------



# 反射（reflect）

在 Java 程序运行过程中，可通过 java.lang.reflect 包中的 API 动态的获取、调用任意对象、任意类的类信息、方法和变量的功能称为反射；

- 在运行时判断任意一个对象所属的类；
- 在运行时构造任意一个类的对象；
- 在运行时判断任意一个类所具有的成员变量和方法；
- 在运行时调用任意一个对象的方法；
- 生成动态代理；

主要的类说明如下：

- Constructor 类：提供类的构造方法信息；
- Field 类：提供类或接口中成员变量信息；
- Method 类：提供类或接口成员方法信息；
- Array 类：提供了动态创建和访问 Java 数组的方法；
- Modifier 类：提供类和成员访问修饰符信息；

动态获取对象构造方法：

- getConstructors()
- getConstructor(Class<?>…parameterTypes)
- getDeclaredConstructors()
- getDeclaredConstructor(Class<?>...parameterTypes)

动态获取对象的方法：

- getMethods()
- getMethods(String name,Class<?> …parameterTypes)
- getDeclaredMethods()
- getDeclaredMethods(String name,Class<?>...parameterTypes)

动态获取成员变量的方法：

- getFields()
- getField(String name)
- getDeclaredFields()
- getDeclaredField(String name)

？？？



------



# 泛型（Generics）

是Java5新特性，是一种模板代码的技术，可在代码编译期间检查对象的类型是否安全，保证了程序运行期间对象类型的安全；

编程语言泛型实现方式都不同，Java使用的是擦拭法（Type Erasure），即虚拟机对泛型一无所知，所有的工作都是编译器做的；

擦拭法决定了泛型

- 不能是基本类型；
- 不能判断泛型的类型，例如：`x instanceof Pair<String>`；
- 不能实例化`T`类型，例如：`new T()`；
- 子类可以获取父类的泛型类型`<T>`；
- 可以声明带泛型的数组，但不能创建带泛型的数组，只能强制转换`T[] array = (T[]) Array.newInstance(Class<T>, int)`；

通配符要遵循PECS原则（Producer Extends Consumer Super）

| 通配符  | 举例                     | 说明                                                   |
| ------- | ------------------------ | ------------------------------------------------------ |
| 无限定  | `Pair<?>`                | 表示可以匹配任意类型；                                 |
| extends | `List<T extends Number>` | 上界通配符；<br>限定必须是 `T` 类型或是 `T` 的子类；   |
| super   | `List<? super Integer>`  | 下界通配符；<br>限定必须是 `T` 类型或是 `T` 类的父类； |

- Producer Extends（生产者用extends）：如果要从集合中读取类型T的数据， 并且无需写入，可以使用**extends**通配符；

- Consumer Super（消费者用super）：如果要从集合中写入类型T的数据， 并且无需读取，可以使用**super**通配符；

- 如果既要存又要取， 那么就不要使用通配符；



------



# 注解（Annotation）

是Java5新特性，是一种注释机制，注解是用来修饰包、类、构造方法、实例方法、实例变量、参数、局部变量的一种特殊注释；

注解分类：

## 标准注解

JAVA编译器会扫描这些标准注解标记的代码，用于执行检查，发现程序警告与错误；

标准注解是 Java 自带的注解，但不会被编译进字节码文件；

| 注解                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| @Override            | 编译器会检查被注解标准的方法是否正确地复写了父类方法；       |
| @SuppressWarnings    | 编译器会忽略此处代码产生的警告；                             |
| @Deprecated          | 编译器会警告被注解标记的方法已过，且不建议使用；             |
| @FunctionalInterface | **<u>JDK8</u>**新特性，指示被修饰的接口是一个匿名函数或函数式接口； |
| @SafeVarargs         | **<u>JDK7</u>**新特性，在可变长参数中的泛型是类型安全的；    |



## 元注解

元注解是用于定义注解的注解；

| 注解        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| @Retention  | 用来定义该注解在哪一个级别可用，在源代码中（SOURCE）、类文件中（CLASS）或者运行时（RUNTIME）； |
| @Target     | 用于描述注解的使用范围（类、构造方法、方法参数、方法、字段、包、局部变量等）； |
| @Inherited  | 注解所修饰类的所有子类都将会继承此注解；                     |
| @Documented | 生成文档信息的时候保留注解，对类作辅助说明；                 |
| @Repeatable | **<u>JDK8</u>**新特性，表示注解在同一个地方可以重复出现多次，但必须指定对应的容器注解；<br>如果重复使用同一注解时，在编译阶段会将多个重复注解转换为对应的容器注解；<br>注意当注解在同一位置只出现了1次的时候，并不会默认生成容器注解； |



## 自定义注解

- 注解中可定义多个参数，且参数可以有默认值，核心参数要用 value；
- 如果注解参数名称是 value，且注解只有这一个参数，那么使用时可以省略参数名称，即@Value("name")；
- 如果注解有多个参数，且多个参数没有默认值，那么 value 名称是不能省略的；
- 如果注解中没有使用任何参数，相当于全部参数使用默认值；
- 注解中参数可以使用：基本类型、String、枚举、Class、注解以及以上类型的数组；
- 注解默认都实现了 Annotation 接口；

- AnnotatedElement接口

   | 方法                                                    | 返回值  | 说明                                                         |
   | ------------------------------------------------------- | ------- | ------------------------------------------------------------ |
   | isAnnotationPresent(Class\<Annotation> annotationClass) | boolean | 如果当前对象上存在指定类型的注解；<br/>返回true；<br>否则返回false； |

   |      限定词       |   中文   | 说明                                                         |
   | :---------------: | :------: | ------------------------------------------------------------ |
   | directly present  | 直接修饰 | 只是元素上声明的注解                                         |
   | indrectly present | 间接修饰 | 注解就是指得容器注解里面的数组指定的注解；<br/>`public @interface RepeatAns {RepeatAn[] value();}` <br>当注解A并没有配置在类E上，但是包含这个注解A的注解B被E直接引用了，这属于E对A的间接修饰； |
   |      present      |   引用   | 是直接修饰注解和从父类继承的（可继承的）注解的合集；<br>注解A（必须是可继承的，即用@Inherited标识）直接配置在E类的父类F上，那么E与A的关系则为引用关系； |
   |    associated     |   关联   | 返回值包含以上三种注解                                       |

   AnnotatedElement中的方法根据限定词返回指定范围的注解：

   |                          方法                           | 直接修饰 | 间接修饰 | Present | 关联 |
   | :-----------------------------------------------------: | :------: | :------: | :-----: | :--: |
   |                 T getAnnotation(Class)                  |          |          |    ✅    |      |
   |              Annotation[] getAnnotations()              |          |          |    ✅    |      |
   |             T[] getAnnotationsByType(Class)             |          |          |         |  ✅   |
   |     T getDeclaredAnnotation(Class annotationClass)      |    ✅     |          |         |      |
   | T[] getDeclaredAnnotationsByType(Class annotationClass) |    ✅     |    ✅     |         |      |
   |          Annotation[] getDeclaredAnnotations()          |    ✅     |          |         |      |

- @Repeatable注解说明

   ```java
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.RUNTIME)
   @Repeatable(RepeatAns.class) // 使用容器注解
   @interface RepeatAn {
   }
   
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.RUNTIME)
   @interface RepeatAns {
   	RepeatAn[] value();
   }
   
   public class RepeatableTest {
   	
   	@RepeatAn()
   	@RepeatAn()
   	public void method() {
   	}
   	
   	public static void main(String[] args) throws Exception {
   		Method method = RepeatableTest.class.getDeclaredMethod("method");
   		RepeatAn an = method.getAnnotation(RepeatAn.class);
   		System.out.println(an);
   		System.out.println("****************************************");
   		RepeatAns ans = method.getAnnotation(RepeatAns.class);
   		System.out.println(ans);
   		System.out.println("****************************************");
   		RepeatAn[] anArr = method.getAnnotationsByType(RepeatAn.class);
   		System.out.println(anArr);
   	}
   }
   ```

   输出结果：

   ```java
   null
   ****************************************
   @test.indi.lvzhaojun.test.spring.RepeatAns(value=[@test.indi.lvzhaojun.test.spring.RepeatAn(), @test.indi.lvzhaojun.test.spring.RepeatAn()])
   ****************************************
   [Ltest.indi.lvzhaojun.test.spring.RepeatAn;@45ee12a7
   ```

   因为在method()方法上 @RepeatAn 注解出现了两次，编译时会替换为容器注解：@RepeatAns(value = {@RepeatAn(), @RepeatAn()})。

   所以 getAnnotation() 方法会返回 null。

   同理 getAnnotation(RepeatAns.class) 方法可以返回 @RepeatAns 注解信息。

   同理 getAnnotationsByType(RepeatAn.class) 方法返回的是关联注解，所以能获取 @RepeatAn 注解数组。




## 反射API

| 方法                                   | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| Class.isAnnotationPresent(Class)       | 判断类信息上是否配置了指定类型的注解<br>对应的是Present限定词的规则 |
| Field.isAnnotationPresent(Class)       | 判断字段上是否配置了指定类型的注解<br/>对应的是Present限定词的规则 |
| Method.isAnnotationPresent(Class)      | 判断方法上是否配置了指定类型的注解<br/>对应的是Present限定词的规则 |
| Constructor.isAnnotationPresent(Class) | 判断构造方法上是否配置了指定类型的注解<br/>对应的是Present限定词的规则 |

| 方法                             | 说明                                         |
| -------------------------------- | -------------------------------------------- |
| Class.getAnnotation(Class)       | 返回类上配置的注解，注解类型与参数一致       |
| Field.getAnnotation(Class)       | 返回字段上配置的注解，注解类型与参数一致     |
| Method.getAnnotation(Class)      | 返回方法上配置的注解，注解类型与参数一致     |
| Constructor.getAnnotation(Class) | 返回构造方法上配置的注解，注解类型与参数一致 |



------



#  枚举（enum）

是Java5新特性，可以限制变量只能是预先设定好的值；

所有枚举类都默认继承了 java.lang.Enum 类，并实现了 Serializable 和 Comparable 两个接口；

- 枚举跟普通类一样可以用自己的变量、方法和构造方法；
- 构造方法只能使用 private 访问修饰符，所以外部无法调用；
- 枚举可以包含具体方法；
- 枚举可以包含抽象方法，但是每个实例都必须实现这个抽象方法；
- 枚举可以使用 for 语句来迭代枚举元素；
- 枚举类常应用于 switch 语句中；
- 枚举对象方法 values()、ordinal() 与 valueOf() 方法位于java.lang.Enum类；

| java.lang.Enum方法                                   | 返回值    | 说明                                                         |
| ---------------------------------------------------- | --------- | ------------------------------------------------------------ |
| Enum.values()                                        | Enum[]    | 静态方法 <br/>返回所有枚举常量数组                           |
| name()                                               | String    | 返回声明枚举时使用的名称                                     |
| ordinal()                                            | int       | 返回枚举在声明时的顺序编号，从0开始                          |
| getDeclaringClass()                                  | Class\<E> | 返回此枚举常量的Class对象                                    |
| valueOf(<br>Class<T> enumType,<br/>String name<br/>) | Enum      | 静态方法 <br/>返回指定类型、指定名称的枚举常量 <br/>enumType：是枚举常量的 Class 信息；<br/>name：是枚举常量的名，大小写敏感； |
| valueOf(<br/>String name<br/>)                       | Enum      | 静态方法 <br/>根据指定枚举名称返回对应的枚举常量 <br/>name：是枚举常量的名，大小写敏感； |
| compareTo(E o)                                       | int       | 将此枚举与指定对象进行顺序比较。<br/>当枚举小于、等于或大于指定枚举时，返回负整数、零或正整数。<br/>枚举常量只能与相同类型的其他枚举常量相比较。<br/>自然顺序是枚举的声明顺序。 |
| toString()                                           | String    | 返回声明枚举时使用的名称                                     |

```java
enum Color {
	RED {
		public String getColor() {
			return "红色";
		}
	},
	GREEN {
		public String getColor() {
			return "绿色";
		}
	},
	BLUE {
		public String getColor() {
			return "蓝色";
		}
	};
	
	public abstract String getColor();
}

public class TestEnum {
	public static void main(String[] args) {
		Color.valueOf("RED");
		Color o = Color.valueOf(Color.class, "RED");
		for (Color c : Color.values()) {
			System.out.println(c.ordinal() // 声明序号
					+ " " + c.name() // 枚举常量名
					+ " " + c.getDeclaringClass().getName() // 枚举的Class信息
					+ " " + c.getColor() //
					+ " " + (o != null ? c.compareTo(o) : 1)); // 比较枚举顺序
			o = c;
		}
	}
}
```



------



# 异常（Throwable）

```mermaid
flowchart TD
    A[Throwable] --> B[Exception]
    A[Throwable] --> C[  Error  ]
    B[Exception] --> D[RuntimeException]
    B[Exception] --> E[Checked Exception]
    style A fill:stroke:#333,width:150px;
    style B fill:stroke:#333,width:150px;
    style C fill:stroke:#333,width:150px;
    style D fill:stroke:#333,width:150px;
    style E fill:stroke:#333,width:150px;
```

**java.lang.Throwable**类是所有异常的超类：

| Throwable方法      | 返回值              | 说明                                                         |
| ------------------ | ------------------- | ------------------------------------------------------------ |
| getMessage()       | String              | 返回异常的描述信息，这个信息可以从构造方法作为参数传入       |
| getCause()         | Throwable           | 返回引起当前错误的异常信息                                   |
| toString()         | String              | 返回异常信息的说明                                           |
| printStackTrace()  | void                | 用 **System.err** 输出异常对象的堆栈跟踪信息                 |
| getStackTrace()    | StackTraceElement[] | 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表栈底 |
| fillInStackTrace() | Throwable           | 会清空原来的栈内的trace信息，然后在当前的调用位置处重新建立trace信息；<br>例如：在方法b()中printStackTrace的执行结果跟c()中的是不一样的，<br>b()方法被c()调用，c()被a()调用，a()被main()调用， <br/>所以在b()中fillInStackTrace时，栈内会包含b(), a(), main()的信息；<br/>而在c()中调用fillInStackTrace时，栈内的信息会被刷新为c(), a(), main() |

## Error

程序无法自己处理的错误，例如：OutofmemoryError（内存溢出错误）；



## Exception

是程序可预测的异常信息，分为二种：



### 非检查型异常

指的是 java.lang.RuntimeException及其子类，不需要在代码中声明的异常，编译器也不会检查这种异常错误；

| 非检查性异常                    | **描述**                                                     |
| :------------------------------ | :----------------------------------------------------------- |
| ArithmeticException             | 当出现异常的运算条件时，抛出此异常。例如，一个整数"除以零"时，抛出此类的一个实例 |
| ArrayIndexOutOfBoundsException  | 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引 |
| ArrayStoreException             | 试图将错误类型的对象存储到一个对象数组时抛出的异常           |
| ClassCastException              | 当试图将对象强制转换为不是实例的子类时，抛出该异常           |
| IllegalArgumentException        | 抛出的异常表明向方法传递了一个不合法或不正确的参数           |
| IllegalMonitorStateException    | 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程 |
| IllegalStateException           | 在非法或不适当的时间调用方法时产生的信号<br>换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下 |
| IllegalThreadStateException     | 线程没有处于请求操作所要求的适当状态时抛出的异常             |
| IndexOutOfBoundsException       | 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出 |
| NegativeArraySizeException      | 如果应用程序试图创建大小为负的数组，则抛出该异常             |
| NullPointerException            | 当应用程序试图在需要对象的地方使用 `null` 时，抛出该异常     |
| NumberFormatException           | 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 |
| SecurityException               | 由安全管理器抛出的异常，指示存在安全侵犯                     |
| StringIndexOutOfBoundsException | 此异常由 `String` 方法抛出，指示索引或者为负，或者超出字符串的大小 |
| UnsupportedOperationException   | 当不支持请求的操作时，抛出该异常                             |



### 检查型异常

这类异常必须在代码中用 throws 关键字声明出来，如果没有声明，在编译时检查阶段会报错；

| 检查性异常类               | **描述**                                                     |
| :------------------------- | :----------------------------------------------------------- |
| ClassNotFoundException     | 应用程序试图加载类时，找不到相应的类，抛出该异常。           |
| CloneNotSupportedException | 当调用 `Object` 类中的 `clone` 方法克隆对象，但该对象的类无法实现 `Cloneable` 接口时，抛出该异常。 |
| IllegalAccessException     | 拒绝访问一个类的时候，抛出该异常。                           |
| InstantiationException     | 当试图使用 `Class` 类中的 `newInstance` 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。 |
| InterruptedException       | 一个线程被另一个线程中断，抛出该异常。                       |
| NoSuchFieldException       | 请求的变量不存在                                             |
| NoSuchMethodException      | 请求的方法不存在                                             |



## OOM错误

英文 Out Of Memory，对应java.lang.OutOfMemoryError异常类，是指新申请的内存空间大于虚拟机能分配的空间限制。

使用 jps 命令查看虚拟机进程pid，根据pid执行jstat命令查看内存使用情况，根据pid导出快照日志，使用mat或jhat分析快照日志定位是内存泄漏还是溢出。



### 内存泄露

使用完的内存没有得到释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。

可以使用Jmap、MAT工具定位是那些对象过多未释放内存导致的，在根据对象的类型到程序中查看是否是逻辑问题，还是未释放对象造成的。



### 内存溢出

申请的内存超出了JVM能提供的内存大小，此时称之为溢出。

可以通过虚拟机的堆参数（ -Xmx和-Xms）来适当调大参数。



## jps

英文 JVM Process Status Tool，用于显示系统内所有HotSpot虚拟机进程信息。

```shell
$ jps [-q] [-mlvV] [<hostname>[:<port>]]

选项
-l : 输出主类全名或jar路径
-q : 只输出LVMID
-m : 输出JVM启动时传递给main()的参数
-v : 输出JVM启动时显示指定的JVM参数
```

示例：

```shell
$ jps -l -m
  28920 org.apache.catalina.startup.Bootstrap start
  11589 org.apache.catalina.startup.Bootstrap start
  25816 sun.tools.jps.Jps -l -m
```



## **jstat**

JVM statistics Monitoring，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据；

```shell
$ jstat [-option] [-t] [-h<lines>] LVMID [间隔时间/毫秒] [查询次数]

选项：
[option] : 操作参数
LVMID : 本地虚拟机进程ID
[interval] : 连续输出的时间间隔
[count] : 连续输出的次数
```

| 选项             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| class            | class loader的行为统计。Statistics on the behavior of the class loader. |
| compiler         | HotSpt JIT编译器行为统计。Statistics of the behavior of the HotSpot Just-in-Time compiler. |
| gc               | 垃圾回收堆的行为统计。Statistics of the behavior of the garbage collected heap. |
| gccapacity       | 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计。Statistics of the capacities of the generations and their corresponding spaces. |
| gcutil           | 垃圾回收统计概述。Summary of garbage collection statistics.  |
| gccause          | 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因。Summary of garbage collection statistics (same as -gcutil), with the cause of the last and |
| gcnew            | 新生代行为统计。Statistics of the behavior of the new generation. |
| gcnewcapacity    | 新生代与其相应的内存空间的统计。Statistics of the sizes of the new generations and its corresponding spaces. |
| gcold            | 年老代和永生代行为统计。Statistics of the behavior of the old and permanent generations. |
| gcoldcapacity    | 年老代行为统计。Statistics of the sizes of the old generation. |
| gcpermcapacity   | 永生代行为统计。Statistics of the sizes of the permanent generation. |
| printcompilation | HotSpot编译方法统计                                          |



### 类加载统计

```shell
$ jstat -class 2060
Loaded  Bytes  Unloaded  Bytes     Time
 15756  17355.6       0    0.0    11.29
```

```properties
Loaded: 加载class的数量
Bytes: 所占用空间大小
Unloaded: 未加载数量
Bytes: 未加载class的占用空间
Time: 加载时间
```



### 编译统计

```shell
$ jstat -compiler 2060
Compiled Failed Invalid   Time   FailedType FailedMethod
    9142      1       0     5.01          1 org/apache/felix/resolver/ResolverImpl mergeCandidatePackages
```

```properties
Compiled: 编译数量。
Failed: 失败数量
Invalid: 不可用数量
Time: 时间
FailedType: 失败类型
FailedMethod: 失败的方法
```



### 垃圾回收统计

```shell
$ jstat -gc 2060
 S0C    S1C    S0U    S1U      EC       EU        OC         OU          MC     MU    CCSC      CCSU   YGC     YGCT    FGC    FGCT     GCT
20480.0 20480.0  0.0   13115.3 163840.0 113334.2  614400.0   436045.7  63872.0 61266.5  0.0    0.0      149    3.440   8      0.295    3.735
```

```properties
S0C: 第一个幸存区的大小
S1C: 第二个幸存区的大小
S0U: 第一个幸存区的使用大小
S1U: 第二个幸存区的使用大小
EC: 伊甸园区的大小
EU: 伊甸园区的使用大小
OC: 老年代大小
OU: 老年代使用大小
MC: 方法区大小
MU: 方法区使用大小
CCSC: 压缩类空间大小
CCSU: 压缩类空间使用大小
YGC: 年轻代垃圾回收次数
YGCT: 年轻代垃圾回收消耗时间
FGC: 老年代垃圾回收次数
FGCT: 老年代垃圾回收消耗时间
GCT: 垃圾回收消耗总时间
```

每1000毫秒查询一次，选项 `-gcutil` 表示已使用空间占总空间的百分比。

```shell
$ jstat -gcutil 98009 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
  0.00   0.00   2.84  57.19  97.65  92.33     17    0.330     1    0.271     8    0.051    0.652
  0.00   0.00   2.84  57.19  97.65  92.33     17    0.330     1    0.271     8    0.051    0.652
  0.00   0.00   2.84  57.19  97.65  92.33     17    0.330     1    0.271     8    0.051    0.652
  0.00   0.00   2.84  57.19  97.65  92.33     17    0.330     1    0.271     8    0.051    0.652
  0.00   0.00   2.84  57.19  97.65  92.33     17    0.330     1    0.271     8    0.051    0.652
```



### 堆内存统计

```shell
$ jstat -gccapacity 2060
 NGCMN    NGCMX     NGC     S0C     S1C       EC      OGCMN      OGCMX       OGC         OC          MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC
204800.0 204800.0 204800.0 20480.0 20480.0 163840.0   614400.0   614400.0   614400.0   614400.0      0.0    63872.0  63872.0      0.0      0.0      0.0    149     8
```

```properties
NGCMN: 新生代最小容量
NGCMX: 新生代最大容量
NGC: 当前新生代容量
S0C: 第一个幸存区大小
S1C: 第二个幸存区的大小
EC: 伊甸园区的大小
OGCMN: 老年代最小容量
OGCMX: 老年代最大容量
OGC: 当前老年代大小
OC: 当前老年代大小
MCMN: 最小元数据容量
MCMX: 最大元数据容量
MC: 当前元数据空间大小
CCSMN: 最小压缩类空间大小
CCSMX: 最大压缩类空间大小
CCSC: 当前压缩类空间大小
YGC: 年轻代gc次数
FGC: 老年代GC次数
```



### 新生代垃圾回收统计

```shell
$ jstat -gcnew 7172
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT
40960.0 40960.0 25443.1    0.0 15  15 20480.0 327680.0 222697.8     12    0.736
```

```properties
S0C: 第一个幸存区大小
S1C: 第二个幸存区的大小
S0U: 第一个幸存区的使用大小
S1U: 第二个幸存区的使用大小
TT: 对象在新生代存活的次数
MTT: 对象在新生代存活的最大次数
DSS: 期望的幸存区大小
EC: 伊甸园区的大小
EU: 伊甸园区的使用大小
YGC: 年轻代垃圾回收次数
YGCT: 年轻代垃圾回收消耗时间
```



### 新生代内存统计

```shell
$ jstat -gcnewcapacity 7172
  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC
  409600.0   409600.0   409600.0  40960.0  40960.0  40960.0  40960.0   327680.0   327680.0    12     0
```

```properties
NGCMN: 新生代最小容量
NGCMX: 新生代最大容量
NGC: 当前新生代容量
S0CMX: 最大幸存1区大小
S0C: 当前幸存1区大小
S1CMX: 最大幸存2区大小
S1C: 当前幸存2区大小
ECMX: 最大伊甸园区大小
EC: 当前伊甸园区大小
YGC: 年轻代垃圾回收次数
FGC: 老年代回收次数
```



### 老年代垃圾回收统计

```shell
$ jstat -gcold 7172
   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT
 33152.0  31720.8      0.0      0.0    638976.0    184173.0     12     0    0.000    0.736
```

```properties
MC: 方法区大小
MU: 方法区使用大小
CCSC:压缩类空间大小
CCSU:压缩类空间使用大小
OC: 老年代大小
OU: 老年代使用大小
YGC: 年轻代垃圾回收次数
FGC: 老年代垃圾回收次数
FGCT: 老年代垃圾回收消耗时间
GCT: 垃圾回收消耗总时间
```



### 老年代内存统计

```shell
$ jstat -gcoldcapacity 7172
   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT
   638976.0    638976.0    638976.0    638976.0    12     0    0.000    0.736
```

```properties
OGCMN: 老年代最小容量
OGCMX: 老年代最大容量
OGC: 当前老年代大小
OC: 老年代大小
YGC: 年轻代垃圾回收次数
FGC: 老年代垃圾回收次数
FGCT: 老年代垃圾回收消耗时间
GCT: 垃圾回收消耗总时间
```



### 元数据空间统计

```shell
$ jstat -gcmetacapacity 7172
   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT
   0.0    33152.0    33152.0        0.0        0.0        0.0    12     0    0.000    0.736
```

```properties
MCMN: 最小元数据容量
MCMX: 最大元数据容量
MC: 当前元数据空间大小
CCSMN: 最小压缩类空间大小
CCSMX: 最大压缩类空间大小
CCSC: 当前压缩类空间大小
YGC: 年轻代垃圾回收次数
FGC: 老年代垃圾回收次数
FGCT: 老年代垃圾回收消耗时间
GCT: 垃圾回收消耗总时间
```



### 总结垃圾回收统计

```shell
$ jstat -gcutil 7172
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
 62.12   0.00  81.36  28.82  95.68      -     12    0.736     0    0.000    0.736
```

```properties
S0: 幸存1区当前使用比例
S1: 幸存2区当前使用比例
E: 伊甸园区使用比例
O: 老年代使用比例
M: 元数据区使用比例
CCS: 压缩使用比例
YGC: 年轻代垃圾回收次数
FGC: 老年代垃圾回收次数
FGCT: 老年代垃圾回收消耗时间
GCT: 垃圾回收消耗总时间
```



### JVM编译方法统计

```shell
$ jstat -printcompilation 7172
Compiled  Size  Type Method
    4608     16    1 org/eclipse/emf/common/util/SegmentSequence$SegmentSequencePool$SegmentsAccessUnit reset
```

```properties
Compiled: 最近编译方法的数量
Size: 最近编译方法的字节码数量
Type: 最近编译方法的编译类型。
Method: 方法名标识
```



## jmap

英文 Java Memory Map，用于生成堆转储（Heap Dump）文件，可得到JVM的堆快照，从而可以离线分析内存对象。

虚拟机在启动时，可以使用 `-XX:+HeapDumpOnOutOfMemoryError` 选项，在出现OOM错误的时候可以自动生成dump文件。

可查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。



### 选项 -dump

连接到正在运行的进程并转储java堆。

```shell
$ jmap -dump:<dump-options> <pid>
		dump-options:
			live         指明仅转储活动对象。如果未指定，堆中的所有对象都被转储
      format=b     二进制格式
      file=<file>  将堆转储到file中
```

例如： 

```shell
$ jmap -dump:format=b,file=dump.hprof 98009
Dumping heap to /Users/user/jmap/heapdump.bin ...
Heap dump file created [121513882 bytes in 0.529 secs]
```

dump.hprof 这个后缀是为了后续可以直接用MAT打开，也可以使用**jhat**命令打开 `dump.hprof` 转储文件：

```shell
$ jhat dump.hprof
```



### 选项 -finalizerinfo

连接到正在运行的进程，并打印等待完成的对象的信息。

```shell
$ jmap -finalizerinfo <pid>
```

例如：

```shell
$ jmap -finalizerinfo 28920
  Attaching to process ID 28920, please wait...
  Debugger attached successfully.
  Server compiler detected.
  JVM version is 24.71-b01
  Number of objects pending for finalization: 0
```

可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行finalizer方法的对象。



### 选项 -clstats

连接到正在运行的进程，并打印类加载器统计信息。

```shell
$ jmap -clstats <pid>
```



### 选项 -heap

打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况，可以用此来判断内存目前的使用情况以及垃圾回收情况。

```shell
$ jmap -heap 28920
  Attaching to process ID 28920, please wait...
  Debugger attached successfully.
  Server compiler detected.
  JVM version is 24.71-b01  

  using thread-local object allocation.
  Parallel GC with 4 thread(s)//GC 方式  

  Heap Configuration: //堆内存初始化配置
     MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)
     MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)
     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小
     NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小
     MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小
     OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=<value>:设置JVM堆的‘老生代’的大小
     NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率
     SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 
     PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=<value>:设置JVM堆的‘永生代’的初始大小
     MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=<value>:设置JVM堆的‘永生代’的最大大小
     G1HeapRegionSize = 0 (0.0MB)  

  Heap Usage://堆内存使用情况
  PS Young Generation
  Eden Space://Eden区内存分布
     capacity = 33030144 (31.5MB)//Eden区总容量
     used     = 1524040 (1.4534378051757812MB)  //Eden区已使用
     free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量
     4.614088270399305% used //Eden区使用比率
  From Space:  //其中一个Survivor区的内存分布
     capacity = 5242880 (5.0MB)
     used     = 0 (0.0MB)
     free     = 5242880 (5.0MB)
     0.0% used
  To Space:  //另一个Survivor区的内存分布
     capacity = 5242880 (5.0MB)
     used     = 0 (0.0MB)
     free     = 5242880 (5.0MB)
     0.0% used
  PS Old Generation //当前的Old区内存分布
     capacity = 86507520 (82.5MB)
     used     = 0 (0.0MB)
     free     = 86507520 (82.5MB)
     0.0% used
  PS Perm Generation//当前的 “永生代” 内存分布
     capacity = 22020096 (21.0MB)
     used     = 2496528 (2.3808746337890625MB)
     free     = 19523568 (18.619125366210938MB)
     11.337498256138392% used  

  670 interned Strings occupying 43720 bytes.
```

可以很清楚的看到Java堆中各个区域目前的情况。



### 选项 -histo

连接到正在运行的进程，并打印java对象堆的直方图。如果指定了 `:live` 子选项，则只计算活动对象。

```shell
$ jmap -histo[:live] <pid>
```

例如：

```shell
$ jmap -histo:live 28920 | more
 num     #instances         #bytes  class name
----------------------------------------------
   1:         83613       12012248  <constMethodKlass>
   2:         23868       11450280  [B
   3:         83613       10716064  <methodKlass>
   4:         76287       10412128  [C
   5:          8227        9021176  <constantPoolKlass>
   6:          8227        5830256  <instanceKlassKlass>
   7:          7031        5156480  <constantPoolCacheKlass>
   8:         73627        1767048  java.lang.String
   9:          2260        1348848  <methodDataKlass>
  10:          8856         849296  java.lang.Class
  ....
```

输出结果中的 **Class name** 表示对象类型，说明如下：

```ini
B  byte
C  char
D  double
F  float
I  int
J  long
Z  boolean
[  数组，如[I表示int[]
[L+类名 其他对象
```



### 选项 -permstat

打印Java堆内存的永久保存区域的类加载器的智能统计信息。对于每个类加载器而言，名称、活跃度、地址、父类加载器、所加载的类的数量和大小都会被打印。

此外，包含的字符串数量和大小也会被打印。

```shell
$ jmap -permstat 28920
  Attaching to process ID 28920, please wait...
  Debugger attached successfully.
  Server compiler detected.
  JVM version is 24.71-b01
  finding class loader instances ..done.
  computing per loader stat ..done.
  please wait.. computing liveness.liveness analysis may be inaccurate ...
  
  class_loader            classes bytes   parent_loader           alive?  type  
  <bootstrap>             3111    18154296          null          live    <internal>
  0x0000000600905cf8      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0
  0x00000006008fcb48      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0
  0x00000006016db798      0       0       0x00000006008d3fc0      dead    java/util/ResourceBundle$RBClassLoader@0x0000000780626ec0
  0x00000006008d6810      1       3056      null          dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0
```



### 选项 -F

强制模式，如果指定的pid没有响应，请使用jmap -dump或jmap -histo选项。此模式下，不支持live子选项。



## jhat

英文 JVM Heap Analysis Tool，用来分析jmap命令生成的dump文件，内置了一个微型的HTTP服务器，可以在浏览器中查看分析结果。

注意正常不应该在服务器上使用jhat命令，因为jhat命令非常耗费硬件资源，可以把dump文件复制到开发环境上进行分析。

分析同样一个dump快照文件，MAT需要的内存比jhat要小的多，所以建议使用MAT来进行分析。

```shell
$ jhat [-stack <bool>] [-refs <bool>] [-port <port>] [-baseline <file>] [-debug <int>] [-version] [-h|-help] <file>

选项：
-stack false|true
关闭对象分配调用栈跟踪(tracking object allocation call stack)。
如果分配位置信息在堆转储中不可用，则必须将此标志设置为 false，默认为 true

-refs false|true
关闭对象引用跟踪（tracking of references to objects）
默认为true，返回的指针是指向其他特定对象的对象，如反向链接或输入引用(referrers or incoming references)，会统计/计算堆中的所有对象

-port port-number
设置 HTTP server 的端口号，默认值 7000

-exclude exclude-file
指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。
例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除

-baseline exclude-file
指定一个基准堆转储（baseline heap dump），用于比较两个不同的堆转储信息
在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new)
其他对象被标记为新的(new)

-debug int
设置 debug 级别，0 表示不输出调试信息。值越大则表示输出更详细的 debug 信息

-version
启动后只显示版本信息就退出

-J <flag>
因为 jhat 命令会启动一个新JVM来运行, 通过 -J 可以在启动JVM时传入一些启动参数
例如, -J-Xmx512m 是指定虚拟机使用的最大堆内存为 512 MB
如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.
```

例如：

```shell
$ jhat -J-Xmx512m dump.hprof
  eading from dump.hprof...
  Dump file created Fri Mar 11 17:13:42 CST 2016
  Snapshot read, resolving...
  Resolving 271678 objects...
  Chasing references, expect 54 dots......................................................
  Eliminating duplicate references......................................................
  Snapshot resolved.
  Started HTTP server on port 7000
  Server is ready.
```

启动后用浏览器打开 Http://localhost:7000，如下所示：

![img](./01.Java_part1.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjY3NzA2,size_16,color_FFFFFF,t_70-20230215150950009.png)

可以在 Heap Histogram 视图中查看所有存活对象

![img](./01.Java_part1.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjY3NzA2,size_16,color_FFFFFF,t_70.png)



## MAT

MAT（Memory Analyzer Tool ）工具用来分析dump文件，可以查看对象类型、对象个数、占用的内存容量。

- Histogram：可以列出内存中的对象，对象的个数以及大小；
- Dominator Tree：可以列出那个线程，以及线程下面的那些对象占用的空间；
- Top consumers：通过图形列出最大的object；
- Leak Suspects：泄露嫌疑分析，通过MAT自动分析泄漏的原因；

https://www.cnblogs.com/trust-freedom/p/6744948.html#histogram



------



# 数组（Array）

数组是相同类型元素的集合。创建数组的时候，虚拟机会在堆内存中分配一段连续的空间来存放数组元素；

| Arrays工具类                                                 | 返回值  | 说明                                                         |
| ------------------------------------------------------------ | :-----: | ------------------------------------------------------------ |
| copyOf(<br/>short[] original, <br/>int newLength<br/>)       | short[] | 返回一个数组的副本，新副本数组的长度是参数newLength          |
| copyOfRange(<br/>T[] original, <br/>int from, <br/>int to<br/>) |   T[]   | 返回参数数组的副本，从**<u>from</u>**开始复制，复制到**<u>to</u>**；<br>是左闭右开区间，即包括**<u>from</u>**，但不包括**<u>to</u>**； |
| equals(<br/>long[] a, <br/>long[] a2<br/>)                   | boolean | 如果两个指定的类型数组彼此相等，则返回 true；<br/>即数组元素数量相同、元素顺序一致且相等；<br/>同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）； |
| fill(<br/>int[] a, <br/>int val<br/>)                        |  void   | 将指定的数值赋值给相同类型的数组中每个元素；<br/>同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）； |
| sort(<br/>Object[] a<br/>)                                   |  void   | 是单线程的，按自然顺序进行升序排列数组中的元素；<br/>同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）；<br/>适合对小数组进行排序； |
| parallelSort(<br/>T[] a<br/>)                                |  void   | 使用并行（使用ForkJoin池）的sort-merge（合并排序）算法；<br>将数组拆分成子数组，同时对子数组进行排序，然后合并；<br>适合对大型数组进行排序； |
| binarySearch(<br/>Object[] a, <br/>Object key<br/>)          |   int   | 用二分查找算法在给定数组中搜索给定值的对象；<br/>在查询前，数组必须是排序好且不会变化的；<br/>如果查找值包含在数组中，则返回搜索键的索引，否则返回-1；<br>同样的方法适用于所有的其他数据类型； |
| parallelPrefix(<br/>T[] array, <br/>BinaryOperator\<T> op<br/>) |  void   | 使用提供的功能，并行地计算给定阵列的每个元素；<br>// left代表数组中前一个索引处的元素，计算时第一个元素时left为1；<br/>// right代表数组中当前索引处的元素；<br>int[] arr = new int[]{3, -4 , 25, 16, 30, 18};<br>Arrays.parallelPrefix(arr, (left, right) -> left * right);<br>[3, -12, -300, -4800, -144000, -2592000] |
| toString(int[] a)                                            | String  | 返回字符串表示形式的数组                                     |



------



# 序列化（Serializable）

**序列化**： 是指将实例对象进行编码，并将编码后的数据持久化到存储介质（例如磁盘、网络、数据库等）的过程；

**反序列化**：是指读取储存介质（例如磁盘、网络、数据库等）中的序列化数据，并将序列化数据恢复成实例对象的过程；



## Serializable机制

当一个类实现了Serializable标记接口，表示该类及其子类的实例对象都支持序列化操作。

- 在 ObjectOutputStream 与 ObjectInputStream 类中实现序列化与反序列化；

- 会序列化对象中的实例变量与静态变量；

- 递归的将引用型变量的中的变量进行序列化，同样地这些变量中的引用变量也将被序列化；

- 不是所有的对象都可以被序列化，比如 Thread 类依赖系统资源的分配；

- 在序列化操作时，会忽略 transient 关键字修饰的变量；

- 在类中可以使用静态变量 serialVersionUID 来控制版本，反序列化时会检查版本号与类是否一致，不一致会抛出 InvalidClassException 异常；

  可根据类名、接口名、成员方法与变量生成一个64位的哈希值，或使用1L作为默认值（但不会执行类型检查）；

```java
public class User implements Serializable {
	private static final long serialVersionUID = 1318824539146791009L;
	private String userName;
	private transient String password;
	
	private static String GROUP;
	
	public User() {
		super();
	}
	
	public String getUserName() {
		return userName;
	}
	
	public void setUserName(String userName) {
		this.userName = userName;
	}
	
	public String getPassword() {
		return password;
	}
	
	public void setPassword(String password) {
		this.password = password;
	}
	
	@Override
	public String toString() {
		return "User [userName=" + userName + ", password=" + password + ", GROUP: " + GROUP + "]";
	}
	
	// JavaBean 序列化
	public static <T> byte[] serialize(T javaBean) throws Exception {
		ObjectOutputStream oos = null;
		ByteArrayOutputStream baos = null;
		try {
			baos = new ByteArrayOutputStream();
			oos = new ObjectOutputStream(baos);
			oos.writeObject(javaBean); // 写入对象
			oos.flush();
			return baos.toByteArray();
		} catch (Exception e) {
			throw new Exception("serialize异常", e);
		} finally {
			if (oos != null) {
				oos.close();
			}
		}
	}
	
	// JavaBean反序列化
	@SuppressWarnings("unchecked")
	public static <T> T deserialize(byte[] serializeData) throws Exception {
		T javaBean = null;
		ObjectInputStream ois = null;
		ByteArrayInputStream bais = null;
		try {
			bais = new ByteArrayInputStream(serializeData);
			ois = new ObjectInputStream(bais);
			javaBean = (T) ois.readObject();
			return javaBean;
		} catch (Exception e) {
			throw new Exception("deserialize异常", e);
		} finally {
			if (ois != null) {
				ois.close();
			}
		}
	}
	
	public static void main(String[] args) throws Exception {
		File file = new File(System.getProperty("user.dir"), "SerializableUserDemo.sle");
		
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
		User user1 = new User();
		user1.setUserName("user");
		user1.setPassword("UserPassword");
		User.GROUP = "GROUP";
		byte[] bytes = serialize(user1);
		oos.write(bytes);
		System.out.println(user1);
		System.out.println("-------序列化成功");
		oos.close();
		
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
		byte[] array = new byte[bytes.length];
		ois.read(array);
		User user2 = deserialize(array);
		System.out.println(user2);
		System.out.println("-------反序列化成功");
		ois.close();
	}
}
```



## Externalizable机制

一个类可通过实现 Externalizable 接口，来为对象提供序列化与反序列化操作，特征如下：

- Externalizable 接口继承了 Serializable 接口；
- Externalizable 接口序列化机制的优先级高于 Serializable 方式；
- 必须要提供一个 public 修饰的无参构造方法，否则在反序列化调用无参构造方法时，会抛出 InvalidClassException 异常；
- 在序列化方法 writeExternal() 与反序列化方法 readExternal() 中，实例变量的数量和顺序必须一致，否则会出现实例变量赋值错误问题；
- 对象中 transient 关键字自动失效，因为哪些实例变量要实现序列化取决于序列化方法中的具体实现；

```java
public class User implements Externalizable {
	private static final long serialVersionUID = 1318824539146791009L;
	private String userName;
	private transient String password;
	
	public User() {
		super();
	}
	
	public String getUserName() {
		return userName;
	}
	
	public void setUserName(String userName) {
		this.userName = userName;
	}
	
	public String getPassword() {
		return password;
	}
	
	public void setPassword(String password) {
		this.password = password;
	}
	
	@Override
	public String toString() {
		return "User [userName=" + userName + ", password=" + password + "]";
	}
	
	@Override
	public void writeExternal(ObjectOutput out) throws IOException {
		out.writeObject(this.userName);
		out.writeObject(this.password);
	}
	
	@Override
	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
		this.userName = (String) in.readObject();
		this.password = (String) in.readObject();
	}
	
	public static void main(String[] args) throws Exception {
		File file = new File(System.getProperty("user.dir"), "SerializableUserDemo.sle");
		
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
		User user1 = new User();
		user1.setUserName("user");
		user1.setPassword("UserPassword");
		oos.writeObject(user1);
		System.out.println(user1);
		System.out.println("-------序列化成功");
		oos.close();
		
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
		User user2 = (User) ois.readObject();
		System.out.println(user2);
		System.out.println("-------反序列化成功");
		ois.close();
	}
}
```



## 使用第三方API

- ApacheCommons 框架提供了序列化与反序列化工具，可将对象序列化为字节数组；
- Gson 框架提供了序列化与反序列化工具，可将对象序列化为 Json 字符串；
- Jackson 框架提供了序列化与反序列化工具，可将对象序列化为 Json 字符串；




------



# 拷贝（clone）

## 浅拷贝

浅拷贝只是拷贝了对象的地址，所以对象的值发生变化时，拷贝对象的值也会发生变化；



## **深拷贝**

因为深拷贝是要拷贝源对象中的所有值作为新的副本，所以当源对象中的值发生变化时，副本对象中的值也不会改变。有以下几种实现方式：

1. 构造方法方式

   ```java
   public class DeepCloneByConstruct {
   	private String address1;
   	private String address2;
   	
   	public DeepCloneByConstruct(String address1, String address2) {
   		this.address1 = address1;
   		this.address2 = address2;
   	}
   }
   ```

2. 重载clone()方法

   实现 Cloneable 标记接口表示支持深拷贝，并使用 public 修饰符重写 Object 类的 clone() 方法。

     ```java
   class Address implements Cloneable {
   	private String address1;
   	private String address2;
   	
   	public Address() {
   	}
   	
   	public String getAddress1() {
   		return address1;
   	}
   	
   	public void setAddress1(String address1) {
   		this.address1 = address1;
   	}
   	
   	public String getAddress2() {
   		return address2;
   	}
   	
   	public void setAddress2(String address2) {
   		this.address2 = address2;
   	}
   	
   	@Override
   	public Address clone() {
   		Address newobj = new Address();
   		newobj.setAddress1(this.address1);
   		newobj.setAddress2(this.address2);
   		return newobj;
   	}
   }
   
   public class DeepCloneByObjectclone implements Cloneable {
   	private String userName;
   	private Address address;
   	
   	public String getUserName() {
   		return userName;
   	}
   	
   	public void setUserName(String userName) {
   		this.userName = userName;
   	}
   	
   	public Address getAddress() {
   		return address;
   	}
   	
   	public void setAddress(Address address) {
   		this.address = address;
   	}
   	
   	@Override
   	public DeepCloneByObjectclone clone() {
   		// 注意 super.clone() 方法是浅拷贝；
   		DeepCloneByObjectclone newobj = new DeepCloneByObjectclone();
   		newobj.setAddress(this.address.clone());
   		newobj.setUserName(this.userName);
   		return newobj;
   	}
   }
     ```


  3. spring-core序列化方式

       使用 Spring 框架中的 SerializationUtils 工具类，可将一个实现了 Serializable 接口的对象，执行序列化与反序列化后可得到一个深拷贝的对象。
       
     ```xml
     <!-- 引入 Spring Core 依赖 -->
     <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-core</artifactId>
       <version>4.3.7.RELEASE</version>
     </dependency>
     ```
     
       ```java
     class Address1 implements Serializable {
     	private static final long serialVersionUID = 1L;
     	private String address1;
     	private String address2;
     	
     	public Address1(String address1, String address2) {
     		this.address1 = address1;
     		this.address2 = address2;
     	}
     	
     	public String getAddress1() {
     		return address1;
     	}
     	
     	public void setAddress1(String address1) {
     		this.address1 = address1;
     	}
     	
     	public String getAddress2() {
     		return address2;
     	}
     	
     	public void setAddress2(String address2) {
     		this.address2 = address2;
     	}
     }
     
     public class DeepCloneBySpring implements Serializable {
     	private static final long serialVersionUID = 1L;
     	private String userName;
     	private Address1 address;
     	
     	public DeepCloneBySpring() {
     	}
     	
     	public DeepCloneBySpring(String userName, Address1 address) {
     		this.userName = userName;
     		this.address = address;
     	}
     	
     	public String getUserName() {
     		return userName;
     	}
     	
     	public void setUserName(String userName) {
     		this.userName = userName;
     	}
     	
     	public Address1 getAddress() {
     		return address;
     	}
     	
     	public void setAddress(Address1 address) {
     		this.address = address;
     	}
     	
     	public static void main(String[] args) {
     		Address1 address = new Address1("小区1", "小区2");
     		DeepCloneBySpring user = new DeepCloneBySpring("小李", address);
     		DeepCloneBySpring copyUser = (DeepCloneBySpring) SerializationUtils.deserialize(SerializationUtils.serialize(user));
     		user.getAddress().setAddress1("小区3");
     		System.out.println(user == copyUser); // false
     		System.out.println(user.getAddress().getAddress1().equals(copyUser.getAddress().getAddress1())); // false
     	}
     }
       ```


  4. ApacheCommonsLang序列化方式

     使用 Apache 提供的 SerializationUtils 工具类，可将一个实现了 Serializable 接口的对象，执行序列化与反序列化后可得到一个深拷贝的对象。

       ```xml
     <!-- 引入 Apache Commons Lang 依赖 -->
     <dependency>
       <groupId>org.apache.commons</groupId>
       <artifactId>commons-lang3</artifactId>
       <version>3.10</version>
     </dependency>
       ```

       ```java
     class Address2 implements Serializable {
     	private static final long serialVersionUID = 1L;
     	private String address1;
     	private String address2;
     	
     	public Address2(String address1, String address2) {
     		this.address1 = address1;
     		this.address2 = address2;
     	}
     	
     	public String getAddress1() {
     		return address1;
     	}
     	
     	public void setAddress1(String address1) {
     		this.address1 = address1;
     	}
     	
     	public String getAddress2() {
     		return address2;
     	}
     	
     	public void setAddress2(String address2) {
     		this.address2 = address2;
     	}
     	
     }
     
     public class DeepCloneByApache implements Serializable {
     	private static final long serialVersionUID = 1L;
     	private String userName;
     	private Address2 address;
     	
     	public DeepCloneByApache() {
     	}
     	
     	public DeepCloneByApache(String userName, Address2 address) {
     		this.userName = userName;
     		this.address = address;
     	}
     	
     	public String getUserName() {
     		return userName;
     	}
     	
     	public void setUserName(String userName) {
     		this.userName = userName;
     	}
     	
     	public Address2 getAddress() {
     		return address;
     	}
     	
     	public void setAddress(Address2 address) {
     		this.address = address;
     	}
     	
     	public static void main(String[] args) {
     		AddressSerializable address = new AddressSerializable("小区1", "小区2");
     		SpringSerializable user = new SpringSerializable("小李", address);
     		SpringSerializable copyUser = (SpringSerializable) SerializationUtils.deserialize(SerializationUtils.serialize(user));
     		user.getAddress().setAddress1("小区3");
     		System.out.println(user == copyUser); // false
     		System.out.println(user.getAddress().getAddress1().equals(copyUser.getAddress().getAddress1())); // false
     	}
     }
       ```


  5. Gson序列化方式

     使用 Gson 框架，可将一个对象序列化为 Json 字符串，再将 Json 字符串反序列化就得到了一个深拷贝对象。

       ```xml
     <!-- 引入 Gson 依赖 -->
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.9</version>
     </dependency>
       ```

       ```java
     class Address4 {
     	private String address1;
     	private String address2;
     	
     	public Address4() {
     	}
     	
     	public Address4(String address1, String address2) {
     		this.address1 = address1;
     		this.address2 = address2;
     	}
     	
     	public String getAddress1() {
     		return address1;
     	}
     	
     	public void setAddress1(String address1) {
     		this.address1 = address1;
     	}
     	
     	public String getAddress2() {
     		return address2;
     	}
     	
     	public void setAddress2(String address2) {
     		this.address2 = address2;
     	}
     }
     
     public class DeepCloneByGson {
     	private String userName;
     	private Address4 address;
     	
     	public DeepCloneByGson() {
     	}
     	
     	public DeepCloneByGson(String userName, Address4 address) {
     		this.userName = userName;
     		this.address = address;
     	}
     	
     	public String getUserName() {
     		return userName;
     	}
     	
     	public void setUserName(String userName) {
     		this.userName = userName;
     	}
     	
     	public Address4 getAddress() {
     		return address;
     	}
     	
     	public void setAddress(Address4 address) {
     		this.address = address;
     	}
     	
     	public static void main(String[] args) {
     		Address4 address = new Address4("小区1", "小区2");
     		DeepCloneByGson user = new DeepCloneByGson("小李", address);
     		Gson gson = new Gson();
     		DeepCloneByGson newobj = gson.fromJson(gson.toJson(user), DeepCloneByGson.class); // 序列化与反序列化
     		user.getAddress().setAddress1("小区3");
     		System.out.println(user == newobj); // false
     		System.out.println(user.getAddress().getAddress1().equals(newobj.getAddress().getAddress1())); // false
     	}
     }
       ```


6. Jackson序列化方式

     使用 Jackson 框架，可将一个对象序列化为 Json 字符串，再将 Json 字符串反序列化就得到了一个深拷贝对象。

     但要求对象及其中的变量都需要有一个公开的无参构造方法。
     ```xml
     <!-- 引入 Jackson 依赖 -->
     <dependency>
         <groupId>com.fasterxml.jackson.core</groupId>
         <artifactId>jackson-databind</artifactId>
         <version>2.12.3</version>
     </dependency>
     ```

       ```java
     class AddressJackson {
     	private String address1;
     	private String address2;
     	
     	public AddressJackson() {
     	}
     	
     	public AddressJackson(String address1, String address2) {
     		this.address1 = address1;
     		this.address2 = address2;
     	}
     	
     	public String getAddress1() {
     		return address1;
     	}
     	
     	public void setAddress1(String address1) {
     		this.address1 = address1;
     	}
     	
     	public String getAddress2() {
     		return address2;
     	}
     	
     	public void setAddress2(String address2) {
     		this.address2 = address2;
     	}
     }
     
     public class UserJackson {
     	private String userName;
     	private AddressJackson address;
     	
     	public UserJackson() {
     	}
     	
     	public UserJackson(String userName, AddressJackson address) {
     		this.userName = userName;
     		this.address = address;
     	}
     	
     	public String getUserName() {
     		return userName;
     	}
     	
     	public void setUserName(String userName) {
     		this.userName = userName;
     	}
     	
     	public AddressJackson getAddress() {
     		return address;
     	}
     	
     	public void setAddress(AddressJackson address) {
     		this.address = address;
     	}
     	
     	public static void main(String[] args) throws JsonProcessingException {
     		AddressJackson address = new AddressJackson("小区1", "小区2");
     		UserJackson user = new UserJackson("小李", address);
     		ObjectMapper objectMapper = new ObjectMapper();
     		UserJackson copyUser = objectMapper.readValue(objectMapper.writeValueAsString(user), UserJackson.class);
     		user.getAddress().setAddress1("小区3");
     		System.out.println(user == copyUser); // false
     		System.out.println(user.getAddress().getAddress1().equals(copyUser.getAddress().getAddress1())); // false
     	}
     }
       ```

     深拷贝机制比较

     | 深拷贝方法        | 优点                                                         | 缺点                                                         |
     | :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
     | 构造方法方式      | 底层实现简单；<br>不需要引入第三方包；<br>系统开销小；<br/>不需要实现额外接口和方法； | 可用性差 <br/>每次新增成员变量都需要修改构造方法             |
     | 重载clone()方法   | 底层实现较简单 ；<br/>不需要引入第三方包；<br/>系统开销小；  | 可用性较差 <br/>每次新增成员变量可能需要修改clone()方法 <br/>需要实现Cloneable接口 |
     | ApacheCommonsLang | 可用性强；<br/>新增成员变量不需要修改拷贝方法；              | 底层实现较复杂  <br/>需要引入Apache Commons Lang包  <br/>需要实现Serializable接口  <br/>序列化与反序列化存在一定的系统开销 |
     | Gson序列化        | 可用性强；<br/>新增成员变量不需要修改拷贝方法；<br>不需要实现额外接口和方法； | 底层实现复杂  <br/>需要引入Gson包  <br/>序列化与反序列化存在一定的系统开销 |
     | Jackson序列化     | 可用性强；<br/>新增成员变量不需要修改拷贝方法；<br>不需要实现额外接口和方法； | 底层实现复杂  <br/>需要引入Jackson包  <br/>需要提供无参构造方法  <br/>序列化与反序列化存在一定的系统开销 |




------



# 代理（Proxy）

代理（Proxy）是一种设计模式，可通过代理对象调用目标对象中的方法；



## 正向代理



### 静态代理

编写代理类，在代理类实现目标类中的方法或继承目标类，在代理类的方法中实现代理操作逻辑；

```java
/**
 * 接口
 */
interface JavaStaticInterface {
	void execute();
}

/**
 * 接口实现
 */
class JavaStaticInterfaceImpl implements JavaStaticInterface {
	
	@Override
	public void execute() {
		System.out.println("execute() ..");
	}
}

/**
 * 静态代理类
 */
class JavaStaticProxy implements JavaStaticInterface {
	public JavaStaticInterface obj; // 被代理的对象
	
	public JavaStaticProxy(JavaStaticInterface factory) {
		this.obj = factory;
	}
	
	@Override
	public void execute() {
		System.out.println("before execute() ..");
		this.obj.execute();
		System.out.println("after execute() ..");
	}
}

public class JavaStaticProxyTest {
	
	public static void main(String[] args) {
		JavaStaticInterface obj = new JavaStaticInterfaceImpl();
		JavaStaticInterface proxy = new JavaStaticProxy(obj);
		proxy.execute();
	}
}
```



### 基于JDK接口动态代理

```java
/**
 * 接口
 */
interface JavaDynamicInterface {
	void execute();
}

/**
 * 接口实现类
 */
class JavaDynamicInterfaceImpl implements JavaDynamicInterface {
	
	@Override
	public void execute() {
		System.out.println("execute() ..");
	}
}

/**
 * JDK动态代理类
 */
class JavaDynamicInterfaceProxy<T> implements InvocationHandler {
	
	private T dest; // 目标对象
	
	public JavaDynamicInterfaceProxy(T dest) {
		this.dest = dest;
	}
	
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		System.out.println("before execute ..");
		Object o = method.invoke(this.dest, args); // 使用反射机制
		System.out.println("after execute ..");
		return o;
	}
	
	/**
	 * 创建一个代理对象
	 * 
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public T get() {
		return (T) java.lang.reflect.Proxy.newProxyInstance(this.dest.getClass().getClassLoader(), this.dest.getClass().getInterfaces(), this);
	}
}

public class JavaDynamicInterfaceProxyTest {
	
	public static void main(String[] args) {
		JavaDynamicInterface obj = new JavaDynamicInterfaceImpl();
		JavaDynamicInterface proxy = new JavaDynamicInterfaceProxy<JavaDynamicInterface>(obj).get();
		proxy.execute();
	}
}
```



### 基于CGLLIB的动态代理

CGLib 动态代理底层使用ASM框架，基于字节码技术生成代理类， 在java6之前比使用反射效率要高。唯一需要注意的是，CGLib 不能对声明为final 的方法进行代理， 因为 CGLib 原理是动态生成被代理类的子类。

在Java6、Java7、Java8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。

```xml
<!--CGLIB-->
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>
```

```java
/**
 * 目标类
 */
class CglibDynamicObject {
	
	public void execute(String msg) {
		System.out.println("execute " + msg);
	}
	
	public String call() {
		return "call() ..";
	}
}

/**
 * Cglib动态代理类
 */
class CglibDynamicProxy<T> implements MethodInterceptor {
	
	private T obj;
	
	public CglibDynamicProxy(T obj) {
		this.obj = obj;
	}
	
	@SuppressWarnings("unchecked")
	public T get() {
		Enhancer e = new Enhancer();
		e.setSuperclass(this.obj.getClass()); // 设置目标类
		e.setCallback(this); // 设置回调函数
		return (T) e.create(); // 创建代理对象
	}
	
	@Override
	public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
		if (method.getName().equals("execute")) {
			System.out.println("before execute() ..");
		}
		Object invoke = method.invoke(this.obj, objects);
		if (method.getName().equals("execute")) {
			System.out.println("after execute() ..");
		}
		return invoke;
	}
}

public class CglibDynamicProxyTest {
	
	public static void main(String[] args) {
		CglibDynamicObject obj = new CglibDynamicObject();
		CglibDynamicObject proxy = new CglibDynamicProxy<CglibDynamicObject>(obj).get();
		proxy.execute("test");
		System.out.println(proxy.call());
	}
}
```



#### Fastclass机制

CGLIB采用了FastClass的机制来实现对被拦截方法的调用，FastClass机制是指对类中的方法建立索引，通过索引来直接调用相应的方法。

例如：

```java
public class FastClassExample {
	public static void main(String[] args) {
		DestObject o = new DestObject();
		DestObjectProxy p = new DestObjectProxy();
		int index = p.getIndex("f()V");
		p.invoke(index, o, null);
	}
}

class DestObject { // 目标类
	
	public void f() {
		System.out.println("f method");
	}
	
	public void g() {
		System.out.println("g method");
	}
}

class DestObjectProxy { // 代理类
	
	public Object invoke(int index, Object o, Object[] ol) {
		DestObject t = (DestObject) o;
		switch (index) {
			case 1:
				t.f();
				return null;
			case 2:
				t.g();
				return null;
		}
		return null;
	}
	
	public int getIndex(String signature) { // 对 DestObject 类中的方法建立索引
		switch (signature.hashCode()) {
			case 3078479:
				return 1;
			case 3108270:
				return 2;
		}
		return -1;
	}
}
```

上例中，DestObjectProxy 是 DestObject 的 Fastclass，在 DestObjectProxy 中有两个方法 getIndex 和 invoke，在 getIndex 方法中对 DestObject 的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引值，在传入 Invoke 方法调用目标对象的方法。这样就避免了反射调用，提高了效率。



## 反向代理

反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的多个服务器，并将从服务器上得到的结果返回给 internet 上的服务器，此时代理服务器对外就表现为一个反向代理服务器，Ngnix就是一个典型的反向代理服务器。

<img src="./01.Java_part1.assets/JavaReverseProxy.jpeg" alt="img" />



------



# 流式计算



## Lambda表达式

也叫闭包，是Java8新特性，可以简化接口的实现代码，避免过多的匿名类，可以让代码简洁紧凑简洁；

- 语法格式

  ```java
  (parameters) -> expression[表达式]
  (parameters) -> statements[语句]
  (parameters) -> { statements; }
  ```

  必须要保证参数的数量和类型和接口中的方法保持⼀致，参数的类型省略不写：

  ```java
  Test test = (name, age) -> { return age + 1; };
  ```

  如果方法只有⼀个参数，则参数两边的小括号可以省略不写：

  ```java
  Test obj = name -> { System.out.println(name+"test"); };
  ```

  如果方法体只有⼀句代码，则方法体两边的⼤括号可以省略不写：

  ```java
  Test obj = name -> System.out.println(name + "test");
  ```

  如果方法体只有一个返回语句， 则在省略掉大括号的同时， 也必须省略掉**return**关键字：

  ```java
  Test obj = (a, b) -> a + b;
  ```

- 静态方法的引用

  语法格式：`类::静态方法`

  ```java
  public class TestLambdaStatic {
      public static void main(String[] args) {
          Calc c = Calculator::calculate; // 最后不要添加小括号
          System.out.println(c.test(4,5)); // 参数类型与数量要与 calculate 静态方法一致
      }
  }
  
  class Calculator {
      public static int calculate(int a, int b) {
          return a > b ? a - b : b - a;
      }
  }
  
  interface Calc {
  	int test(int a, int b);
  }
  ```

- 非静态方法的引用

  语法格式：`对象::非静态方法`

  ```java
  public class TestLambdaInstance {
  	public static void main(String[] args) {
  		Max obj = new CalMax()::calculate0;
  		System.out.println(obj.test(2, 3));
  	}
  }
  
  class CalMax {
  	public int calculate0(int a, int b) {
  		return a > b ? a - b : b - a;
  	}
  }
  
  interface Max {
  	int test(int a, int b);
  }
  ```

- 构造方法的引用

  语法格式：`类名::new`

  ```java
  public class TestLambdaInit {
  	private static class Person {
  		String name;
  		int age;
  		
  		public Person() { // 无参构造
  			System.out.println("一个Person对象通过无参构造被实例化了");
  		}
  		
  		public Person(String name, int age) { // 有参构造
  			System.out.println("一个Person对象通过有参构造被实例化了");
  			this.name = name;
  			this.age = age;
  		}
  	}
  	
  	@FunctionalInterface
  	private interface GetPerson {
  		Person test();
  	}
  	
  	@FunctionalInterface
  	private interface GetPersonWithParameter {
  		Person test(String name, int age);
  	}
  	
  	public static void main(String[] args) {
  		GetPerson lm = Person::new;
  		Person p1 = lm.test();
  		System.out.println("Person 名字：" + p1.name + ", 年龄：" + p1.age);
  		System.out.println();
  		
  		GetPersonWithParameter lm2 = Person::new;
  		Person p2 = lm2.test("测试人员", 2);
  		System.out.println("Person 名字：" + p2.name + ", 年龄：" + p2.age);
  	}
  }
  ```

- 使用案例

  1. 替代匿名内部类

     ```java
     @Test
     public void oldRunable() {
       new Thread(new Runnable() {
         @Override
         public void run() {
         	System.out.println("The old runable now is using!");
         }
       }).start();
     }
     ```

     使用lambda表达式可以简化：

     ```java
     @Test
     public void newRunable() {
     	new Thread(() -> System.out.println("It's a lambda function!")).start();
     }
     ```

  2. 遍历集合

     ```java
     @Test
     public void iterTest() {
         List<String> languages = Arrays.asList("java","scala","python");
         // before java8
         for(String each:languages) {
             System.out.println(each);
         }
     
         // after java8
         languages.forEach(x -> System.out.println(x));
         languages.forEach(System.out::println);
     }
     ```

  3. map操作

     map事项将一个对象变为另外一个；

     ```java
     @Test
     public void mapTest() {
         List<Double> cost = Arrays.asList(10.0, 20.0,30.0);
         cost.stream().map(x -> x + x*0.05).forEach(x -> System.out.println(x));
     }
     ```

     输出结果：

     ```shell
     10.5
     21.0
     31.5
     ```

  4. reduce操作

     reduce实现将所有值合并为一个；

     ```java
     @Test
     public void mapReduceTest() {
         List<Double> cost = Arrays.asList(10.0, 20.0,30.0);
         double allCost = cost.stream().map(x -> x+x*0.05).reduce((sum,x) -> sum + x).get();
         System.out.println(allCost);
     }
     ```

     输出结果：

     ```shell
     63.0
     ```

  5. filter操作

     可以从集合中过滤掉一部分元素；

     ```java
     @Test
     public void filterTest() {
         List<Double> cost = Arrays.asList(10.0, 20.0,30.0,40.0);
         List<Double> filteredCost = cost.stream().filter(x -> x > 25.0).collect(Collectors.toList());
         filteredCost.forEach(x -> System.out.println(x));
     }
     ```

     输出结果：

     ```shell
     30.0
     40.0
     ```

  6. 与函数式接口配合使用

     ```java
     public static void filterTest(List<String> languages, Predicate<String> condition) {
         languages.stream().filter(x -> condition.test(x)).forEach(x -> System.out.println(x + " "));
     }
     
     public static void main(String[] args) {
         List<String> languages = Arrays.asList("Java","Python","scala","Shell","R");
         System.out.println("Language starts with J: ");
         filterTest(languages,x -> x.startsWith("J"));
         
         System.out.println("\nLanguage ends with a: ");
         filterTest(languages,x -> x.endsWith("a"));
         
         System.out.println("\nAll languages: ");
         filterTest(languages,x -> true);
         
         System.out.println("\nNo languages: ");
         filterTest(languages,x -> false);
         
         System.out.println("\nLanguage length bigger three: ");
         filterTest(languages,x -> x.length() > 4);
     }
     ```

     输出结果：

     ```shell
     Language starts with J: 
     Java 
     
     Language ends with a: 
     Java 
     scala 
     
     All languages: 
     Java 
     Python 
     scala 
     Shell 
     R 
     
     No languages: 
     
     Language length bigger three: 
     Python 
     scala 
     Shell 
     
     ```




## 函数式接口

英文 Functional lnterface，是Java8新特性，增加了`java.util.function`包支持函数式编程，如下所示，指接口有且只有一个抽象方法，可以通过Lambda表达式创建该接口的对象。

```java
public interface Runnable {
    void run();
}
```

在接口名前使用**@FunctionalInterface**注解表示函数式接口；

```java
@FunctionalInterface
interface Test {
    void test();
}
```

| 函数式接口          | 方法名                             | 返回值  | 说明         |
| ------------------- | ---------------------------------- | ------- | ------------ |
| Runnable            | run()                              | void    |              |
| Function\<T, R>     | apply(T t)                         | \<R>    |              |
| BiFunction<T, U, R> | apply(T t, U u)                    | \<R>    |              |
| BinaryOperator\<T>  | apply(T t, T t1)                   | \<T>    |              |
| Consume\<T>         | accept(T t)                        | void    |              |
| Supplier\<T>        | get()                              | \<T>    |              |
| BiConsumer\<T, U>   | accept(T t, U u)                   | void    |              |
| Predicate\<T>       | test(T t)                          | boolean | 适用于做过滤 |
| BiPredicate<T, U>   | test(T t, U u)                     | boolean |              |
| LongBinaryOperator  | applyAsLong(long left, long right) | long    |              |



## Stream流式调用

流是从支持数据处理操作的源生成的元素序列；

1. 元素序列：就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值
2. 源：流会使用一个提供数据的源，如集合、数组或输入/输出资源；
3. 数据处理操作：流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等；
4. 流水线：很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线；
5. 内部迭代：与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的；

**流只能遍历一次**

**流使用内部迭代**

中间操作：代码中的filter、map、limit

终端操作：将流中的数据输出到终端上，





## Chain链式调用





------



# 内存模型（JMM）

全称 Java Memory Model，内存模型是一个约定规范，定义了虚拟机在内存中的工作方式，包含约定了线程和内存之间的抽象关系，如果要想全面掌握并发编程，就一定要先理解 JAVA 内存模型；

 

## 内存结构

线程之间的共享变量存储在主内存（main memory）中；

每个线程都有一个私有的本地内存（local memory）；

每个线程的本地内存中存储了该线程以读/写共享变量的副本；

线程对共享变量的所有操作都必须先在线程自己的工作内存中进行，之后再将结果回写到主内存中，不能直接从主内存中读写（不能越级）；

不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递香要通过主内存来进行（同级不能相互访问）；

Java定义了8种原子操作，用来控制主存与工作内存之间的交互：

|  原子操作  | 说明                                                         |
| :--------: | ------------------------------------------------------------ |
|  read读取  | 作用于主内存，将共享变量从主内存传送到线程的工作内存中       |
|  load载入  | 作用于线程工作内存，把read读取的值放到线程私有的工作内存中，作为一个副本变量 |
| store存储  | 作用于工作内存，把工作内存中的变量传送到主内存中             |
| write写入  | 作用于主内存，把从工作内存中 store 传送过来的值写到主内存的变量中 |
|  use使用   | 作用于工作内存，把工作内存的值传递给执行引擎，当虚拟机遇到一个需要使用这个变量的指令时，就会执行这个动作 |
| assign赋值 | 作用于工作内存，把执行引擎获取到的值赋值给工作内存中的变量，当虚拟机栈遇到给变量赋值的指令时，就执行此操作 |
|  lock锁定  | 作用于主内存，把变量标记为线程独占状态                       |
| unlock解锁 | 作用于主内存，它将释放独占状态                               |



## 三大特性

关键技术点都是围绕多线程的原子性、可见性和有序性展开的；

- 原子性

  一个或多个操作，要么全部执行，要么全部不执行（执行的过程中是不会被任何因素打断的）；

- 可见性

  只要有一个线程对共享变量的值做了修改，其他线程都将马上收到通知，立即获得最新值；

- 有序性

  **指令重排序现象**，包括编译器和处理器重排序，JMM会分别限制这两种指令重排序；

  **线程工作内存与主内存同步延迟现象**，同步指的是：

  - 线程解锁前，必须把共享变量的值刷新回主内存；

  - 线程加锁前，必须将主内存的最新值读取到自己的工作内存；

  - 加锁解锁是同一把锁；



## 指令重排

对于一个线程的执行代码而言，总是习惯性认为代码的执行总是从上到下，有序执行。为了提升性能，编译器和处理器通常会对指令序列进行重新排序；

但在虚拟机规范规定：只要保证程序的最终结果与顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，这个过程叫指令的重排序；

![截屏2022-12-14 02.23.53](./01.Java_part1.assets/JMMInstructionRearrangement.png)

例如：如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率；



### as-if-serial规则

不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义；

为程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题；



### happens-before规则

JSR-133 使用 happens-before 的概念来指定两个操作之间的执行顺序，具体的定义为：

- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前；

  例如：如果 A happens-before B，那么JMM将向程序员保证A操作的结果将对B可见，且A的执行顺序排在B之前；

- 两个操作之间存在happens-before关系，并不意味着虚拟机的具体实现必须要按照happens-before关系指定的顺序来执行；

  这是JMM对编译器和处理器重排序的约束原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序）编译器和处理器怎么优化都行；
  
  JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）；
  
  因此，happens-before关系本质上和as-if-serial语义是一回事；

**先行发生原则**

- 程序次序规则

  在一个线程中，按照代码的顺序，前面的操作Happens-Before于后面的任意操作；

- 锁定规则

  对一个锁的解锁操作 happens-before于后续对这个锁的加锁操作；

- volatile变量规则

  对一个volatile变量的写操作，Happens-Before于后续对这个变量的读操作；

  也就是说，对一个使用了volatile变量的写操作，先行发生于后面对这个变量的读操作。这个需要大家重点理解；

- 传递规则

  如果A Happens-Before B，并且B Happens-Before C，则A Happens-Before C；

- 线程启动规则（Thread Start Rule）

  如果线程A调用线程B的start()方法来启动线程B，则start()操作Happens-Before于线程B中的任意操作；

- 线程中断规则（Thread Interruption Rule）

  对线程interrupt()方法的调用Happens-Before于被中断线程的代码检测到中断事件的发生；

- 线程终止规则（Thread Termination Rule）

  线程A等待线程B完成（在线程A中调用线程B的join()方法实现），当线程B完成后（线程A调用线程B的join()方法返回），则线程A能够访问到线程B对共享变量的操作；

- 对象终结规则（Finalizer Rule）

  一个对象的初始化完成Happens-Before于其的finalize()方法的开始；




------



# 内存区域

也叫运行时数据区，指JVM运行时会将虚拟机管理的内存划分为若干个区域；

因为在操作系统内存架构中只划分了：寄存器（register）、缓存（cache）、主内存（RAM、Main Memory）；

根据《JAVA虚拟机规范》将虚拟机内存划分为：堆、虚拟机栈、方法区、程序计数器、本地方法栈，共五个部分；

![img](./01.Java_part1.assets/JavaMemoryArea.jpg)

![JavaMemoryArea](./01.Java_part1.assets/JavaMemoryArea.png)



## 堆（heap）

堆区是虚拟机中最大的内存区域，是被所有线程共享的，用于存放对象和数组，随虚拟机启动时创建，随虚拟机停止时销毁；

堆区实际的物理内存空间可以不连续的，但在逻辑上是连续的；

堆区的大小可以设置为固定大小或可扩展（通过参数`-Xmx`和`-Xms`设定）；

堆中内存耗尽且无法再扩展时，会抛出 OutOfMemoryError 异常；



### 分代划分算法

HotSpot虚拟机垃圾回收器采用分代收集算法，该算法根据对象不同的存活周期，将整个堆区划分为年轻代与老年代。



#### 年轻代（Young Generation）

也叫青年代，用来存放创建不久的对象，一般占据堆区内存空间的三分之一；

新生代又划分为 8 : 1 : 1 分别对应Eden区（伊甸园）、与二个存活区：From Survivor（幸存区0）与To Survivor（幸存区1）；

可通过虚拟机参数 `-XX:+UseAdaptiveSizePolicy` 启动/关闭动态控制策略（根据以往GC执行情况，动态调整Eden区与Survivor区的大小）；



#### 老年代（Old Generation）

英文 Tenured，老年代的空间一般比新生代大，能存放更多的对象，当老年代内存不足时，将执行 FullGC；

- 直接分配策略

  如果对象比较大（比如长字符串或大数组）导致新生代空间不足，则大对象会直接分配到老年代中；

  可通过虚拟机参数 `-XX:PretenureSizeThreshold` 设置直接分配到老年代对象大小的阀值，对象大于这个值时直接分配在老年代上；

- 卡标记技术（Card Marking）

  需求：老年代中对象引用了新生代对象时，每次 YGC 需要查询整个老年代来确认是否可以清理回收，这显然是低效的办法；

  卡页（Card Page）是指堆空间中一系列的 2^n^ 大小的空间，默认大小是 512 字节；

  卡表（Card Table）是一个字节数组，用于标记卡页的状态，数组中每个字节对应一个卡页；

  所有在老年代中引用新生代对象的记录都在卡页中，每次 YGC 时只要查卡页即可，不用再去查全部老年代，因此性能大大提高；



#### 相关参数

| **参数**                 | **说明**                                                |
| ------------------------ | ------------------------------------------------------- |
| -Xnoclassgc              | 关闭类信息的GC功能                                      |
| -XX:+TraceClassLoading   | 表示查看类的加载信息，可以在 Product版 HotSpot 中使用； |
| -XX:+TraceClassUnLoading | 表示查看类的卸载信息，需要 fastdebug 版 HotSpot 支持；  |
| -verbose:gc              | 表示输出虚拟机中GC的详细情况                            |



### 指针碰撞机制（bump-the-pointer）

是指在创建新对象时，可根据在伊甸园空间顶部对象的位置判断是否有足够空间分配给新对象，这种机制极大地提高了内存的分配速度；



### TLAB

全称 Thread Local Allocation Buffer，指JVM在堆区中为每个线程分配的专属内存空间，使线程都只在各自的TLAB中为对象分配内存；

可使用 TLAB 技术来解决分配堆内存的线程安全问题。

优点是可以避免因多线程竞争导致加锁带来的时间开销，再结合指针碰撞机制，达到了快速分配内存的目的；

TLAB包含三个指针，即start和end分别表示开始与结束位置，top用来判断TLAB是否已用满，如果已用满，就可以申请新的TLAB；

可使用 `-XX:+UseTLAB` 参数开启 TLAB（默认已开启）；

可使用 `-XX:+PrintTLAB` 参数打印 TLAB 的使用情况；

可使用 `-XX:TLABSize` 参数设置每个 TLAB 的大小；



### 逃逸分析

是指JIT编译器分析代码，判断对象的作用域，虚拟机会根据对象作用域做相应优化（栈上分配、锁消除等），包括：

- 全局变量赋值逃逸
- 方法返回值逃逸
- 实例引用发生逃逸
- 线程逃逸（如果对象可被一个以上的线程访问时，则属于逃逸对象）

```java
public class EscapeAnalysis {
 
     public static Object object;
      
     public void globalVariableEscape(){ // 全局变量赋值逃逸 
         object =new Object(); 
      } 
      
     public Object methodEscape(){  // 方法返回值逃逸
         return new Object();
     }
      
     public void instancePassEscape(){ // 实例引用发生逃逸
        this.speak(this);
     }
      
     public void speak(EscapeAnalysis escapeAnalysis) {
         System.out.println("Escape Hello");
     }
}
```



### 同步消除

也叫锁销除，开启了JIT编译优化，如果一个对象不会被多线程访问，那么针对这个对象的同步措施就可以省略掉。

例如 Vector这样的类，很多方法上都用了同步锁，当某个对象没有出现线程数逃逸时，JIT编译器会在编译这段代码时进行锁销除来提升效率。

可使用 `-XX:+EliminateLocks` 参数开启或关闭同步消除。



### 栈上分配

在开启了JIT的前提下，如果使用逃逸分析判断出对象没有出现逃逸，则使用标量替换，将对象分配在栈帧上。

优点是对象的内存空间可以随着方法栈帧一起销毁，节省了对这些对象的GC时间。

相关参数：

- 必须用JVM的`-server`运行模式（还有mix/client），可以开启JIT编译（才会开启逃逸分析）；
- 可使用`-XX:+DoEscapeAnalysis`参数开启（加号）或关闭（减号）逃逸分析，从Java7开始默认是打开的；
- 可使用`-XX:+EliminateAllocations`参数开启（加号）或关闭（减号）标量替换，默认是打开的；



### 标量替换

标量（Scalar）：指无法分解成更小粒度的数据，如基础数据类型。

聚合量（Aggregate）：指可以被分解成更小粒度的数据。

如果一个聚合量没有出现逃逸，那么虚拟机会将该聚合量分解成为多个成员变量，并在栈帧或寄存器上分配空间。

可使用`-XX:+PrintEliminateAllocations`参数查看标量替换情况（Server VM 非Product版本支持）。



## 方法区（Method Area）

别名是 Non-Heap（非堆），是所有线程共享的一块内存区域，随虚拟机启动创建，随虚拟机停止销毁；

方法区的实际的物理内存空间可以不连续的，但在逻辑上是连续的；

与方法区有关的概念：



### 类元信息

- Class信息

  类的全限定名（java/lang/Object）、父类全限定名、修饰符、版本号、实现接口的有序列表；

  如果是用户类加载器的，还保存用户类加载器的引用；

- 方法信息

  类中定义所有方法的方法表、方法名、方法的参数、返回值、异常表、局部变量区、操作数栈、修饰符等；

- 域信息

  变量名、变量类型、修饰符；

- 类变量

  类中定义的所有的静态变量；

- 常量

  被声明为final的类变量，都会被添加到常量池中；

- 常量池表（Constant Pool Table）

  每个class文件都有一个常量池表，用于存放编译时生成的各种字面量和符号引用（还有翻译出来的直接引用），如下图所示；

  - 字面量：文本字符串、基本数据类型的值、被**final**修饰的常量等；
  - 符号引用：类信息、方法的全限定名、字段名称、字段描述符、方法名称、方法描述符；

  ![img](./01.Java_part1.assets/1846149-20200402105747280-708488154.png)

- JIT编译器的代码缓存等数据；

- 运行时常量池（Runtime Constant Pool）

  类加载器装载某个类时，会将class文件中常量池的内容解析为字面量、直接引用，还可以动态向其中添加数据；

  如String类中的intern()方法可在运行期间向常量池中添加字符串常量；

  String.intern() 可以将字符串添加到常量池中，如果在常量池中已存在等值字符串，那么会返回常量池中的那个字符串引用，否则会在常量池中复制一份该字符串，并返回这个字符串。但JDK7及以后会直接在常量池中保存当前字符串的引用；如果使用new关键字创建字符串，则会强制String类在堆空间中创建一个新的String对象；

- 字符串常量池（String Constant Pool）

  在每个 HotSpotVM 中，只有一个字符串常量池对象（StringTable，是一个Hash表，默认容量是1009），被所有的类共享；

  - 在 JDK6 及之前版本，池中存放的都是字符串常量。但在JDK7中，可通过String#intern()方法添加堆区里的字符串对象的引用到池中；
  - 在 JDK7 中，可使用`-XX:StringTableSize=7777777	`参数来设置StringTable的容量；

方法区的实现有二种：

- 永久代（PermGen）

  永久代是 Java7及之前的HotSpot虚拟机对方法区概念的一个实现方式；

  因为永久代需要通过 `-XX:MaxPermSize` 参数来设置内存的上限值，如果设置小了会出现 OOM错误，所以在 Java8中被移除，取而代之的是元空间；

  - 在JDK6中，存储Class类信息、字符串常量池、静态变量等；
  - 在JDK7中，存储Class类信息，但字符串常量池和静态变量保存在堆区；
  - 使用`-XX:PermSize`来设置永久代的初始内存空间，默认值是20.75M；
  - 使用`-XX:MaxPermSize`来设定永久代最大可分配空间，32位机器默认是64M，64位机器默认是82M；
  - 使用`-XX:StringTableSize`来设置 StringTable 大小；

- 元空间（Metaspace）

  元空间是 Java8及之后的HotSpot虚拟机对方法区概念的一个实现方式，元空间不在虚拟机内存中，而是直接使用本机内存；

  优点是元空间使用本地内存不受虚拟机内存参数的限制，只受外部操作系统的内存容量的限制；

  元空间保存Class信息、字段、方法、常量，但字符串常量池和静态变量在堆区；
  
  - 使用 `-XX:MetaspaceSize` 来设置元空间的初始分配空间，默认值是21M；
  - 使用 `-XX:MaxMetaspaceSize` 来设置元空间的最大可分配空间，默认值是 -1 即没有限制；
  - 使用 `-XX:StringTableSize` 来设置 StringTable 大小；



## 虚拟机栈（VM Stack）

[虚拟机栈详解](https://www.cnblogs.com/liuyanntes/p/12616356.html)

JVM在创建线程的同时，也会创建一个对应的虚拟机栈（线程私有），与线程一同创建和销毁；

入栈：线程执行的每个方法都会在线程的虚拟机栈中创建对应的栈帧；

出栈：线程执行完方法后，栈帧也会出栈并释放内存空间；

如果线程请求的栈深度大于虚拟机所允许的深度，会抛出 StackOverflowError 异常；

如果虚拟机栈容量可以动态扩展，且扩展时无法申请到足够的内存，会抛出 OutOfMemoryError 异常；

可使用`-XX:ThreadStackSize`参数为每个线程设置栈大小（默认值在512k - 1024k之间），这个参数对性能影响比较大，需要严格的测试；

- 栈帧（Stack Frame）

  用于存储局部变量表，操作数栈，动态链表，方法返回地址等信息；

  - 局部变量表（Local Variable Table）

    也叫局部变量数组或本地变量表，是一个数组存放方法参数和局部变量；

    在编译期间就会确定局部变量表的容量大小，并保存在方法的Code属性的maximum local variables数据项中；

  - 操作数栈（Operand Stack）

    或表达式栈，用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间；

    - 当方法开始执行时，对应的栈帧也会随之被创建出来，这个方法的操作数栈是空的；
    - 操作数栈都会拥有明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值；
    - 栈中的任何一个元素都是可以任意的java数据类型，32bit的类型占用一个栈单位深度，64bit的类型占用两个栈深度单位；
    - 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问；
    - 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令；
    - 操作数栈中元素的类型必须与字节码匹配，编译器在编译期间进行验证，在类加载的验证阶段的数据流分析时要再次验证；
    - JAVA虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈；

  - 动态链接（Dynamic Linking）

    在编译JAVA源文件时，会将所有变量和方法引用都以符号引用的形式保存在class文件的常量池里。线程在执行方法时，方法对应的栈帧都有一个指向运行时常量池中，该栈帧所对应的类信息中方法的引用。在类加载的解析阶段会将符号引用转为直接引用；

    

    <img src="./01.Java_part1.assets/1846149-20200402110625116-1337433158.png" alt="img" style="zoom:67%;" />

  - 方法返回地址（Return Adress）

    有以下二种方式退出方法：

    - 方法返回指令

      也叫正常完成出口，解释引擎遇到一个方法返回的字节码指令，这时有可能会有返回值传递给上层的方法调用者；

      方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中会保存这个计数器值；

    - 异常退出

      也叫异常完成出口，在方法的执行过程中抛出了异常，会通过异常处理器表来确定返回地址，栈帧中一般不会保存这部分信息；

      ```java
      public void method2() {
        try {
          method1();
        } catch (I0Exception e) {
          e.printStackTrace();
        }
      }
      
      public void method1() throws IOException {
        FileReader fis = new FileReader("atguigu.txt");
        char(] cBuffer = new char(1024);
        int len;
        while ((len = fls.read (cBuffer))!=-1) {
          String str = new String (cBuffer, offset: 0, len);
          System.out.println(str);
        }
        fis.close();
      }
      ```

      下面是字节码中的异常处理表示例，下面的行号也是指字节码中的行号；

      ```class
      Exception table:
         from    to    target type
            4     8        11 Class java/io/IOException
      ```

      在字节码当中的4~8行是可能存在异常的代码，11代表字节码中的行号，也就是代码中的第5行；

  - 一些附加信息

    例如：对程序调试提供支持的信息；

    



## 本地方法栈（Native Method Stack）

虚拟机在创建线程时，会为每个线程分配一个线程私有的本地方法栈，与线程一同创建和销毁；

虚拟机调用native方法时，会在本地方法栈中创建一个对应的栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息等，方法执行完毕后相应的栈帧也会出栈并释放内存空间；

本地方法栈在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 异常；



## 程序计数器（Program Counter Register）

也叫寄存器，虚拟机在线程调度器切换线程上下文时，确保能恢复到正确的执行位置，为每个线程分配的私有的内存空间，与线程一同创建和销毁；

如果正在执行的是本地（Native）方法，该计数器值则为空(Undefined)；

因为该区域所占空间的大小不会发生改变，所以不会抛出OutOfMemoryError异常；



## 直接内存（Direct Memory）

直接内存并不是虚拟机运行时内存的一部分，是属于操作系统的内存。

在Java4中新引入了NIO类，是一种基于通道（Channel）与缓冲区（Buffer）的网络IO框架，NIO可以使用 native方法库直接分配堆外内存，然后通过一个存储在堆里面的DirectByteBuffer对象作为这块内存的引用进行操作与管理。这样能显著提高性能，因为省掉了在Java堆和native堆中来回复制数据的时间开销。当NIO的ByteBuffer调用allocateDirect方法时，会分配一块直接内存，此时会在操作系统划出一块缓冲区direct memory ，这块区域java代码可以直接访问，系统也可以使用；

直接内存也可能会抛出 OutOfMemoryError 异常；

可使用 `MaxDirectMemorySize` 参数设置直接内存的大小，如果未指定，默认与堆的最大值 `-Xmx` 参数值一致；



------



# 安全机制

![img](./01.Java_part1.assets/JavaSecurityManager_5.png)

Java安全机制的核心就是沙箱机制（sandbox），是指将 Java程序限定在虚拟机中特定的运行环境中，并严格限制程序对本地资源的访问（通过自定义安全策略实现），通过这样的措施来保证程序与外部资源的有效隔离，防止程序对本地系统造成破坏。

**Java安全机制历史：**

>在最初的JDK中将可执行程序分为本地代码和远程代码，默认信任本地代码，远程代码不受信任。使用沙箱机制来实现对远程代码的安全控制；
>
>后来发现如此严格的安全机制给程序扩展带来困难，因此后续JDK1.1中增加了安全策略，并允许用户代码访问本地资源；
>
>在Java1.2中增加了代码签名，不论本地代码还是远程代码，都会按照用户的安全策略，由类加载器加载代码到虚拟机中不同权限的空间中，以实现差异化的权限控制；
>
>在最新的安全机制中，引入了域（Domain）的概念，虚拟机会把代码加载到不同系统域和应用域中，系统域专门负责关键资源交互，而应用域可通过系统域的代理来访问所需资源。虚拟机中，不同的受保护域（Protected Domain），对应不一样的权限（Permission）；

**Java安全机制组件：**

1. 类加载器（ClassLoader）

2. 字节码校验器（BytecodeVerifier）
3. 安全管理器（SecurityManager）
4. 存取控制器（AccessController）
5. 安全软件包（SecruityPackage）



------



## 类加载器（ClassLoader）



### 显示与隐式加载

显式加载：是指通过代码设定，来加载类的过程。

例如：

```java
Class.forName(name);
this.getClass().getClassLoader().loadClass();
```

隐式加载：是指不直接在代码中调用ClassLoader的方法加载类，而由虚拟机自动加载类到内存中，比如使用 new关键字创建类。



### 类的命名空间

每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成，同一命名空间下的类是相互可见的。

在同一命名空间中，不会出现名字相同的两个类。

在不同的命名空间中，可能会出现名字相同的类。



### 类加载器种类



#### 启动类加载器

Bootstrap Class Loader，是顶级类加载器，由 C++ 编写是 JRE 的一部分，用于加载 `JAVA_HOME/jre/lib` 路径下的类库，也加载虚拟机参数 `-Xbootclasspath` 设定路径下的类库，启动类加载器只加载包名为 `java`、`javax`、`sun`等开头的类。

可使用虚拟机参数 `-xx:+TraceClassLoader` 查看类加载的详细流程。

扩展类加载器和应用类加载器都是被启动类加载器加载的。



#### 扩展类加载器

是指 ExtClassLoader类，用于加载环境变量 `%JAVA_HOME%/jre/lib/ext` 路径下的类库，也加载虚拟机参数 `java.ext.dirs` 设定路径下的类库，开发者可以直接使用扩展类加载器。



#### 应用类加载器

由 sun.misc.Launcher$AppClassLoader类实现，用于加载属性 `java.class.path` 指定路径下的类库，也就是加载环境变量 `CLASSPATH` 路径下的类库与虚拟机参数 `-classpath` 和 `-cp` 指定路径下的类库，开发者可以直接使用的类加载器，如果没有使用自定义类加载器，则应用类加载器就是默认类加载器。



#### 自定义类加载器

自定义的类加载器要继承 ClassLoader类，重写 findClass()方法来读取类的 class文件，可调用 defineClass重载方法将字节数组转为 Class 对象。

**ClassLoader类：**

| 方法                                                         | 返回值            | 说明                                                         |
| ------------------------------------------------------------ | ----------------- | ------------------------------------------------------------ |
| loadClass(<br/>String name<br/>)                             | Class             | 加载类的 Class 对象；<br/>是双亲委派机制的实现方法，会使用 findClass 方法查找类信息；<br/>name：全限定类名；<br/>返回参数类名对应的 Class 信息； |
| findClass(<br/>String name<br/>)                             | Class             | **需要重写**，如果不重写会抛出 ClassNotFoundException 异常；<br/>根据输入参数（全限定类名）加载对应的的 Class 信息；<br/>可以使用 defineClass 相关重载方法将字节数组转为字节码；<br/>name：全限定类名；<br/>返回参数类名对应的 Class 信息； |
| findResource(<br/>String name<br/>)                          | URL               | **可以重写**，以指定要查找的资源位置；<br/>查找资源名对应的资源URL对象；<br/>可以编写代码访问外部位置上的资源（图像、音频、文本等）；<br/>name：资源名，是以 / 字符分隔路径，用于标识资源；<br/>返回资源的URL对象，如果找不到资源，则返回 null |
| findResources(<br/>String name<br/>)                         | Enumeration\<URL> | **可以重写**，以指定要查找的资源位置；<br/>查找资源名对应的资源URL对象；<br/>可以编写代码访问外部位置上的资源（图像、音频、文本等）；<br/>name：资源名，是以 / 字符分隔路径，用于标识资源；<br/>返回资源的URL对象枚举 |
| defineClass(<br>String name, <br/>byte[] b, <br/>int off, <br/>int len<br/>) | Class             | **常用API**；<br/>将字节数组转为 Class 信息；<br/>name：类的预期二进制名称，如果未知，则为null；<br/>b：字节数组；<br/>off：字节在数组中的起始位置；<br/>len：字节在数组中的长度；<br/>返回字节转换后的 Class 信息； |
| defineClass(<br/>String name, <br/>byte[] b, <br/>int off, <br/>int len,<br/>ProtectionDomain protectionDomain<br/>) | Class             | **常用API**；<br/>将字节数组转为 Class 信息；<br/>name：类的预期二进制名称，如果未知，则为null；<br/>b：字节数组；<br/>off：字节在数组中的起始位置；<br/>len：字节在数组中的长度；<br/>protectionDomain：域信息；<br/>返回字节转换后的 Class 信息； |
| defineClass(<br/>String name, <br/>java.nio.ByteBuffer b,<br/>ProtectionDomain protectionDomain<br/>) | Class             | **常用API**；<br/>将字节数组转为 Class 信息；<br/>name：类的预期二进制名称，如果未知，则为null；<br/>b：字节数组；<br/>protectionDomain：域信息；<br/>返回字节转换后的 Class 信息； |
| resolveClass(<br/>Class<?> c<br/>)                           | void              | final关键字修饰的方法<br/>用来链接 Class 对象；<br/>如果类c已经被链接，则直接返回；<br/>否则，将按照类加载流程中的<a href="###类加载的流程">连接</a>执行； |
| findLoadedClass(<br/>String name<br/>)                       | Class<?>          | final关键字修饰的方法<br/>查找名称为name的已经被加载过的类；<br/>返回结果为 Class 对象； |
| getSystemResource(<br/>String name<br/>)                     | URL               | 静态方法；<br/>在加载类的搜索路径中查找指定名称的资源。<br/>name：资源名称；<br/>返回资源的URL对象，如果找不到资源，则返回 null |
| getSystemResources(<br/>String name<br/>)                    | Enumeration\<URL> | 静态方法；<br/>在加载类的搜索路径中查找指定名称的所有资源；<br/>name：资源名称；<br/>将所有找到的资源将作为URL对象的枚举返回； |
| getResource(<br/>String name<br/>)                           | URL               | 查找资源名称对应的资源URL对象；<br/>先在上级加载器中搜索资源；<br/>如果返回 null，会使用 findResource(String name) 方法来查找资源；<br/>name：资源名称，以 / 分隔的路径名，用于标识资源；<br/>返回资源的URL对象，如果找不到资源，则返回 null |
| getResources(<br/>String name<br/>)                          | Enumeration\<URL> | 查找资源名称对应的资源URL对象；<br/>先在上级加载器中搜索资源；<br/>如果返回 null，会使用 findResources(String name) 方法来查找资源；<br/>name：资源名称，以 / 分隔的路径名，用于标识资源；<br/>返回资源的URL对象枚举 |
| getResourceAsStream(<br/>String name<br/>)                   | InputStream       | 返回指定资源的输入流；<br/>先使用 getResource(String) 方法得到 URL 对象；<br/>然后再从 URL 对象上打开输入流；<br/>name：资源名称，以 / 分隔的路径名，用于标识资源； |
| getSystemResourceAsStream(<br/>String name<br/>)             | InputStream       | 静态方法；<br/>在加载类的搜索路径中查找指定名称的资源输入流；<br/>先使用 getSystemResource(String) 方法得到 URL 对象；<br/>然后再从 URL 对象上打开输入流；<br/>name：资源名称； |
| getParent()                                                  | ClassLoader       | 返回上级类加载器                                             |
| getSystemClassLoader()                                       | ClassLoader       | 静态方法；<br/>返回当前应用的系统类加载器；                  |
| setDefaultAssertionStatus(<br/>boolean enabled<br/>)         | void              | 设置该类加载器加载的类启用或禁用断言机制；<br/>enabled：true表示启用断言，false表示禁用断言； |
| setPackageAssertionStatus(<br/>String packageName,<br/>boolean enabled<br/>) | void              | 设置该类加载器加载指定包下的类启用或禁用断言机制；<br/>enabled：true表示启用断言，false表示禁用断言； |
| setClassAssertionStatus(<br/>String className, <br/>boolean enabled<br/>) | void              | 设置该类加载器加载指定类时启用或禁用断言机制；<br/>enabled：true表示启用断言，false表示禁用断言； |
| clearAssertionStatus()                                       | void              | 删除所有类和包的断言状态设置；<br/>禁用通过这个类加载器加载的所有类的断言； |

例如：

```java
public class TestClassLoader extends ClassLoader {
	
	private static String CLASS_NAME;
	private static File CLASS_FILE;
	
	static {
		try {
			buildClassFile();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) throws Exception {
		String name = TestClassLoader.class.getName() + "Pojo";
		System.out.println("类名：" + name);
		
		TestClassLoader cl = new TestClassLoader();
		Class<?> cls = cl.loadClass(name);
		Method method = cls.getMethod("println");
		Object obj = cls.newInstance();
		method.invoke(obj);
	}
	
	/**
	 * 编译源文件
	 * 
	 * @return 源文件编译后的字节码文件
	 * @throws IOException
	 */
	private static void buildClassFile() throws IOException {
		TestClassLoader.CLASS_NAME = "TestClassLoaderPojo"; // 类名
		String filepath = System.getProperty("java.io.tmpdir");
		File javafile = new File(filepath, TestClassLoader.CLASS_NAME + ".java");
		File classfile = new File(javafile.getParentFile(), TestClassLoader.CLASS_NAME + ".class");
		javafile.delete();
		classfile.delete();
		
		FileWriter fw = new FileWriter(javafile);
		fw.write("public class " + TestClassLoader.CLASS_NAME + " {public void println() {System.out.println(\"hello world!\");}}");
		fw.close();
		
		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
		int v = compiler.run(null, null, null, javafile.getAbsolutePath());
		if (v != 0 || !classfile.exists()) {
			throw new IOException(String.valueOf(v));
		} else {
			System.out.println("源文件 " + javafile.getAbsolutePath() + " 编译成功!");
			CLASS_FILE = classfile;
		}
	}
	
	@Override
	protected Class<?> findClass(String name) throws ClassNotFoundException {
		byte[] bytes = this.readBytes();
		return super.defineClass(TestClassLoader.CLASS_NAME, bytes, 0, bytes.length);
	}
	
	/**
	 * 读取 class 文件内容
	 * 
	 * @return
	 */
	private byte[] readBytes() {
		String filepath = CLASS_FILE.getAbsolutePath();
		System.out.println("字节码文件：" + filepath);
		try ( //
				InputStream in = new FileInputStream(CLASS_FILE); //
				ByteArrayOutputStream out = new ByteArrayOutputStream() //
		) {
			byte[] buf = new byte[4096];
			int len = 0;
			while ((len = in.read(buf)) != -1) {
				out.write(buf, 0, len);
			}
			return out.toByteArray();
		} catch (IOException e) {
			throw new RuntimeException(filepath, e);
		}
	}
}
```



##### URLClassLoader

是 java.net 包下的类，继承自 SecureClassLoader，在Java7中该类实现了Closeable接口，可以释放被类加载器打开的资源；

可加载的资源类型：

- 本地文件系统中的 class 文件；

- 本地文件系统中的 jar 文件；

- http链接上的 class 文件或 jar 文件；

例如：

```java
public class TestURLClassLoader {
	
	public static void main(String[] args) throws Exception {
		URL u0 = new URL("file://" + new File(System.getProperty("java.home"), "lib/rt.jar").getAbsolutePath());
		URL u1 = new URL("https://github.com/jeremy8551/TestJARURL/blob/main/db2java.jar");
		
		URLClassLoader ucl = new URLClassLoader(new URL[] { u0, u1 });
		Class<?> cls = Class.forName("com.ibm.db2.jcc.SQLJConnection", false, ucl);
		System.out.println(cls != null);
	}
}
```



##### 线程上下文类加载器

为了打破双亲委托机制，在Java2中推出了线程上下文类加载器，可用线程的 setContextClassLoader(ClassLoader cl) 方法设置某个线程单独使用的类加载器，如未设置的话，线程将默认使用其父线程中的上下文类加载器；

```java
public class TestClassLoader1 {
	
	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getContextClassLoader()); // 当前线程的线程上下文类加载器
	}
}
```



##### 系统类加载器

系统类加载器可通过 `ClassLoader.getSystemClassLoader()` 获得，且所有的 `ClassLoader.getSystemXXX()` 方法也是通过系统类加载器加载的；

URL协议处理器使用 `java.protocol.handler.pkgs`系统属性，并只使用系统类加载器；

```java
public class TestClassLoader2 {
	
	public static void main(String[] args) {
		System.out.println(ClassLoader.getSystemClassLoader()); // 打印系统的类加载器
	}
}
```



##### Class的类加载器

序列化API、`java.util.ResourceBundle`、`Class.forName(String)` 和 `Class.getResource(String)`方法使用的就是 Class类加载器；

```java
public class TestClassLoader3 {
	
	public static void main(String[] args) {
		System.out.println(TestClassLoader1.class.getClassLoader()); // Class的加载器
	}
}
```



### 选择类加载器

可以使用策略模式来设计类加载器的选择机制。



### 双亲委派模型

<img src="./01.Java_part1.assets/11.png" alt="11" style="zoom:50%;" />

类加载过程遵循双亲委派模型，是指当类加载器收到类加载请求时，会先委派给自己的上级类加载器执行加载操作，如果上级类加载器还有上级类加载器，则接着向上委托，每一层都是如此，一直递归到启动类加载器为止，当上级的加载器无法完成这个请求时，下级类加载器才会尝试去执行加载。

双亲委派机制可以防止 Java 核心 API 被随意篡改，也避免了类重复（即全限定类名的只加载一次）。

如果想要打破双亲委派模型，只要在自定义的类加载器中重写 loadClass() 方法中的类加载逻辑即可。

例如：

- Tomcat

  可以在 Tomcat中部署多个 WEB项目，为了保证每个 WEB项目互相独立，所以不能都由 AppClassLoader来加载。Tomcat容器自定义了一个类加载器WebappClassLoader继承自URLClassLoader，重写了 findClass() 和 loadClass()方法，打破了双亲委派模型；

- 热插拔

    因为双亲委派机制，导致类加载器对相同的类加载一次后，会直接使用内存中的这个 Class 对象。如果想要实现热插拔（hot swap），则必须在加载 Class的时候进行拦截，判断 class 文件是否有变化，如果发生了变化则重新加载这个 Class，如果没有变化则直接使用内存中已有的 Class。

    热加载：是指在容器启动时运行一个守护线程，定时检查 class 文件的时间戳变化，如果文件的时间戳更新了，就使类加载器重新载入该 class 文件；

    热部署：是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间；

- SPI

    双亲委派机制决定了SPI接口是由启动类加载器加载，SPI实现是由应用类加载器来加载，但启动类加载器无法找到SPI的实现类，可将应用类加载器设置为SPI线程默认的上下文类加载器，可解决这个问题；

- JDBC

    在 JDBC4.0以后，开始使用SPI机制注册JDBC驱动类，而SPI机制会打破双亲委派模型；

    在mysql的驱动包中 `META-INF/services/java.sql.Driver` 的文件中，已指明使用的驱动类名，就不再需要用 `Class.forName("com.mysql.cj.jdbc.Driver");` 加载驱动包了；

- JNDI

    JNDI使用SPI机制注册服务提供商，而SPI机制会打破双亲委派模型；

- JCE

    密钥工厂使用SPI机制选择不同的密钥工厂，而SPI机制会打破双亲委派模型；



### 类加载的流程

#### 加载（Loading）

根据全限定类名获取其类的二进制字节流，将二进制流中的静态结构，转化为方法区中的运行时数据结构，在堆中创建对应的 Class 对象，作为方法区类数据的访问入口；



#### 连接（Linking）

连接操作分为验证，准备，解析三个步骤：



##### 验证（Verification）

因为除了 Java编译器可以生成字节码以外，还可通过动态代理的方式生成字节码文件，所以对字节码的校验是非常有必要的；

使用字节码校验器（BytecodeVerifier）校验字节码是否符合《Java虚拟机规范》，如果未通过校验会抛出 java.lang.VerifyError 异常；

可以在[字节码校验器](##字节码校验器)中查看相关校验内容。

如果能保证字节码100%正确，则可使用虚拟机参数 `-Xverify:none` 来关闭大部分的验证措施；




##### 准备（Preparation）

为静态变量分配内存（非 final修饰的静态变量值成零值，final修饰的静态变量将会按定义赋值），不包括实例变量。



##### 解析（Resolution）

是指将常量池内的符号引用转换成直接引用的动作。

- 静态链接

  如果被调用的方法在编译期可知，且运行期保持不变。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接；

  早期绑定：是指被调用的目标方法如果在编译期可知，且运行期间保持不变，虚拟机将这个方法与所属的 Class 进行绑定；

- 动态链接

  如果被调用的方法在编译期无法被确定下来，只能在运行中将方法的符号引用转为直接引用，因为这个过程具有动态性，所以叫动态链接；

  后期绑定：也叫动态绑定，是指在编译期无法确定被调用的是哪个方法，只能在运行时根据实际情况才能确定要调用的方法；



#### 初始化（Initialization）

初始化类中非 final 修饰的静态变量、实例变量、按定义顺序执行多个 static{} 块、执行父类构造方法、子类构造方法等。



#### 使用（Using）

虚拟机在执行字节码的时候，还进行了一些内置的安全机制操作：

- 类型安全的引用转换；
- 结构化的内存访问（无指针算法）；
- 自动垃圾收集；
- 数组边界检查；
- 空引用检查；



#### 卸载（Unloading）

《Java虚拟机规范》中规定了一个 Class信息只有在满足下面三个条件的时候才会被卸载（即被GC回收）。

- Class 的所有实例都已经被GC；
- Class 实例没有在其他地方被引用（如：被反射机制使用）；
- Class 实例的类加载器已被GC；



------



## 代码源（CodeSource）

代码源，类加载器读取 class文件和 jar包，会得知谁为这个类签过名（可以有多个签名者，即被多个机构认证），且将所有的签名封装成一个签名数组，并将签名数组赋给新创建的CodeSource对象中的signers实例变量，将这个类的来源（URL）赋给CodeSource对象中的location实例变量，还有类中的公钥证书赋给CodeSource对象中的certs成员。

```java
public class CodeSource implements java.io.Serializable {
    private static final long serialVersionUID = 4977541819976013951L;
 
    // The code location.
    private URL location; // 本地代码库

    // The code signers.
    private transient CodeSigner[] signers = null; // 签名者
 
    // The code signers. Certificate chains are concatenated
    private transient java.security.cert.Certificate certs[] = null; // 证书
```



------



## 保护域（ProtectionDomain）

类加载器加载字节码后，会得到类或接口中的代码库和签名者。利用这些信息来创建一个CodeSource对象。将这个CodeSource对象作为参数传递给默认Policy对象的getPermissions(CodeSource codesource)方法，会得到PermissionCollection对象。使用这个CodeSource对象和PermissionCollection对象，实例化一个ProtectDomain对象。再把ProtectionDomain对象作为参数传给类加载器的**defineClass**()方法，表示将字节码放到一个保护域中。如下图所示

![1354914933_7854](./01.Java_part1.assets/JavaProtectionDomain.jpg)

注意：不是每个类加载器都有相应的保护域，Java核心类库的类加载器就没有指定保护域，可以理解为属于系统保护域；

```java
public class ProtectionDomain {
 
    /* CodeSource */
    private CodeSource codesource ; // 代码源
 
    /* ClassLoader the protection domain was consed from */
    private ClassLoader classloader; // 类装载器
  
    /* Principals running-as within this protection domain */
    private Principal[] principals;
 
    /* the rights this protection domain is granted */
    private PermissionCollection permissions; // 被授予的权限集合
```

| 方法                                                         | 返回值               | 说明                                                         |
| ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ |
| ProtectionDomain(<br/>CodeSource codesource,<br/>PermissionCollection permissions<br/>) | 无                   | 使用给定的CodeSource和权限创建一个新的ProtectionDomain<br>codesource：与此域相关codesource的代码源；<br/>permissions：授予此域的权限； |
| ProtectionDomain(<br/>CodeSource codesource,<br/>PermissionCollection permissions,<br/>ClassLoader classloader,<br/>Principal[] principals<br/>) | 无                   | 使用给定的CodeSource和权限创建一个新的ProtectionDomain<br/>codesource：与此域相关codesource的代码源；<br/>permissions：授予此域的权限；<br>classloader：与此域相关联的ClassLoader；<br/>principals：与此域相关联的主体数组，会复制数组的内容以防止后续修改； |
| getCodeSource()                                              | CodeSource           | 返回此域的CodeSource                                         |
| getClassLoader()                                             | ClassLoader          | 返回此域的ClassLoader                                        |
| getPrincipals()                                              | Principal[]          | 返回此域的主体数组                                           |
| getPermissions()                                             | PermissionCollection | 返回授予此域的静态权限                                       |
| implies(Permission permission)                               | boolean              | 判断当前ProtectionDomain中是否包含permission许可权限         |



------



## 字节码校验器

英文 BytecodeVerifier，当字节码文件加载到虚拟机时，首先要对字节码进行校验，确保其符合《Java虚拟机规范》，核心 API是不需要经过此校验的。

如果字节码已被反复使用和验证过，那么可以考虑使用虚拟机参数 `-Xverify:none` 来关闭字节码校验器，以缩短类加载时间。

>-Xverify[:\<option>]
>
>虚拟机默认是启用字节码校验器的，如单独使用选项而不带任何参数 `-Xverify`，那么将会忽略此选项
>
>可选选项如下：
>
>​	all - 启用最完整的验证
>
>​	none - 禁用验证器
>
>​	remote - 对远程装入的类启用严格的类装入检查

也可以使用非正式的指令钝化字节码校验器

```shell
java -noverify Hello
```



### class文件验证

class文件是否复合《Java虚拟机规范》，验证后，字节码信息才会进入运行时方法区；

* 验证 class文件是否以固定的四字节开始，即 class文件以 0xCAFEBABE 开始的；
* 根据 class文件中的主次版本号，来检查 Java虚拟机是否可以兼容运行这个 class 文件；
* 检查常量池中是否有不支持类型；
* 长度检查等；



### 元数据验证

是指对字节码描述的 Class 进行语义分析，确保其描述的信息符合《Java虚拟机规范》中的要求；
* 检查 Class 是否有父类；
* 父类是否集成了不允许继承的类；
* 父类是否实现了父类或接口中要求实现的所有方法；
* 类中的变量和父类是否有矛盾等；



### 字节码验证

是指通过分析数据流和控制流，确定程序的语义是正确的、符合逻辑的；
* 验证方法中的类型转换是否正确；
* 验证跳转指令不会跳转到方法体以外的字节码指令上；



### 符号引用验证

是指对 Class自身以外的各类信息进行匹配性校验，确保在连接的解析阶段可以正确的将符号引用转化为直接引用，如果未通过校验，则会抛出 IncompatibleClassChangeError异常或其子类，如：java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等；

- 符号引用中全限定类名字符串对应的 Class对象是否存在；
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段；
- 符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当前类访问等；



------



## 安全管理器

Java中的 SecurityManager类，字节码校验通过之后，会将 Class对象交给安全管理器执行。

SecurityManager是一个API级别的，可自定义的安全策略管理器，这是安全沙箱中，离我们程序员最接近的一环。



### 启用安全管理器

默认情况下，Java应用程序是不开启安全管理器的，可使用下面方式开启；

**参数式开启**

```shell
java -Djava.security.manager -Djava.security.policy=${HOME}/jre/lib/java.policy MyApp
```

**编程式开启**

```java
SecurityManager securityManager = new SecurityManager(); // 创建SecurityManager实例
System.setSecurityManager(securityManager); // 设置启动
```



### 关闭安全管理器

只有在默认的安全策略配置文件 **java.policy** 或自定义的配置文件中，配置了如下权限时才会生效；

```ini
permission java.lang.RuntimePermission "setSecurityManager"
```

例子：

```java
SecurityManager sm = System.getSecurityManager();
if(sm != null){
    System.setSecurityManager(null);
}
```



### 使用方式

SecurityManager类包含许多以check开头命名的方法，核心**API**库中执行敏感操作时，可以调用这些方法进行检查操作；

```java
SecurityManager security = System.getSecurityManager();
if (security != null) {
	security.checkXXX(argument);
}
```

| SecurityManager方法                 | 返回值      | 说明                                                         |
| ----------------------------------- | ----------- | ------------------------------------------------------------ |
| checkAccept(String, int)            | void        | 如果调用线程不允许从指定的主机和端口号接受套接字连接，则抛出一个SecurityException |
| checkAccess(Thread)                 | void        | 如果调用线程不允许修改线程参数，则抛出一个 SecurityException |
| checkAccess(ThreadGroup)            | void        | 如果调用线程不允许修改线程组参数，则抛出一个 SecurityException |
| checkAwtEventQueueAccess()          | void        | 已弃用                                                       |
| checkConnect(String, int)           | void        | 如果调用线程不允许打开与指定的主机和端口号的套接字连接，则抛出一个SecurityException |
| checkConnect(String, int, Object)   | void        | 如果指定的安全上下文不允许打开到指定的主机和端口号的套接字连接，则抛出SecurityException |
| checkCreateClassLoader()            | void        | 如果调用线程不允许创建新的类加载器，则抛出一个 SecurityException |
| checkDelete(String)                 | void        | 如果调用线程不允许删除指定的文件，则抛出一个 SecurityException |
| checkExec(String)                   | void        | 抛出 SecurityException如果调用线程不允许创建子进程           |
| checkExit(int)                      | void        | 如果不允许调用线程使Java虚拟机停止指定的状态代码，则抛出一个 SecurityException |
| checkLink(String)                   | void        | 如果调用线程不允许动态链接由字符串参数文件指定的库代码，则抛出一个 SecurityException |
| checkListen(int)                    | void        | 抛出 SecurityException如果调用线程不允许等待与指定的端口号的连接请求 |
| checkMemberAccess(Class<?>, int)    | void        | 已弃用                                                       |
| checkMulticast(InetAddress)         | void        | 抛出 SecurityException如果调用线程不允许使用（加入/离开/发送/接收）IP多播 |
| checkMulticast(InetAddress, byte)   | void        | 已弃用                                                       |
| checkPackageAccess(String)          | void        | 如果调用线程不允许访问由参数指定的包，则抛出一个 SecurityException |
| checkPackageDefinition(String)      | void        | 如果调用线程不允许在参数指定的包中定义类，则抛出一个 SecurityException |
| checkPermission(Permission)         | void        | 如果根据当前有效的安全策略不允许由给定权限指定的请求访问，则抛出SecurityException |
| checkPermission(Permission, Object) | void        | 抛出 SecurityException如果指定的安全上下文被拒绝访问由给定权限所指定的资源 |
| checkPrintJobAccess()               | void        | 如果调用线程不允许启动打印作业请求，抛出SecurityException    |
| checkPropertiesAccess()             | void        | 如果调用线程不允许访问或修改系统属性，抛出SecurityException  |
| checkPropertyAccess(String)         | void        | 如果调用线程不允许访问具有指定的 key名称的系统属性，抛出SecurityException |
| checkRead(FileDescriptor)           | void        | 抛出 SecurityException如果调用线程不允许从指定的文件进行读取 |
| checkRead(String)                   | void        | 如果调用线程不允许读取字符串参数指定的文件，抛出SecurityException |
| checkRead(String, Object)           | void        | 如果指定的安全上下文不允许读取由字符串参数指定的文件，抛出SecurityException |
| checkSecurityAccess(String)         | void        | 确定是否应授予或拒绝具有指定权限目标名称的权限               |
| checkSetFactory()                   | void        | 抛出 SecurityException如果调用线程不允许设置由使用的套接字工厂 ServerSocket或 Socket ，或使用的流处理程序工厂 URL |
| checkSystemClipboardAccess()        | void        | 已弃用                                                       |
| checkTopLevelWindow(Object)         | boolean     | 已弃用                                                       |
| checkWrite(FileDescriptor)          | void        | 如果调用线程不允许写入指定的文件描述符，抛出SecurityException |
| checkWrite(String)                  | void        | 如果调用线程不允许写入由字符串参数指定的文件，抛出SecurityException |
| getSecurityContext()                | Object      | 创建封装当前执行环境的对象                                   |
| getThreadGroup()                    | ThreadGroup | 返回要在其被调用时实例化任何正在创建的新线程的线程组         |



------



## 访问控制器

英文 AccessController，上一步是安全管理器，那么下一步就是访问控制器了。沙箱的所有 check 方法实现，都是基于 AccessController 的。

例如：

```java
public void checkRead(String file) {
    checkPermission(new FilePermission(file, SecurityConstants.FILE_READ_ACTION));
}
```

`SecurityManager.checkPermission()` 方法会调用 AccessController 里的方法。

```java
public void checkPermission(Permission perm) {
    java.security.AccessController.checkPermission(perm);
}
```

| AccessController方法                                         |        返回值        | 说明                                                         |
| ------------------------------------------------------------ | :------------------: | ------------------------------------------------------------ |
| checkPermission(<br/>Permission perm<br/>)                   |         void         | 根据**Policy**策略，判断是否有Permission的执行权限；<br>如果没有执行权限，会抛出AccessControlException； |
| doPrivileged(<br/>PrivilegedAction<T> action<br/>)           |          T           | 授权给程序，执行本来不具有的操作权限<br/>action：计算程序    |
| doPrivilegedWithCombiner(<br>PrivilegedAction<T> action<br/>) |          T           | 授权给程序，执行指定的PrivilegedAction；<br/>该操作在调用者保护域所拥有的全部权限下执行；<br/>使用当前AccessControlContext的DomainCombiner（可能为 null）<br/>action：计算程序 |
| doPrivileged(<br/>PrivilegedAction action,<br/>AccessControlContext context<br/>) |          T           | 授权给程序，执行指定的PrivilegedAction；<br/>该操作在调用者保护域所拥有的全部权限下执行；<br/>action：计算程序<br>context：访问控制上下文信息； |
| doPrivileged(<br/>PrivilegedAction action,<br/>AccessControlContext context,<br/>Permission... perms<br/>) |          T           | 授权给程序，执行指定的PrivilegedAction；<br/>该操作在调用者保护域所拥有的全部权限下执行；<br/>action：计算程序<br/>context：访问控制上下文信息；<br>perms：限制调用者的权限范围 |
| doPrivileged(<br/>PrivilegedExceptionAction<T> action<br/>)  |          T           | 授权给程序，执行本来不具有的操作权限<br/>action：计算程序，run方法有声明抛出异常 |
| doPrivileged(<br/>PrivilegedExceptionAction<T> action,<br/>AccessControlContext context<br/>) |          T           | 授权给程序，执行指定的PrivilegedAction；<br/>该操作在调用者保护域所拥有的全部权限下执行；<br/>action：计算程序，run方法有声明抛出异常<br/>context：访问控制上下文信息； |
| doPrivileged(<br/>PrivilegedExceptionAction<T> action,<br/>AccessControlContext context,<br/>Permission... perms<br/>) |          T           | 授权给程序，执行指定的PrivilegedAction；<br/>该操作在调用者保护域所拥有的全部权限下执行；<br/>action：计算程序，run方法有声明抛出异常<br/>context：访问控制上下文信息；<br/>perms：限制调用者的权限范围 |
| doPrivilegedWithCombiner(<br/>PrivilegedAction<T> action,<br/>AccessControlContext context,<br/>Permission... perms<br/>) |          T           |                                                              |
| doPrivilegedWithCombiner(<br/>PrivilegedExceptionAction<T> action<br/>) |          T           |                                                              |
| getContext()                                                 | AccessControlContext | 返回当前默认的访问控制上下文信息                             |

例子：

```ini
// 意思是 d:/test 下面的jar包或class类可以读取 /home/ 下的文件
grant codebase "file://d:/test"
{
    permission java.io.FilePermission "/home/*", "read";
};
```

```java
/**
 * AccessController 权限校验
 * 启动命令: 
 * -Djava.security.manager
 * -Djava.security.policy=acc.policy
 */
public class AccessMain {
    public static void main(String[] args) throws PrivilegedActionException {
        String filePath = "/user/touch-file.txt";
        boolean createFlag = AccessController.doPrivileged(new PrivilegedExceptionAction<Boolean>() {
            @Override
            public Boolean run() throws Exception {
                return touchFile(filePath); // 用特权方式创建文件
            }
        });
        System.out.println("create flag:" + createFlag);
    }

    private static boolean touchFile(String fileAbsolutePath) throws IOException {
        File touchFile = new File(fileAbsolutePath);
        return touchFile.createNewFile();
    }
}
```



------



## 密钥仓库（keystore）

密钥仓库：用来保存密钥对的（例如：公钥和私钥），每个**keystore**都有一个别名（不区分大小写）；

该文件中包含两种数据：

- 密钥实体（key entity）与密钥（sercet key），或者是**私钥**和**公钥**（采用非对称加密）；
- 可信任的证书实体（trusted certificate entities）：只包含**公钥**；

 创建密钥库：

```shell
# 选项 validity 可以指定签名有效日
keytool -genkey -keystore test.store -alias test -validity 55555
输入密码：1234567
```

例子：

```java
public class Main {
    public static void main(String[] args) throws Exception {
        byte[] message = "Hello, use X.509 cert!".getBytes("UTF-8");
        // 读取KeyStore:
        KeyStore ks = loadKeyStore("/my.keystore", "123456");
        // 读取私钥:
        PrivateKey privateKey = (PrivateKey) ks.getKey("mycert", "123456".toCharArray());
        // 读取证书: 公钥
        X509Certificate certificate = (X509Certificate) ks.getCertificate("mycert");
        // 加密:
        byte[] encrypted = encrypt(certificate, message);
        System.out.println(String.format("encrypted: %x", new BigInteger(1, encrypted)));
        // 解密:
        byte[] decrypted = decrypt(privateKey, encrypted);
        System.out.println("decrypted: " + new String(decrypted, "UTF-8"));
        // 签名:
        byte[] sign = sign(privateKey, certificate, message);
        System.out.println(String.format("signature: %x", new BigInteger(1, sign)));
        // 验证签名:
        boolean verified = verify(certificate, message, sign);
        System.out.println("verify: " + verified);
    }

    static KeyStore loadKeyStore(String keyStoreFile, String password) {
        try (InputStream input = Main.class.getResourceAsStream(keyStoreFile)) {
            if (input == null) {
                throw new RuntimeException("file not found in classpath: " + keyStoreFile);
            }
            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
            ks.load(input, password.toCharArray());
            return ks;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    static byte[] encrypt(X509Certificate certificate, byte[] message) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());
        return cipher.doFinal(message);
    }

    static byte[] decrypt(PrivateKey privateKey, byte[] data) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return cipher.doFinal(data);
    }

    static byte[] sign(PrivateKey privateKey, X509Certificate certificate, byte[] message) throws GeneralSecurityException {
        Signature signature = Signature.getInstance(certificate.getSigAlgName());
        signature.initSign(privateKey);
        signature.update(message);
        return signature.sign();
    }

    static boolean verify(X509Certificate certificate, byte[] message, byte[] sig) throws GeneralSecurityException {
        Signature signature = Signature.getInstance(certificate.getSigAlgName());
        signature.initVerify(certificate);
        signature.update(message);
        return signature.verify(sig);
    }
}
```

上面代码，从密钥仓库中直接读取了私钥-公钥对，私钥以 `PrivateKey` 实例表示，公钥以 `X509Certificate` 表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。



------



## JAR签名

可以防止他人篡改被签名的jar包

步骤：

1. 生成jar包

   ```shell
   $ jar cvf test.jar test.class
   ```

2. 生成密钥库

   ```shell
   $ keytool -genkey -keystore test.store -alias test -validity 55555
   ```

   输入密码：1234567

   选项 validity 可以指定签名有效日。

3. 提取数字证书

   ```shell
   $ keytool -export -keystore test.store -alias test -file test.cer
   ```

   输入密码：1234567

4. 对jar文件签名

   ```shell
   $ jarsigner -keystore test.store test.jar test
   ```
   
   输入密码：1234567
   
   签名以后在 `META-INF `文件夹下会多出两个文件：
   
   - XXX.SF文件
   
     XXX应该与签名时使用密钥的别名一致；
   
     XXX.SF文件包含的内容例如：
   
     ```ini
     Manifest-Version: 1.0
     Created-By: 1.3.0_02 (Sun Microsystems Inc.)
     Name: a/b/c1.class
     SHA1-Digest: fcav7ShIG6i86xPepmitOVo4vWY=
     Name: a/b/c2.class
     SHA1-Digest: kdHbE7kL9ZHLgK7akHttYV4XIa0=
     ```
   
     其中 `a/b/c1.class` 的 SHA1-Digest 值指的是 c1.class 的 SHA1 内容摘要；
   
   - XXX.YYY文件
   
     扩展名 YYY，根据数字签名的类型RSA、DSA、PGP以及用于签名jar的证书类型而有不同的扩展名；
   
     XXX.YYY 是二进制签名文件，其包含签名的证书链以及公共密钥；



### jarsigner

可以为jar文件产生签名，也可以校验已签名的Jar文件的签名和完整性。

<a href="https://blog.csdn.net/yangxt/article/details/1796965">jarsigner使用教程</a>



### keytool

数据证书管理工具，用于生成密钥文件keystore，keytool将密钥(key)和证书(certificates)存在keystore文件中；

```shell
 -certreq            生成证书请求
 -changealias        更改条目的别名
 -delete             删除条目
 -exportcert         导出证书
 -genkeypair         生成密钥对
 -genseckey          生成密钥
 -gencert            根据证书请求生成证书
 -importcert         导入证书或证书链
 -importpass         导入口令
 -importkeystore     从其他密钥库导入一个或所有条目
 -keypasswd          更改条目的密钥口令
 -list               列出密钥库中的条目
 -printcert          打印证书内容
 -printcertreq       打印证书请求的内容
 -printcrl           打印 CRL 文件的内容
 -storepasswd        更改密钥库的存储口令

使用 "keytool -?, -h, or --help" 可输出此帮助消息
使用 "keytool -command_name --help" 可获取 command_name 的用法。
使用 -conf <url> 选项可指定预配置的选项文件；
```



------



## 数字证书

摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并形成一套完善的标准，这就是数字证书；

数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准，只包含公钥；

数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的；

正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书；



------



## 安全策略（Policy）

[官方参考文档](https://docs.oracle.com/javase/7/docs/technotes/guides/security/spec/security-spec.doc3.html)

[JAVA策略文件简介](https://blog.csdn.net/hudashi/article/details/7069764)

安全策略负责检查虚拟机中程序是否具有执行操作或资源的权限，安全策略的实现就是Policy类；

Policy是抽象类，默认实现类是sun.security.provider.PolicyFile，即策略信息配置在文件中；

如果要实现从数据库中读取策略信息，可自定义实现Policy抽象类，然后通过安全属性文件中的`policy.provider`属性，修改为自定义的Policy类；

| Policy方法                                                   | 返回值               | 说明                                                         |
| ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ |
| Policy.setPolicy(Policy p)                                   | void                 | 设置全局策略                                                 |
| Policy.getPolicy()                                           | Policy               | 返回已安装的Policy对象<br>返回值不能为null                   |
| getInstance(<br/>String type, <br/>Policy.Parameters params) | Policy               | 返回指定类型的Policy对象<br>type：策略类型；<br/>params：策略需要的参数信息；<br/>使用SPI机制管理多个Policy对象 |
| getInstance(<br/>String type, <br/>Policy.Parameters params, <br/>Provider provider) | Policy               | 返回指定类型的Policy对象<br/>type：策略类型；<br/>params：策略需要的参数信息；<br/>provider：策略供应商信息；<br/>使用SPI机制管理多个Policy对象 |
| getInstance(<br/>String type, <br/>Policy.Parameters params, <br/>String provider) | Policy               | 返回指定类型的Policy对象<br/>type：策略类型；<br/>params：策略需要的参数信息；<br/>provider：策略供应商名；<br/>使用SPI机制管理多个Policy对象 |
| getParameters()                                              | Policy.Parameters    | 返回策略使用的参数<br>只有通过**<u>Policy.getInstance</u>**方法得到的Policy实例才有值<br/>否则此方法返回 null |
| getPermissions(CodeSource codesource)                        | PermissionCollection | 返回一个 PermissionCollection 对象<br/>包含授予指定 CodeSource 的权限集 |
| getPermissions(ProtectionDomain domain)                      | PermissionCollection | 返回一个 PermissionCollection 对象<br/>包含授予指定 ProtectionDomain 的权限集 |
| getProvider()                                                | Provider             | 返回此策略的供应商信息                                       |
| getType()                                                    | String               | 返回此 Policy 的类型<br>只有通过**<u>Policy.getInstance</u>**方法得到的Policy实例才有值<br/>否则此方法返回 null |
| implies(<br/>ProtectionDomain domain, <br/>Permission permission) | boolean              | 判断 ProtectionDomain 全局策略中，是否包含许可参数<br>domain：<br/>permission：表示权限许可 |
| refresh()                                                    | void                 | 刷新/重新加载策略配置                                        |



### 安全属性文件

安全属性文件的位置：`${JAVA_HOME}/jre/lib/security/java.security`

可以通过JVM参数添加安全属性文件，即除了加载默认的安全属性文件，还会加载JVM参数指定的安全属性文件：

```ini
java -Djava.security.manager -Djava.security.properties=安全属性文件URL SomeApp
```

使用双等号设置安全属性文件表示：忽略默认的安全属性文件，仅用JVM参数指定的安全属性文件：

```ini
java -Djava.security.manager -Djava.security.properties==安全属性文件URL SomeApp
```

| 属性名                          | 值                                                           | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| policy.provider                 | sun.security.provider.PolicyFile                             | 设置默认Policy的实现类<br>想从数据库中取策略配置信息，可以自定义Policy实现类<br>然后将实现Policy类配置到这个属性； |
| policy.url.1                    | file:${java.home}/lib/security/java.policy                   | 默认策略文件绝对路径；<br>可以使用JVM属性替换占位符；<br>可以使用**http://**的url<br/>注意属性名中的数字必须连续才能生效 |
| policy.url.2                    | file:${user.home}/.java.policy                               | 用户自定义策略文件绝对路径；<br/>可以使用JVM属性替换占位符；<br/>可以使用**http://**的**URL**<br/>注意属性名中的数字必须连续才能生效 |
| policy.expandProperties         | true                                                         | 是否开启策略文件中的**属性扩展**功能；<br/>true表示打开；<br/>false表示关闭； |
| policy.allowSystemProperty      | true                                                         | true表示自动忽略通过虚拟机参数设定的策略文件                 |
| policy.ignoreIdentityScope      | false                                                        | 无论我们是否查看受信任标识的IdentityScope<br/>当遇到1.1签名的JAR文件时。如果找到身份<br/>并且是可信的，我们授予它AllPermission。 |
| keystore.type                   | jks                                                          | keystore默认类型                                             |
| keystore.type.compat            | true                                                         | true表示启动密钥库兼容模式；<br/>此模式使得**JKS**密钥库可以访问**JKS**和**PKCS12**文件格式； |
| crypto.policy                   | unlimited                                                    | unlimited表示启用无限强度策略文件<br>limited表示有限的（默认值）； |
| security.overridePropertiesFile | true                                                         | true表示允许您加载通过系统属性命名的其他安全属性文件<br>-Djava.security.properties= |
| security.provider.n             | sun.security.provider.Sun<br>sun.security.rsa.SunRsaSign<br/>... | 用于设置安全算法的供应商信息                                 |



### 策略文件

策略文件（ASCII码）默认位置是：`${JAVA_HOME}/jre/lib/security/java.policy`

- 虚拟机参数

  安全策略是依赖于安全管理器的，所以要用虚拟机参数 `-Djava.security.manager` 启动默认的安全管理器，或可在应用程序中安装一个安全管理器；

  可以通过JVM参数添加策略文件，即除了加载安全属性文件中设定的所有策略文件，还会加载JVM参数指定的策略文件：

  ```ini
  java -Djava.security.manager -Djava.security.policy=策略文件URL SomeApp
  ```

  使用双等号设置策略文件表示：忽略安全属性文件中的策略文件，仅用虚拟机参数指定的策略文件：

  ```ini
  java -Djava.security.manager -Djava.security.policy==策略文件URL SomeApp
  ```

  注意安全属性文件中`policy.allowSystemProperty=false`表示忽略虚拟机参数设置的策略文件；

- 属性扩展（PropertyExpansion）

  策略文件中 `${xxx.xxx}` 的字符串，可自动扩展为JVM属性值，但不能嵌套属性。

  策略文件中允许使用双引号字符串的地方都可进行属性扩展，包括 signer_names、URL、target_name、action 域。

  属性扩展时，如果属性foo不存在，则表示属性扩展所在的整个域都失效，即`grant codeBase "${foo}" {permission ...;}`整体失效。

  属性扩展功能的开启，是由安全属性文件中的`policy.expandProperties`控制，默认是允许的。

  属性扩展中平台无关的文件路径分隔符是`${/}`是`${file.separator}`的简化表示，`${user.home}${/}foo.bat`。

  属性扩展支持`${{self}}`与`${{alias:*alias_name*}}`格式？？详见：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/spec/security-spec.doc3.html">官方文档</a>

  ```ini
  permission java.io.FilePermission "＄{user.home}", "read";
  ```

- 通配符

  策略文件中关于资源位置的域（如：URL等），在这些域中可使用如下通配符：

  | 通配符                               | 说明                                                         |
  | ------------------------------------ | ------------------------------------------------------------ |
  | ${directory}/<br/>或<br/>{directory} | ${directory}表示使用JVM属性替换；<br>匹配指定目录下的所有类文件（ 非 JAR 文件 ） |
  | ${directory}/*                       | 匹配该目录下的所有文件（类文件和 JAR 文件）                  |
  | ${directory}/-                       | 匹配该目录下的所有文件（类文件和 JAR 文件）及其子目录下的所有文件 |
  | *                                    | 指当前目录下的所有文件（类文件和 JAR 文件）                  |
  | -                                    | 指当前目录下的所有文件（类文件和 JAR 文件）及其子目录        |
  | \<\<ALL FILES>>                      | 文件系统中的所有文件                                         |

- 文件格式

  ```ini
  keystore "some_keystore_url", "keystore_type";
  
  grant [SignedBy "signer_names"] [, CodeBase "URL"]
        [, Principal [principal_class_name] "principal_name"]
        [, Principal [principal_class_name] "principal_name"] ... {
      permission permission_class_name [ "target_name" ] [, "action"] [, SignedBy "signer_names"];
      permission ...
  };
  ```

- keystore

  密钥仓库，用于储存密钥、签名、证书信息，可以使用数据证书管理工具**keytool**来创建；

  - **some_keystore_url**

    表示**密钥仓库**的**URL**位置，**URL**是相对于**策略文件**位置而言的；

    如果**安全属性文件**中指定了策略文件：`policy.url.1=http://foo.bar.com/fum/some.policy`；

    则当策略文件配置了：`keystore "robin.keystore"`，即表示**URL**是：http://foo.bar.com/fum/robin.keystore；

    在URL中可以使用**通配符**与**属性扩展**；

  - **keystore_type**

    表示**密钥仓库**的类型，非必填项，未设置时，默认用**安全属性文件**中的`keystore.type=jks`值作为默认值；

- grant

  授权项；

  - SignedBy

    表示签名者，即keystore中密钥的别名，是非必填项；

    如果未使用签名者，则表示任何签名人，代码的权限与是否有签名或由谁签名都没有关系了；

    如果设置了签名者，则必须要在keystore中存在对应的密钥；

    可以使用逗号分隔多个密钥别名，关系是AND（与）而不是OR（或）的关系，例如`Adam,Eve,Charles`；

    公钥用于验证代码上的数字签名；

  - codeBase

    表示策略对应的代码位置，非必填项；

    如果省略该域，则表示代码的权限与代码来源于何处没有任何关系；

    因为值是一个URL，所以可使用通配符与属性扩展描述路径，要用正斜杠（不要用反斜杠）作为目录分隔符；

    例如`codeBase "file:/C:/somepath/api/"` 或`file:${{java.ext.dirs}}/*`

  - principal

    表示用户主体，是非必填项，如果未使用这个域，则表示任何主体都可以；

    对应Principal接口，表示委托人的抽象概念，可用于表示任何实体，例如：个人、公司与登录ID；

    - principal_class_name

      实现Principal接口类的全限定名；

    - principal_name

      主体类生成实例的名字；

      如果class_name/principal_name对由一个单独的引号括起来的字符串，那么表示是一个keystore的别名，将通过这个别名查询keystore以获取X509证书。如果找到，则principal_class_name被设置为javax.security.auth.x500.X500Principal，而principal_name被自动的设为证书中Subject的别名，如果没有找到证书的映射，则此grant条目自动被忽略；

    主体结构要求配置一个**与**主体名，且该对信息必须存在于正在执行线程主体集中。主体集通过Subject与正在执行的代码相关联；

    如下所示，表示允许任何有特征 `X500Principal, "cn=Alice"` 的客户代码读写 `/home/Alice` 下的文件；

    ```ini
    grant principal javax.security.auth.x500.X500Principal "cn=Alice" {
          permission java.io.FilePermission "/home/Alice", "read, write";
    };
    ```

  - permission

    表示许可项；

    注意target_name和action域值是作为许可类的构造方法参数，如果许可类中没有用到这些值，则target_name和action域就是非必填项；

    | permission_class_name                               | target_name  | action                             |
    | --------------------------------------------------- | ------------ | ---------------------------------- |
    | java.security.AllPermission                         | 无           | 无                                 |
    | java.io.FilePermission                              | 文件绝对路径 | read,write,delete,execute,readlink |
    | java.lang.RuntimePermission                         | 无           | 无                                 |
    | java.net.SocketPermission                           | host         | listen,accept,connect,resolve      |
    | javax.management.MBeanPermission                    |              |                                    |
    | javax.management.MBeanTrustPermission               |              |                                    |
    | javax.security.auth.PrivateCredentialPermission     |              |                                    |
    | javax.security.auth.kerberos.ServicePermission      |              |                                    |
    | java.security.UnresolvedPermission                  |              |                                    |
    | java.net.URLPermission                              | URI          | 无或 *:*                           |
    | javax.security.auth.AuthPermission                  |              |                                    |
    | java.awt.AWTPermission                              |              |                                    |
    | javax.xml.bind.JAXBPermission                       |              |                                    |
    | java.nio.file.LinkPermission                        |              |                                    |
    | java.util.logging.LoggingPermission                 |              |                                    |
    | java.lang.management.ManagementPermission           |              |                                    |
    | java.net.NetPermission                              |              |                                    |
    | jdk.net.NetworkPermission                           |              |                                    |
    | java.util.PropertyPermission                        |              |                                    |
    | java.lang.reflect.ReflectPermission                 |              |                                    |
    | java.lang.RuntimePermission                         |              |                                    |
    | java.security.SecurityPermission                    |              |                                    |
    | java.io.SerializablePermission                      |              |                                    |
    | java.sql.SQLPermission                              |              |                                    |
    | javax.net.ssl.SSLPermission                         |              |                                    |
    | javax.management.remote.SubjectDelegationPermission |              |                                    |
    | javax.xml.ws.WebServicePermission                   |              |                                    |
    | javax.smartcardio.CardPermission                    |              |                                    |
    | javax.sound.sampled.AudioPermission                 |              |                                    |

    - permission_class_name

      许可类的全限定名，是必填项；

    - target_name

      资源信息，可以是文件、字符串等，可以使用通配符；

    - action

      表示许可的权限；

    - signedBy

      表示这是一个签名许可，为非必填项；

      表示许可类必须是由signedBy所签名的，许可类是系统类则不受此限制；




### 自定义策略文件

例如：

```ini
grant {
//对系统和用户目录“读”的权限
permission java.util.PropertyPermission “user.dir", “read";
permission java.util.PropertyPermission “user.home", “read";
permission java.util.PropertyPermission “java.home", “read";
permission java.util.PropertyPermission “java.class.path", “read";
permission java.util.PropertyPermission “user.name", “read";

//对线程和线程组的操作权限
permission java.lang.RuntimePermission “modifyThread";
permission java.lang.RuntimePermission “modifyThreadGroup";

//操作Socket端口的各种权限
permission java.net.SocketPermission “－", “listen";
permission java.net.SocketPermission “－", “accept";
permission java.net.SocketPermission “－", “connect";
permission java.net.SocketPermission “－", “read";
permission java.net.SocketPermission “－", “write";

//读写文件的权限
permission java.io.FilePermission “－", “read";
permission java.io.FilePermission “－", “write";

//退出系统的权限，例如System.exit(0)
permission java.lang.RuntimePermission “exitVM";
}; 
```



### policytool

是一个图形化的Policy策略文件编辑器；

<a href="https://www.cnblogs.com/zzj0410/articles/5160919.html">policytool使用教程</a>



------



## JCA&JCE（加解密）

加密：根据明文和密钥，经过计算生成密文的过程；

解密：根据密文和密钥，经过计算生成明文的过程；

因美国的密码出口条例约束，在JDK1.1-1.3版本中涉及加解密功能的API被限制出口，JCE属于扩展包，仅供美国和加拿大的用户下载；

因美国法律限制，密钥长度是受限的，即默认支持 AES 128 Bit 的密钥，如果密钥大于 128 Bit，会抛出`InvalidKeyException`异常；

[JDK6无限制JCE包下载地址](http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html)，一定要先备份，再覆盖原文件；

[JDK7无限制JCE包下载地址](http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html)，一定要先备份，再覆盖原文件；

[JDK8无限制JCE包下载地址](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)：一定要先备份，再覆盖原文件；

授权文件绝对路径：`${java_home}/jre/lib/security/java.policy`；

- JCA

  全称 Java Cryptography Architecture，即Java密码体系结构，只是一个约定结构；


  - JCE

      全称 Java Cryptography Extension，即 Java 密码体系实现，指的是 javax.crypto 包中的内容；

      注意从 JDK1.4 版本开始，才将 JCE 捆绑到 JDK 中，即 jce.jar 包；

- 加密算法

  - 对称式加密技术

    即加密和解密使用同一个密钥；


    - 非对称式加密技术
    
      即加密和解密使用的密钥不同：公钥可以对外公布，私钥需要保密；
    
      对称加密算法如果在网络上传输加密文件就很难不把密钥告诉对方，不管用什么方法都有可能被别人窃听到；
    
      非对称加密算法有两个密钥，公钥是可以公开的，私钥是保密的，这样就很好地避免了密钥的传输安全性问题；
    
    - 常用加密算法
    
      | 算法名称 | 密钥长        | 块长 | 速度 | 说明                                                         | 类型       |
      | -------- | ------------- | ---- | ---- | ------------------------------------------------------------ | ---------- |
      | DES      | 56            | 64   | 较快 | 适用于加密大量数据，不太安全                                 | 对称加密   |
      | 3DES     | 112/168       | 64   | 较慢 | 中等安全, 适合加密较小的数据                                 | 对称加密   |
      | AES      | 128, 192, 256 | 128  | 快   | 安全                                                         | 对称加密   |
      | Blowfish | （4至56）*8   | 64   | 快   | 应该安全, 在安全界尚未被充分分析、论证                       | 对称加密   |
      | RC4      | 40-1024       | 64   | 很快 | 安全性不明确，变长密钥对大量数据进行加密                     | 对称加密   |
      | RSA      | 500-1024      |      | 很慢 | 512位被视为不安全的；<br/>768位不用担心受到危害；<br>1024位几乎是安全的，用于少量数据加密； | 非对称加密 |
      | MD5      | 128           | 32   | 快   | 普遍、稳定广泛应用于普通数据，不可逆                         | 散列算法   |
      | SHA1     | 160           |      | 快   | 安全散列算法，但安全性如今被密码学家严重质疑                 | 散列算法   |


    - 总结
      - 非对称加密普遍会比对称加密慢，取决于密码长度（长度长计算复杂度大）；
      - 非对称加密普遍使用 RSA，对称加密普遍使用 AES；
      - 对称加密的密钥管理较为重要，需要保证传输的安全性；
      - 散列算法的安全性不高，有被破解的可能；



- 核心类

  jce.jar 包中的核心 API 都在 javax.crypto 包下，主要包括：加解密、密钥生成（对称）、MAC生成、密钥协商等核心功能；

  - Provider（提供商）

    表示加密算法的提供商，查看当前支持提供商信息：

    ```java
    public class Main {
      
    	public static void main(String[] args) throws Exception {
        // Security.addProvider(new BouncyCastleProvider());
    		Provider[] providers = Security.getProviders();
    		if (null != providers) {
    			for (Provider provider : providers) {
    				Set<Provider.Service> services = provider.getServices();
    				for (Provider.Service service : services) {
    					if ("Cipher".equals(service.getType())) {
    						String s = String.format("provider:%s,  type:%s,  algorithm:%s", 
                                         service.getProvider(), 
                                         service.getType(), 
                                         service.getAlgorithm());
    						System.out.println(s);
    					}
    				}
    			}
    		}
    	}
    }
    ```

    引入第三方的提供商，比如引入bouncycastle（BC）的依赖：

    ```xml
    <dependency>
        <groupId>org.bouncycastle</groupId>
        <artifactId>bcprov-jdk15on</artifactId>
        <version>1.60</version>
    </dependency>
    ```

    ```java
    Security.addProvider(new BouncyCastleProvider()); // 装载BC提供商
    ```

  - Key（密钥接口）

    密匙，可以使用 SecretKeySpec、KeyGenerator 和 KeyPairGenerator 创建密匙；

  - SecretKey（安全密钥接口）

    表示安全密钥信息；

  - KeySpec（密钥规范接口）

    表示密钥规范，是一个空接口。其实实现类有 DESKeySpec、SecretKeySpec；

  - SecretKeySpec（安全密钥规范）

    安全密钥规范，密钥规范接口的实现类，使用加密算法对密钥规范加密后；

  - KeyPairGenerator（密钥对生成器）

    可以为以下算法生成加密密匙：

    | 算法名        | 说明                                                         |
    | ------------- | ------------------------------------------------------------ |
    | DiffieHellman | Generates keypairs for the Diffie-Hellman KeyAgreement algorithm.Note:<br> `key.getAlgorithm()` will return "DH" instead of "DiffieHellman". |
    | DSA           | Generates keypairs for the Digital Signature Algorithm.      |
    | RSA           | Generates keypairs for the RSA algorithm (Signature/Cipher). |
    | EC            | Generates keypairs for the Elliptic Curve algorithm.         |

    ```java
    // 根据slatKey获取公匙
    public static byte[] getPublicKey(String slatKey) throws Exception {
      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
      SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
      random.setSeed(slatKey.getBytes()); // 随机种子
      keyPairGenerator.initialize(1024, random);// or 2048
      KeyPair keyPair = keyPairGenerator.generateKeyPair();
      return keyPair.getPublic().getEncoded();
    }
    
    // 根据slatKey获取私匙
    public static byte[] getPrivateKey(String slatKey) throws Exception {
      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
      SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
      random.setSeed(slatKey.getBytes());
      keyPairGenerator.initialize(1024, random); // or 2048
      KeyPair keyPair = keyPairGenerator.generateKeyPair();
      return keyPair.getPrivate().getEncoded();
    }
    ```

  - KeyGenerator（密钥生成器）

    支持为以下算法创建密匙；

    | 算法名                                             | 说明                                                         |
    | -------------------------------------------------- | ------------------------------------------------------------ |
    | AES                                                | Key generator for use with the AES algorithm                 |
    | ARCFOUR                                            | Key generator for use with the ARCFOUR (RC4) algorithm       |
    | Blowfish                                           | Key generator for use with the Blowfish algorithm            |
    | DES                                                | Key generator for use with the DES algorithm                 |
    | DESede                                             | Key generator for use with the DESede (triple-DES) algorithm |
    | HmacMD5                                            | Key generator for use with the HmacMD5 algorithm             |
    | HmacSHA1<br>HmacSHA256<br>HmacSHA384<br>HmacSHA512 | Keys generator for use with the various flavors of the HmacSHA algorithms |
    | RC2                                                | Key generator for use with the RC2 algorithm                 |

    ```java
    public Key toKey(String strKey) throws NoSuchAlgorithmException { // strKey是密钥
      KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
      keyGenerator.init(128, new SecureRandom(strKey.getBytes()));
      SecretKey secretKey = keyGenerator.generateKey();
      byte[] enCodeFormat = secretKey.getEncoded();
      return new SecretKeySpec(enCodeFormat, "AES");
    }
    ```

    ```java
    public static Key getSlatKey(String slatKey) throws Exception { // slatKey可以是任意长度的
      KeyGenerator kgen = KeyGenerator.getInstance("AES");
      SecureRandom random = SecureRandom.getInstance("SHA1PRNG"); // 随机种子
      random.setSeed(slatKey.getBytes());
      kgen.init(128, random); // 设置密匙的长度128bit(16位byte) 
      Key key = kgen.generateKey();
      return key;
    }
    ```

  - SecretKeyFactory（密钥工厂）

    | 方法                                           | 返回值           | 说明                                                         |
    | ---------------------------------------------- | ---------------- | ------------------------------------------------------------ |
    | getInstance(String algorithm)                  | SecretKeyFactory | 返回指定加密算法的密钥工厂<br/>此方法基于SPI机制获取密钥工厂；<br>通过Security.getProviders().getServices("SecretKeyFactory", 算法名)查找已注册的第一个SecretKeyFactorySpi对象； |
    | getInstance(String algorithm, String provider) | SecretKeyFactory | 根据加密算法和算法实现的提供商信息，查询对应的密钥工程       |
    | getProvider()                                  | Provider         | 返回密钥工厂的提供商信息                                     |
    | getAlgorithm()                                 | String           | 返回密钥工程的加密算法名                                     |
    | generateSecret(KeySpec keySpec)                | SecretKey        | 根据提供的密钥规范生成密钥信息                               |
    | getKeySpec(SecretKey key, Class cls)           | KeySpec          | 返回给定密钥规范，且返回值的类与参数Class相同                |
    | translateKey(SecretKey key)                    | SecretKey        | 将一个密钥对象（其提供者未知或可能不受信任）转换为此秘密密钥工厂的相应密钥对象 |

    ```java
    public class TestSecretKeyFactory {
    	
    	public static void main(String[] args) throws Exception {
    		SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
    		byte[] DESkey = "abcdefghijk".getBytes("UTF-8"); // 设置密钥
    		DESKeySpec keySpec = new DESKeySpec(DESkey);
    		SecretKey key = keyFactory.generateSecret(keySpec); // 得到密钥对象
    		System.out.println("over");
    	}
    }
    ```

  - Cipher（加密器）

    是JCE的核心类，提供了具体的加密与解密功能；

    ![请添加图片描述](./01.Java_part1.assets/JCE_Cipher_0.png)

    | 方法                                                         | 返回值                 | 说明                                                         |
    | ------------------------------------------------------------ | ---------------------- | ------------------------------------------------------------ |
    | getInstance(<br/>String transformation<br/>)                 | Cipher                 | 静态工厂方法<br>transformation：转换模式，格式：**algorithm/mode/padding**； |
    | getInstance(<br/>String transformation,<br/>String providerName<br/>) | Cipher                 | 静态工厂方法<br/>transformation：转换模式，格式：**algorithm/mode/padding**；<br>providerName：加密器的提供商名； |
    | getInstance(<br/>String transformation,<br/>Provider provider<br/>) | Cipher                 | 静态工厂方法<br/>transformation：转换模式，格式：**algorithm/mode/padding**；<br/>provider表示加密器的提供商信息； |
    | getProvider()                                                | Provider               | 返回加密器的提供商，即 CipherSpi 中的 Provider               |
    | getAlgorithm()                                               | String                 | 返回transformation：转换模式，格式：**algorithm/mode/padding**； |
    | getBlockSize()                                               | int                    | 按块密码方式加密，每个块的大小；<br>[块密码说明](https://zhuanlan.zhihu.com/p/76796603) |
    | getOutputSize(<br/>int inputlen<br/>)                        | int                    | inputlen：在准备调用update或dofinal操作数据时，字节数组的长度<br/>返回下一次执行update或dofinal操作时，所需的输出缓冲区长度<br>输入参数与返回值都是以字节为单位 |
    | getIV()                                                      | byte[]                 | 新缓冲区中的初始化向量；<br/>如果底层算法不使用 iv，或者 iv 尚未设置，则返回 null； |
    | getParameters()                                              | AlgorithmParameters    | 返回此 Cipher 使用的参数。<br/>返回的参数可能与初始化此 Cipher 所使用的参数相同；<br/>如果此 Cipher 需要算法参数，但却未使用任何参数进行初始化，<br/>则返回的参数将由默认值和底层 Cipher 实现所使用的随机参数值组成； |
    | getExemptionMechanism()                                      | ExemptionMechanism     | 返回此 Cipher 使用的豁免（exemption）机制对象。              |
    | init(<br/>int opmode, <br/>Key key<br/>)                     | void                   | 初始化加密器；<br/>key：密钥对象；<br/>opmode：操作模式，如下：<br/>Cipher.ENCRYPT_MODE（加密模式）<br/>Cipher.DECRYPT_MODE（解密模式）<br/>Cipher.WRAP_MODE（包装密钥模式）<br/>Cipher.UNWRAP_MODE（解包装密钥模式） |
    | init(<br/>int opmode, <br/>Certificate certificate<br/>)     | void                   | 初始化加密器；<br/>opmode：操作模式，如下：<br/>Cipher.ENCRYPT_MODE（加密模式）<br/>Cipher.DECRYPT_MODE（解密模式）<br/>Cipher.WRAP_MODE（包装密钥模式）<br/>Cipher.UNWRAP_MODE（解包装密钥模式）<br/>certificate：带有密钥的证书对象 |
    | init(<br/>int opmode, <br/>Key key, <br/>SecureRandom random<br/>) | void                   | 初始化加密器；<br/>opmode：操作模式，如下：<br/>Cipher.ENCRYPT_MODE（加密模式）<br/>Cipher.DECRYPT_MODE（解密模式）<br/>Cipher.WRAP_MODE（包装密钥模式）<br/>Cipher.UNWRAP_MODE（解包装密钥模式）<br>key：密钥对象；<br/>random：随机源，因为有些算法每次加密结果都要不同，这个时候要依赖随机源 |
    | init(<br/>int opmode, <br/>Certificate certificate, <br/>SecureRandom random<br/>) | void                   | 初始化加密器；<br/>opmode：操作模式，如下：<br/>Cipher.ENCRYPT_MODE（加密模式）<br/>Cipher.DECRYPT_MODE（解密模式）<br/>Cipher.WRAP_MODE（包装密钥模式）<br/>Cipher.UNWRAP_MODE（解包装密钥模式）<br/>certificate：带有密钥的证书对象<br>random：随机源，因为有些算法每次加密结果都要不同，这个时候要依赖随机源 |
    | init(<br/>int opmode, <br/>Key key, <br/>AlgorithmParameterSpec params<br/>) | void                   | 初始化加密器；<br/>opmode：操作模式，如下：<br/>Cipher.ENCRYPT_MODE（加密模式）<br/>Cipher.DECRYPT_MODE（解密模式）<br/>Cipher.WRAP_MODE（包装密钥模式）<br/>Cipher.UNWRAP_MODE（解包装密钥模式）<br/>key：密钥对象；<br/>params：加密参数规范接口，用于加密的参数必须用于解密<br>使用CBC模式时必须传入该参数，使用IvParameterSpec创建iv对象 |
    | init(<br/>int opmode, <br/>Key key, <br/>AlgorithmParameterSpec params,<br/>SecureRandom random<br/>) | void                   | 初始化加密器；<br/>opmode：操作模式，如下：<br/>Cipher.ENCRYPT_MODE（加密模式）<br/>Cipher.DECRYPT_MODE（解密模式）<br/>Cipher.WRAP_MODE（包装密钥模式）<br/>Cipher.UNWRAP_MODE（解包装密钥模式）<br/>key：密钥对象；<br/>params：加密参数规范接口，用于加密的参数必须用于解密<br/>使用CBC模式时必须传入该参数，使用IvParameterSpec创建iv对象<br>random：随机源，因为有些算法每次加密结果都要不同，这个时候要依赖随机源 |
    | init(<br/>int opmode, <br/>Key key, <br/>AlgorithmParameters params<br/>) | void                   | 初始化加密器；<br/>opmode：操作模式，如下：<br/>Cipher.ENCRYPT_MODE（加密模式）<br/>Cipher.DECRYPT_MODE（解密模式）<br/>Cipher.WRAP_MODE（包装密钥模式）<br/>Cipher.UNWRAP_MODE（解包装密钥模式）<br/>key：密钥对象；<br/>params：加密参数规范接口，用于加密的参数必须用于解密<br/>使用CBC模式时必须传入该参数，使用IvParameterSpec创建iv对象 |
    | update(byte[] input)                                         | byte[]                 | 执行加密或解密数据（多步骤）<br/>如不知道待加密数据长度或数据太长，无法一次存储在内存中时使用；<br>input：待加密数据；<br/>返回值是加密后的byte数组 |
    | update(byte[] input, <br/>int inputOffset, <br/>int inputLen<br/>) | byte[]                 | 执行加密或解密数据（多步骤）<br/>如不知道待加密数据长度或数据太长，无法一次存储在内存中时使用；<br/>input：待加密数据；<br/>inputOffset：加密开始位置<br/>inputLen：加密长度 <br/>返回值是加密后的byte数组 |
    | update(byte[] input, <br/>int inputOffset, <br/>int inputLen, <br/>byte[] output<br/>) | int                    | 执行加密或解密数据（多步骤）<br/>如不知道待加密数据长度或数据太长，无法一次存储在内存中时使用；<br/>input：待加密数据；<br/>inputOffset：加密开始位置<br/>inputLen：加密长度 <br/>output：用于存储加密后的数据<br/>返回是否成功（0/1） |
    | update(byte[] input, <br/>int inputOffset, <br/>int inputLen, <br/>byte[] output, <br/>int outputOffset<br/>) | int                    | 执行加密或解密数据（多步骤）<br/>如不知道待加密数据长度或数据太长，无法一次存储在内存中时使用；<br/>input：待加密数据；<br/>inputOffset：加密开始位置<br/>inputLen：加密长度 <br/>output：用于存储加密后的数据<br/>outputOffset ：加密后的数据中的起始位置<br/>返回是否成功（0/1） |
    | doFinal(byte[] input)                                        | byte[]                 | 执行加密或解密数据（单步骤）<br/>input：待处理数据；<br/>返回处理后的字节数组 |
    | doFinal(byte[] input, <br/>int inputOffset, <br/>int inputLen<br/>) | byte[]                 | 执行加密或解密数据（单步骤）<br/>input：待处理数据；<br/>inputOffset：开始位置；<br/>inputLen：数据长度；<br>返回处理后的字节数组 |
    | doFinal(byte[] input, <br/>int inputOffset, <br/>int inputLen, <br/>byte[] output<br/>) | int                    | 执行加密或解密数据（单步骤）<br/>input：待处理数据；<br/>inputOffset：开始位置；<br/>inputLen：数据长度；<br/>output：存储处理后的数据<br/>返回是否成功（0/1） |
    | doFinal(byte[] input,<br/>int inputOffset, <br/>int inputLen, <br/>byte[] output, <br/>int outputOffset<br/>) | int                    | 执行加密或解密数据（单步骤）<br/>input：待处理数据；<br/>inputOffset：开始位置；<br/>inputLen：数据长度；<br/>output：存储处理后的数据<br/>outputOffset ：处理后数据的起始位置<br>返回是否成功（0/1） |
    | wrap(Key key)                                                | byte[]                 | 通过某种算法对原始密钥进行加密包装；<br/>这样在传递密钥的过程中避免泄漏密钥铭文；<br/>初始化时一定要用Cipher.WRAP_MODE（包装密钥模式） |
    | unwrap(<br/>byte[] wrappedKey,<br/>String wrappedKeyAlgorithm,<br/>int wrappedKeyType<br/>) | Key                    | 把包装加密后的密钥解包为原始密钥<br/>初始化时一定要用Cipher.UNWRAP_MODE<br/>wrappedKey：要解包的密钥；<br/>wrappedKeyAlgorithm：与此包装密钥关联的算法；<br>wrappedKeyType：已包装密钥的类型<br/>Cipher.PUBLIC_KEY（密钥类型为公钥）<br/>Cipher.PRIVATE_KEY（密钥类型为私钥）<br/>Cipher.SECRET_KEY（对称加密的密钥） |
    | getMaxAllowedKeyLength(<br/>String transformation<br/>)      | int                    | transformation：转换模式，格式：algorithm/mode/padding；<br/>返回最大密钥长度；<br/>如果安装了无限制强度仲裁策略文件，返回Integer.MAX_VALUE |
    | getMaxAllowedParameterSpec(<br/>String transformation<br/>)  | AlgorithmParameterSpec | transformation：转换模式，格式：algorithm/mode/padding；<br/>保存最大值的 AlgorithmParameterSpec；<br/>如果安装了无限制强度仲裁策略文件，或者策略文件中对用于指定转换的参数没有最大限制，则返回 null； |

    - transformation（转换模式）

      格式：algorithm/mode/padding，具体细节与详情可查看 **[Java密体系结构标准算法文档](http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html)** ；

      - algorithm（加密算法名，必填项）

        - AES/AESWrap（加密数据必须是8的整数倍）
        - ARCFOUR
        - Blowfish
        - RC2/RC4/RC5
        - RSA
        - DES/DESede/DESedeWrap/ECIES

      - mode（加密模式，非必填项，默认为ECB）

        主要针对分组密码，分组密码是将明文消息编码后的数字序列（简称明文数字序列）划分成长度为 n 的组（可看成长度为 n 的矢量），每组分别在密钥控制下变换成等长的输出数字序列（简称密文数字序列）；

        具体可查看 [加密模式介绍（ECB、CBC、PCBC、CFB、OFB、CTR）](https://blog.csdn.net/weixin_42272869/article/details/124278342)

        - NONE

        - CBC

          Cipher Block Chaining，密码分组链接；

          加密算法的输入是上一个密文组和下一个明文组的异或；

          有向量模式，可以简单理解为偏移量，需要定义一个IvParameterSpec对象；

        - CCM

        - CFB,CFBx

        - CTR/CTS

        - ECB

          Electronic Code Book，电子密码本，无向量模式，用相同的密钥分别对明文分组独立加密；

        - GCM

        - OFB,OFBx

        - PCBC

      - padding（填充模式，非必填项，默认为PKCS5Padding）

        块加密算法要求，原文数据长度为固定块大小的整数倍，如果原文数据长度大于固定块大小，则需要在固定块填充数据直至整个块的数据是完整的。例如：如果约定块长度是128，实际需要加密的原文长度是129，则需要分为两个加密块，第二个加密块需要填充127位数据；

        具体可查看 [分组加密中的填充介绍](https://blog.csdn.net/weixin_42272869/article/details/124282901)

        - NoPadding

          不启用填充模式（加密内容不足8位用0补足8位, Cipher类不提供补位功能，需自己实现代码给加密内容添加0, 如{65,65,65,0,0,0,0,0}）；

        - ISO10126Padding

          XML 加密语法和处理文档中有详细描述；

        - OAEPPadding/OAEPWithAndPadding

          PKCS1中定义的最优非对称加密填充方案，digest代表消息摘要类型，mgf代表掩码生成函数；

          例如：`OAEPWithMD5AndMGF1Padding` 或 `OAEPWithSHA-512AndMGF1Padding`；

        - PKCS1Padding

          PKCS1，RSA算法使用

        - PKCS5Padding

          PKCS5，RSA算法使用（加密内容不足8位用余位数补足8位, 如{65,65,65,5,5,5,5,5}或{97,97,97,97,97,97,2,2}; 刚好8位补8位8）；

        - SSL3Padding

          见SSL Protocol Version 3.0的定义；

- 消息认证码（MAC）

  消息认证码（Message authentication code，缩写MAC），又译为消息鉴别码、文件消息认证码、讯息鉴别码、信息认证码，用于检查消息的完整性，以及作身份验证。可以用来检查在消息传递过程中，其内容是否被更改过，不管更改的原因是来自意外或是蓄意攻击。同时可以作为消息来源的身份验证，确认消息的来源。 消息认证码的算法中，通常会使用使用带密钥的散列函数，或者块密码的带认证工作模式（如CBC）。 信息鉴别码不能提供对信息的保密，若要同时实现保密认证，同时需要对信息进行加密。

  MAC优于数据摘要的地方在于：MAC双方要共享一个密钥，所以也有互相认证的功能，可有效防止数据摘要中明文和数据摘要被同时替换而无法发现的问题。

  ![JCE_MAC_0](./01.Java_part1.assets/JCE_MAC_0-6281641.png)

  ```java
  public class TestMac {
  
  	// Mac算法
  	public static enum JMacAlgorithm {
  		HmacMD5, HmacSHA1, HmacSHA224, HmacSHA256, HmacSHA384, HmacSHA512;
  		
  		public String getName() {
  			return this.name();
  		}
  	}
  
  	// 初始化密钥
  	public static byte[] initKey(String algorithm) {
  		try {
  			KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);
  			SecretKey secretKey = keyGenerator.generateKey();
  			return secretKey.getEncoded();
  		} catch (Exception e) {
  			throw new RuntimeException("initKey", e);
  		}
  	}
  
  	// 加密
  	public static byte[] encrypt(byte[] data, byte[] key, String algorithm) {
  		return getMac(key, algorithm).doFinal(data);
  	}
  
  	private static Mac getMac(byte[] key, String algorithm) {
  		try {
  			Mac mac = Mac.getInstance(algorithm);
  			SecretKey secretKey = new SecretKeySpec(key, algorithm);
  			mac.init(secretKey);
  			return mac;
  		} catch (Exception e) {
  			throw new RuntimeException("getMac", e);
  		}
  	}
  	
  	public static void main(String[] args) {
  		String str = "jianggujin";
  		System.out.println("原串：" + str);
  		Base64.Encoder encoder = Base64.getEncoder();
  		for (JMacAlgorithm algorithm : JMacAlgorithm.values()) {
  			System.out.println("-----------------------------------------");
  			System.out.println("算法：" + algorithm.getName());
  			byte[] key = TestMac.initKey(algorithm.getName());
  			System.out.println("密钥：" + encoder.encodeToString(key));
  			byte[] result = TestMac.encrypt(str.getBytes(), key, algorithm.getName());
  			System.out.println("结果：" + encoder.encodeToString(result));
  		}
  	}
  }
  ```

- 密钥协商？？？

  密钥协商就是在通讯多方间不直接交换通讯密钥的情况下而选择一个大家达成一致的密钥（session key），这个（session key）是对称密钥；

  [密钥协商](https://javaforall.cn/149236.html)

- 示例

  DES加密操作：

  ```java
  public static byte[] encrypt(byte[] bytes, byte[] key) { // bytes是明文，key是密钥，必须大于8字节
  		try {
  			Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding"); //  生成一个加密组件
  			SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("DES");
  			KeySpec keySpec = new DESKeySpec(key);
  			SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
  			cipher.init(Cipher.ENCRYPT_MODE, secretKey, new SecureRandom()); // 初始化
  			byte[] enMsgBytes = cipher.doFinal(bytes); // 加密
  			return enMsgBytes;
  		} catch (Exception e) {
  			throw new RuntimeException("encrypt error", e);
  		}
  }
  ```

  DES解密操作：

  ```java
  public static byte[] decrypt(byte[] bytes, byte[] key) { // bytes是密文，key是密钥，必须大于8字节
    try {
      Cipher deCipher = Cipher.getInstance("DES/ECB/PKCS5Padding"); //  生成一个加密组件
      SecretKeyFactory deDecretKeyFactory = SecretKeyFactory.getInstance("DES");
      KeySpec deKeySpec = new DESKeySpec(key);
      SecretKey deSecretKey = deDecretKeyFactory.generateSecret(deKeySpec);
      deCipher.init(Cipher.DECRYPT_MODE, deSecretKey, new SecureRandom()); // 初始化
      byte[] deMsgBytes = deCipher.doFinal(bytes); // 解密
      return deMsgBytes;
    } catch (Exception e) {
    	throw new RuntimeException("decrypt error", e);
    }
  }
  ```

  MD5加密操作：

  ```java
  public static String md5(String str) { // str 是明文
  		try {
  			MessageDigest md = MessageDigest.getInstance("MD5"); // 创建一个消息生成器
  			md.reset();
  			md.update(str.getBytes("UTF-8"));
  			byte[] array = md.digest();
  			Chars buf = new Chars();
  			for (int i = 0; i < array.length; i++) {				
  				if (Integer.toHexString(0xFF & array[i]).length() == 1) { // 如果是0L的话默认在数字前面补4个零字符
  					buf.append("0").append(Integer.toHexString(0xFF & array[i]));
  				} else {
  					buf.append(Integer.toHexString(0xFF & array[i]));
  				}
  			}
  			return buf.toString().toUpperCase(); // 生成MD5码
  		} catch (Throwable e) {
  			throw new RuntimeException("md5", e);
  		}
  }
  ```

  对密钥进行包装和解包装：？？？

  ```java
  public enum EncryptUtils {
  
  	SINGLETON;
  	
  	private static final String SECRECT = "password";
  	
  	private static final SecureRandom random = new SecureRandom();
  	
  	public byte[] wrap(String keyString) throws Exception {
  		byte[] key = SECRECT.getBytes("utf-8");
  		Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding"); // 生成一个加密组件
  		SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("DES");
  		KeySpec keySpec = new DESKeySpec(key);
  		SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
  		cipher.init(Cipher.WRAP_MODE, secretKey, random); // 初始化
  		byte[] wrap = cipher.wrap(secretKey);
  		return wrap;
  	}
  	
  	public String unwrap(byte[] rawKey) throws Exception {
  		byte[] key = SECRECT.getBytes();
  		Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding"); // 生成一个加密组件
  		SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("DES");
  		KeySpec keySpec = new DESKeySpec(key);
  		SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
  		cipher.init(Cipher.UNWRAP_MODE, secretKey, random); // 初始化
  		Key key1 = cipher.unwrap(rawKey, "DES", Cipher.SECRET_KEY);
  		return new String(key1.getEncoded(), "utf-8");
  	}
  	
  	public static void main(String[] args) throws Exception {
  		byte[] wrapKey = EncryptUtils.SINGLETON.wrap("doge");
  		System.out.println(wrapKey);
  		System.out.println(EncryptUtils.SINGLETON.unwrap(wrapKey));
  	}
  }
  ```

  带算法参数的加解密：

  ```java
  public class TestPBEParameterSpec {
  	
  	// 提供基于口令的加密功能
  	public static final String pbeEncrypt(String plainText) {
  		Key pbeSecretKey = getPBEKey();
  		PBEParameterSpec pbeParamSpec = getParamSpec();
  		try {
  			Cipher cipher = Cipher.getInstance("PBEWithMD5AndDES");
  			cipher.init(Cipher.ENCRYPT_MODE, pbeSecretKey, pbeParamSpec);
  			byte[] p = plainText.getBytes("UTF-8");
  			byte[] result = cipher.doFinal(p);
        //BASE64Encoder encoder = new BASE64Encoder();
  			//String encoded = encoder.encode(result);
  			Base64.Encoder encoder = Base64.getEncoder();
  			String encoded = encoder.encodeToString(result);
  			return encoded;
  		} catch (Exception e) {
  			throw new RuntimeException(e);
  		}
  	}
  	
  	// 提供基于口令的解密功能.
  	public static final String pbeDecrypt(String cipherText) {
  		Key pbeSecretKey = getPBEKey();
  		PBEParameterSpec pbeParamSpec = getParamSpec();
  		try {
  			Cipher cipher = Cipher.getInstance("PBEWithMD5AndDES");
  			cipher.init(Cipher.DECRYPT_MODE, pbeSecretKey, pbeParamSpec);
        
        //BASE64Decoder decoder = new BASE64Decoder();
  			//byte[] c = decoder.decodeBuffer(cipherText);
        
  			Base64.Decoder decoder = Base64.getDecoder();
  			byte[] c = decoder.decode(cipherText);
  			byte[] result = cipher.doFinal(c);
  			String plainText = new String(result, "UTF-8");
  			return plainText;
  		} catch (Exception e) {
  			throw new RuntimeException(e);
  		}
  	}
  	
  	// 获取PBE算法的密钥. 注意PBE密钥由用户提供的口令构造出来的, 用户提供的口令务必使用char数组, 而不能使用字符串, 字符数 组用完即清空
  	private static final Key getPBEKey() {
  		// TODO come from db or System.in, NOTE: MUST be char array, not java.lang.String
  		char[] pwd = { '%', '_', 'A', 's', '9', 'K' };
  		SecretKey pbeKey = null;
  		PBEKeySpec pbeKeySpec = new PBEKeySpec(pwd);
  		try {
  			SecretKeyFactory keyFac = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
  			pbeKey = keyFac.generateSecret(pbeKeySpec);
  			return pbeKey;
  		} catch (Exception e) {
  			throw new RuntimeException(e);
  		} finally {
  			Arrays.fill(pwd, ' ');
  		}
  	}
  	
  	// 获取PBE的算法参数, 涉及salt和iterate count两个参数
  	private static final PBEParameterSpec getParamSpec() {
  		byte[] salt = { (byte) 0xab, 
                     (byte) 0x58, 
                     (byte) 0xa1, 
                     (byte) 0x8c, 
                     (byte) 0x3e, 
                     (byte) 0xc8, 
                     (byte) 0x9d, 
                     (byte) 0x7a 
      };
  		int count = 20;
  		PBEParameterSpec paramSpec = new PBEParameterSpec(salt, count);
  		return paramSpec;
  	}
  	
  	public static void main(String[] args) {
  		String pbePlainText = "127Kjk$%2^";
  		String pbeCipherText = pbeEncrypt(pbePlainText);
  		String pbePlainText2 = pbeDecrypt(pbeCipherText);
  		if (!pbePlainText.equals(pbePlainText2)) {
  			System.out.println("PBE Something wrong");
  		} else {
  			System.out.println("PBE do right");
  		}
  	}
  }
  ```




------



# 垃圾回收（GC）

英文 Generational Collection，为有效利用内存空间并防止内存泄漏，而自动回收虚拟机内存中不再被使用的对象内存的机制，不再需要手动释放内存空间。

GC 机制是通过 GC 线程执行的，GC 线程是一个守护线程，当确定对象为不可达时，GC 线程会回收这些不可达对象的内存空间。



## 垃圾识别算法

有二种算法可以判断内存中的对象是否为不可达对象。



### 引用计数法

是指将对象的被引用次数保存起来，当被引用次数变为零时表示对象不可达。



### 可达性算法

是指用**GC Roots**对象作为根结点，判断对象是否与**GC Root**对象关联起来。如果发生了直接或间接的关联，则会形成一个引用链（Reference Chain）表示对象可达，如果没有直接或间接的关联，则表示此对象是不可达的。如下图所示，从**GC Roots**出发没有达到 a 和 b，所以 a 和 b 是可回收。

<img src="./01.Java_part1.assets/JavaReachabilityAlgorithm.png" alt="Java垃圾回收机制详解_老年代_06" />

可作为**GC Roots**对象的有：

- 虚拟机栈（栈帧中的局部变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法（native方法）栈中引用的对象；
- 虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器；
- 所有被同步锁（synchronized关键字）持有的对象；



## GC种类



### YoungGC

也叫 MinorGC、MGC、YGC，当新生代的 Eden区没有足够的内存空间分配时，针对新生代的GC。如果YGC频繁，会导虚拟机性能下降。

YGC流程：

- 当 Eden 区快满的时候会触发 YGC；

- 假设 Survivor0 是未使用的存活区，此时 Survivor1 是上次YGC使用的存活区（两个Survivor总有一个是未使用的）；

- 首先将上一次YGC时使用的 Survivor1 区中的存活对象，复制到 Survivor0 区中；

- 再把 Eden 区中存活的对象，也复制到存活区 Survivor0，如果 Survivor0 区中空间不足，则对象会直接进入老年代；

- 将 Survivor1 区设置为未使用的状态，将 Survivor0 区设置为使用状态；

- 年轻代中长期存活的对象会晋升到老年代；

  即年轻代中的对象经历了 15 次 YGC 后还存活，则该对象会进入到老年代。可使用虚拟机参数 `-XX:MaxTenuringThreshold` 来设置这个阀值。



#### 空间分配担保

在执行YGC前，虚拟机会先检查老年代中最大可用的连续空间是否大于新生代所有存活对象的总空间，如果老年代中空间足够，那么执行YGC是安全的。如果老年代中空间不足，则还会查看 `-XX:HandlePromotionFailure` 启动参数是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次YGC；如果小于，或者不允许空间分配担保，则会执行一次FullGC。



### OldGC

也叫 MajorGC，是指老年代被占满之后，就会触发老年代的GC，单独回收老年代的只有并发标记清除回收机制（CMS）。



### MixedGC

是G1收集器中专用的概念：在G1中，一旦老年代的内存使用率达到45%及以上，就要触发MixedGC，会同时对新生代和老年代执行GC。

可使用虚拟机参数 `-XX:InitiatingHeapOccupancyPercent` 设置触发 MixedGC的阀值，参数的默认值是 45（单位是百分比）。



### FullGC

也叫 FullGC、FGC，是指对年轻代、老年代、元空间中的内存执行GC操作。

FullGC 时会暂停除GC线程以外的所有用户线程，所以STW时间过长会导致系统性能下降。



#### 触发条件

- 老年代内存空间不足时；
- 元空间内存空间不足时；
- 调用 `System.gc()`，建议执行GC（不一定会执行），也可以通过 `-XX:+DisableExplicitGC` 来禁止，不允许通过代码来触发GC；
- 空间分配担保失败时，使用复制算法的YGC，需要老年代的内存空间作担保，如果担保失败会执行一次FullGC；
- 在CMS垃圾收集器抛出concurrent mode failure错误（指老年代正在清理，从年轻代晋升了新对象，或直接分配大对象年轻代放不下导致直接在老年代生成，但老年代空间也不够用）时会退化为单线程的 FullGC；
- 执行 `jmap -histo:live ${pid}`
- 执行 `jmap -dump:format=b,file=ll.bin [pid]`



#### 频繁触发

先使用 jps 命令得到虚拟机的pid编号，根据pid使用jstat命令查看虚拟机内存中各个区大小、执行GC的次数、时间。

再用 jmap 命令导出虚拟机内存dump快照文件，在使用jhat或mat工具分析内存快照。

通过MAT查看Histogram即可找出是哪块代码。



## GC算法



### 复制算法

是将堆内存划分为二块大小一致的逻辑区，暂时叫它们 A堆和 B堆。申请内存时统一在A堆分配，当 A堆用完了，将 A堆中的活动对象全部复制到 B堆，然后 A堆的对象就可以全部回收了。这时不需要将 B堆的对象又搬回 A堆，只需要将 A和 B互换以下就行了，这样原来的 A堆变成 B堆，原来的B堆变成了A堆。经过这一轮复制，活动对象搬了新家，垃圾对象也被回收了。GC 复制算法就是在两个堆之间来回倒腾。

优点：

- 吞吐量优秀，益于复制算法只会搜索复制活动对象，能在较短时间内完成 GC，而且时间与堆的大小无关，只与活动对象数成正比。相比于需要搜索整个堆的GC标记清除算法，GC 复制算法吞吐量更高，而且堆越大，差距越明显；

- 分配速度快，因为不需要搜索空闲链表，在O(1) 的时间复杂度就能完成分配；

- 不会发生碎片化，因为每次复制都会执行压缩；

- 与缓存兼容，因为复制过程中使用了深度优先遍历，具有引用关系的对象会被复制到相邻的位置，局部性原理可以很好发挥作用；

缺点：

- 堆的使用效率低，这是一个最显眼的问题，因为要留一半的空间用来复制，所以堆的利用率总小于50%；
- 不兼容保守式 GC，因为 GC 复制算法需要移动对象；
- 复制时存在递归调用，需要消耗栈空间，并可能导致栈溢出；

![在这里插入图片描述](./01.Java_part1.assets/ReplicationAlgorithm0.png)



### 标记-清除算法（Mark-Sweep）

标记-清除作为最基本的算法，主要包含标记和清除两个阶段：

先根据可达性算法标记出相应的可回收对象，清除阶段回收被标记对象所占用的空间。

缺点：

- 内存碎片化严重，后续可能会发生大对象不能找到可用空间的问题；
- 标记和清除这两个过程的效率都不高；

![在这里插入图片描述](./01.Java_part1.assets/MarkSweepAlgorithm0.png)



### 标记-整理算法（**Mark-Compact**）

先根据可达性算法标记出相应的可回收对象，让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。

![在这里插入图片描述](./01.Java_part1.assets/MarkCompactAlgorithm0.png)



### 并发标记清除算法（CMS）

全称Concurrent marke sweep，是一种针对老年代进行内存回收的并发标记-清除算法，尽可能减少STW时间（stop the world）。

工作流程：

1. 初始标记（需要STW）

   标记出GC root直接引用的对象，从线程栈、静态区（方法区的静态属性引用对象、方法区的常量引用对象）、本地方法栈的JNI引用的对象。

   包含二部分：

   - 老年代中全部的GC root对象，如下图的1结点；

   - 新生代中活着的对象，这些对象所引用到的老年代中的对象，如下图的节点2、3；

     ![img](./01.Java_part1.assets/JavaCMS_0.png)

2. 并行标记

   以初始标记的对象集为起点，并行多线程的搜索所有存活的对象；

   由于该阶段是和用户线程同时进行的，所以对象之间的引用关系会发生改变（如：新生代升到老年代、老年代中的对象引用关系变化等）；

   如果不进行后续处理，会出现漏标的情况，即有了后面的重新标记步骤；

   为了提高重新标记的效率，会将并行标记阶段变化的对象所在的 card 标记为 dirty，后续只扫描标记为 dirty 的 card；

   该阶段会增加2个节点4和5；

   ![img](./01.Java_part1.assets/JavaCMS_1.png)

3. 预清理

   由于并发标记阶段，并不能标记所有存活的对象（因为GC线程与用户线程同时运行），在这个阶段会扫描所有 dirty 的 card；

   如下图节点3 的引用关系发生了变化，所有节点3所在的 card 会被标记成 dirty；

   ![img](./01.Java_part1.assets/JavaCMS_2.png)

   扫描后，6节点会被标记上，如下图：

   ![img](./01.Java_part1.assets/JavaCMS_3.png)

4. 可终止预清理

   该阶段主要是为下阶段的工作铺垫，尽量承担一部分下阶段的工作，该阶段持续的事件依赖很多因素，例如：重复次数、持续工作时间登；

   目的是：期待在该阶段中发生异常YGC，从而减少下个阶段扫描新生代对老年代引用的时间；

5. 重新标记（需要STW）

   目的是标记老年代中所有存活的对象。

   本阶段标记的范围是：整个堆，包含新生和老年代。

   为何扫描新生代？老年代中的对象只要是被新生代中的对象引用了，就算是活的。

   即使新生代中的对象是不可达的，也会用来做GC root扫描老年代。

   在第2到第4阶段，都是和用户线程并行的，新生代中对老年代中的对象引用关系发生了变化，所以重新标记的STW时间相对很长。

6. 并发清理

   此阶段是清理前五个阶段标记后剩下的垃圾对象的内存空间；

   在此阶段的时间内，用户新产生的垃圾，就只能等到下个阶段在清理了；

7. 并发重置

   重置CMS算法需要的内部数据结构，为下一次的CMS做准备；

**相关配置：**

可使用`-XX:+UseConcMarkSweepGC`参数启用CMS；

可使用`-XX:+CMSParallellnitialMarkEnabled`参数设置在初始标记阶段多线程执行，以缩短STW时间；

可通过`-XX:ParallelGCThreads=N`参数设置年轻代的并行收集线程数，默认是(cpu <= 8) ? cpu : 3 + ((cpu * 5) / 8)；

可使用 `-XX:ParallelCMSThreads=20` 参数设置老年代并行收集线程数，默认值`ParallelGCThreads + 3)/4`；

可通过`-XX:+UseCMSCompactAtFullCollection`参数开启堆碎片整理，防止堆碎片引起FullGC；

可通过`-XX:CMSFullGCsBeforeCompaction=3`参数设置多少次FullGC之后压缩一次，默认值是0（表示每次FullGC后都会压缩一次）；

可通过-XX:+CMSParallelRemarkEnabled参数设置在重新标记阶段使用并行线程标记，以缩短STW时间；

可通过-XX:+CMSScavengeBeforeRemark参数强制重新标记前开始一次新生代GC，减少重新标记的STW时间；

可通过`+CMSPermGenSweepingEnabled -XX:+CMSClassUnloadingEnabled`参数开启CMS回收永久代的选项，可避免永久代满引起的FullGC；

可通过`-XX:CMSInitiatingOccupancyFraction=80`参数设置老年代触发FullGC的内存使用率，默认是92（单位：百分比）；

可通过`-XX:+UseCMSInitiatingOccupancyOnly` 参数设置始终用自定义的阈值（`-XX:CMSInitiatingOccupancyFraction`）触发CMS收集，如果不指定这个参数，第二次执行CMS时`-XX:CMSInitiatingOccupancyFraction=80`参数会恢复为默认值；

注意：如果`-XX:CMSInitiatingOccupancyFraction`设置大了会FullGC，小了会频繁CMS，那就说明老年代的空间小了（需要增大）；



## 垃圾收集器

是垃圾收集算法的具体实现，可根据实际场景选择合适的垃圾收集器，性能指标如下：

- 吞吐量：程序运行时间占总运行时间（总运行时间=程序运行时间+垃圾回收时间）的比例，垃圾回收时间越少，吞吐量越高；
- 暂停时间：STW的时间；
- 内存占用：Java堆所占的大小；

在一个垃圾收集器中不可能全部满足以上三点，但随着硬件水平的提升，内存占用不再是我们关注的重点，评估垃圾回收器性能时，重点关注吞吐量和暂停时间。吞吐量和暂停时间是相互矛盾的，目前我们追求的效果是：在最大吞吐量优先的情况下，减小暂停时间。

垃圾收集器发展历史：

- 1999年 JDK 1.3.1 发布第一款串行方式的 Serial GC、ParNew 垃圾回收器是 Serial 回收器的多线程版本；
- 2002年2月26 JDK 1.4.2 发布 Parallel GC 和 Concurrent Mark Sweep GC（CMS）；
- 2006年 JDK 1.6 默认使用 Parallel GC 收集器；
- 2012年 JDK 1.7 默认使用 Parallel Scavenge（新生代）+Parallel Old（老年代）收集器，JDK1.7 u4 版本中正式提供了G1；

- 2014年 JDK 1.8 默认使用 Parallel Scavenge（新生代）+Parallel Old（老年代）收集器；

- 2017年 JDK1.9 默认使用 G1 收集器；
- 2018年3月 JDK 10 提升了 G1 并行性；
- 2018年9月 JDK 11 引入了 Epsilon 收集器，同时引入ZGC（实验版本）；
- 2019年3月 JDK 12 增强了 G1，并引入 Shenandoah GC（实验版本）；
- 2019年9月 JDK 13 增强了 ZGC；
- 2020年3月 JDK 14 删除了 CMS，拓展 ZGC 在 MacOS 和 Windows 上的应用；



### Serial收集器

单线程收集器，使用一个GC线程去完成垃圾收集工作，而且在进行垃圾收集工作的时候必须要暂停用户线程，直到收集结束。

新生代采用复制算法，老年代采用标记-整理算法；

使用参数 `-XX:+UseSerialGC -XX:+UseSerialOldGC` 开启Serial收集器；



### ParallelScavenge收集器（吞吐量优先）

是**<u>Serial</u>**收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。

默认的收集线程数跟 CPU 核数相同，当然也可以用参数（`-XX:ParallelGCThreads`）指定收集线程数，但是一般不推荐修改；

Parallel Scavenge收集器关注点是吞吐量；

新生代采用复制算法，老年代采用标记-整理算法；

使用参数 `-XX:+UseParallelGC,-XX:+UseParallelOldGC` 开启



### ParNew收集器（吞吐量优先）

ParNew收集器跟Parallel Scavenge收集器很类似，但只有ParNew可以和CMS收集器配合使用。

ParNew是许多运行在Server模式的虚拟机的首选，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器）配合工作。

新生代采用复制算法，老年代采用标记-整理算法。

使用参数 `-XX:+UseParNewGC` 开启ParNew收集器；



### SerialOld收集器

是**<u>Serial</u>**垃圾收集器**<u>老年代</u>**版本，同样是单线程的收集器，使用**<u>标记-整理算法</u>**，主要运行在**<u>Client</u>**模式的**<u>JVM</u>**中。

在**<u>Server</u>**模式下，主要有两个用途：

- 在**<u>JDK1.5</u>**之前的版本中与**<u>新生代</u>**的**<u>Parallel Scavenge</u>**收集器搭配使用（即**<u>Parallel Scavenge + Serial Old</u>**）；

- 作为**<u>老年代</u>**版中使用**<u>CMS</u>**收集器的后备方案；



### ParallelOld收集器

是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供使用；

在JDK1.6之前是Parallel Scavenge（新生代）+ SerialOld（老年代）；

Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器。

JDK1.8后Parallel Scavenge（新生代） + ParallelOld（老年代）；

可通过`-XX:+UseParallelOldGC`参数使用ParallelOld收集器，即Parallel（新生代）+ParallelOld（老年代）；



### CMS收集器（停顿时间优先）

CMS收集器是⼀种以获取最短回收停顿时间为⽬标的收集器，第⼀次实现了让GC线程与⽤户线程同时⼯作，采用并发收集策略，且停顿时间少。

适合在内存较大、CPU核数多的服务器上运行；

**步骤：**

- 初始标记

  标记GC Roots能直接关联的对象，速度很快，但会存在STW时间；

- 并发标记

  同时启动GC线程和用户线程⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。

  因为⽤户线程可能会不断的引用更新，所以GC线程⽆法保证可达性分析的实时性，这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅；

- 重新标记

  为了修正并发标记期间因用户线程运行而产生变动的那部分对象的标记记录，STW时间⼀般会⽐初始标记阶段的时间稍⻓，但远⽐并发标记阶段时间短；

- 并发清除

  启动用户线程，同时GC线程对未标记的区域进行清扫；

**缺点：**

- 对CPU资源要求高；
- 无法处理浮动垃圾（在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次GC再清理了）；
- 使用标记-清除算法会产生大量内存空间碎片；
- 执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收一边运行，也许没回收完就会再次触发FullGC，也就是concurrent mode failure，此时会进入STW，退化成用Serial Old GC；



### G1收集器

全称Garbage-First，在JDK1.7u4中新增的收集器，目标是取代CMS收集器，是⼀款⾯向服务器的垃圾收集器，可充分服务器CPU与内存，极大的减少垃圾收集的停顿时间，全面提升服务器的性能。

主要改变是Eden，Survivor和老年代等区域不再是连续的了，而是将堆划分成了多个大小一样的region，这些region的一部分包含在新生代中，新生代的垃圾收集依然采用暂停所有用户线程的方式，将存活对象拷贝到老年代或Survivor空间；

这些region的一部分包含在老年代中，收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。意思是在正常的处理过程中完成了对堆的压缩（至少是部分堆的压缩），这样也就不会有内存碎片问题的存在了；

G1收集器后台维护了一个优先列表，每次根据设置的收集时间，优先回收价值最大的块，这也就是Garbage-First的由来，这种以region划分内存空间，以及有优先级的区域回收方式，保证了G1收集器能在有限时间内尽可能提高收集效率；

工作步骤：

- 初始标记

  仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象（需要线程停顿，但耗时很短）；

- 并发标记

  从GC Roots开始对堆中对象进行可达性分析，找出存活对象（耗时较长，但可与用户线程并发执行）；

- 最终标记

  为了修正在并发标记期间，因用户线程执行而导致标记产生变化的那一部分标记记录，且对象的变化记录在线程Remembered Set Logs里面，把里面的数据合并到Remembered Set中（需要线程停顿，但可并行执行）；

- 筛选回收

  对各个region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划（可并发执行）；

拥有优势：

- 并发：多个线程并发执行GC来减少STW时间；
- 并行：GC线程和用户线程可同时运行；
- 分代收集：虽然G1不需要其它的收集器配合就能管理整个的GC堆，但是还是保留了分代的概念；
- 空间的整合：采用标记-整理算法，从局部上来看是基于复制算法实现，这二个算法都不会产生内存碎片，收集后提供规整可用的内存空间；
- 可预测的停顿：建立了一个可预测的STW时间模型，会将STW时间控制在用户指定的时间内（单位毫秒）；
- 对堆内存要求不高；

**相关参数：**

可通过 `-XX:G1HeapRegionSize=n` 参数设置大小（1MB~32MB，且必须是2的幂）默认将整堆划分为2048个分区，即能够支持的最大内存为：32MB*2048=65536MB=64G内存。

| 参数                                        | 新生代垃圾收集器          | 新生代算法                              | 老年代垃圾收集器                                             | 老年代算法 |
| ------------------------------------------- | ------------------------- | --------------------------------------- | ------------------------------------------------------------ | ---------- |
| -XX:+UseSerialGC                            | SerialGC                  | 复制                                    | SerialOldGC                                                  | 标整       |
| -XX:+UseParNewGC                            | ParNew                    | 复制                                    | SerialOldGC                                                  | 标整       |
| -XX:+UseParallelGC<br>-XX:+UseParallelOldGC | Parallel[Scavenge]        | 复制                                    | ParallelOld                                                  | 标整       |
| -XX:+UseConcMarkSweepGC                     | ParNew                    | 复制                                    | CMS+SerialOld的收集器组合<br/>(SerialOld作为CMS出错的后备<br/>收集器） | 标清       |
| -XX:+UseG1GC                                | G1整体上采用标记-整理算法 | 局部是通过复制算法<br/>不会产生内存碎片 |                                                              |            |



## 对象回收过程

参考文档：<a href="https://blog.csdn.net/reliveIT/article/details/116307562">对象回收过程</a>

java.lang.ref包的结构如下图所示，其中Finalizer类是FinalReference（都表示强引用类型）的子类，且该类被final关键字修饰。

![包结构](./01.Java_part1.assets/fianlizerPkg.png)

对象回收步骤：

1. 启动回收线程

   虚拟机启动时，在Finalizer类被加载的阶段，会通过一个静态代码，去创建一个FinalizerThread守护线程（优先级是8），该线程用来消费被回收的对象；

2. 注册对象

   每当JVM创建一个对象时，会调用Finalizer.register(Object o)方法对那些已实现了finalize()方法（必须是非空方法）的类实例化一个Finalizer对象；

   调用Finalizer.register(Object o)方法的时间点可使用 `-XX:+RegisterFinalizersAtInit` 参数设置，默认为true表示在构造方法返回之前调用Finalizer.register(Object o)方法，false表示在对象分配好内存空间时（最后一步）调用 `Finalizer.register(Object o)` 方法；

3. 注销注册

   在执行GC时，如果对象为不可达时（即Finalizer中的referent失去强引用后），就会将Finalizer挂到pending-reference list中，随后ReferenceHandler线程从pending-reference list取走Finalizer对象，并将其放入Finalizer.queue阻塞队列中，并通知FinalizerThread去消费；

4. 执行finalize()方法

   FinalizerThread线程后会从Finalizer.queue阻塞队列拿出要被回收的对象，执行finalize()方法，并且忽略其抛出的所有异常，再断开Finalizer和referent之间的引用关系，使referent变成真正的不可达状态，此时这个对象叫垃圾对象；

5. 回收对象

   再次发生GC时，执行完finalize()方法的垃圾对象才会被真正回收；



## 参数配置

| 参数                        | **含义**                                                     | **默认值**           | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ |
| -Xms                        | 初始堆大小                                                   | 物理内存的1/64(<1GB) | 默认（MinHeapFreeRatio参数可以调整）空余堆内存小于40%时，<br/>JVM就会增大堆直到-Xmx的最大限制 |
| -Xmx                        | 最大堆大小                                                   | 物理内存的1/4(<1GB)  | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，<br/>JVM会减少堆直到-Xms的最小限制 |
| -Xmn                        | 年轻代大小<br/>(1.4or lator)                                 |                      | 此处的大小是（**<u>Eden</u>**+ 2 survivor space）与jmap -heap中显示的New gen是不同的<br/>整个堆大小=年轻代大小 + 年老代大小 + 持久代大小，增大年轻代后<br/>将会减小年老代大小<br/>此值对系统性能影响较大<br/>Sun官方推荐配置为整个堆的3/8 |
| -XX:NewSize                 | 设置年轻代大小<br/>(for 1.3/1.4)                             |                      |                                                              |
| -XX:MaxNewSize              | 年轻代最大值<br/>(for 1.3/1.4)                               |                      |                                                              |
| -XX:PermSize                | 非堆内存初始值<br/>（PermGen）                               | 物理内存的1/64       |                                                              |
| -XX:MaxPermSize             | 设置持久代最大值                                             | 物理内存的1/4        |                                                              |
| -Xss                        | 每个线程的堆栈大小                                           |                      | JDK5.0以后每个线程堆栈大小为1M<br/>以前每个线程堆栈大小为256K<br/>更具应用的线程所需内存大小进行调整<br/>在相同物理内存下，减小这个值能生成更多的线程<br/>但是操作系统对一个进程内的线程数还是有限制的，<br/>不能无限生成,经验值在3000~5000左右 一般小的应用， <br/>如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。<br/>这个选项对性能影响比较大，需要严格的测试。<br/>（校长） 和threadstacksize选项解释很类似，官方文档似乎没有解释，在论坛中有这样一句话:"-Xss is translated in a VM flag named ThreadStackSize” 一般设置这个值就可以了 |
| -XX:ThreadStackSize         | Thread Stack Size                                            |                      | (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.] |
| -XX:NewRatio                | 年轻代（包括**<u>Eden</u>**和两个Survivor区）与年老代的比值（除去持久代） |                      | -XX:NewRatio=4表示年轻代与年老代所占比值为1:4<br/>年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下<br/>该参数不需要进行设置 |
| -XX:SurvivorRatio           | **<u>Eden</u>**区与Survivor区的大小比值                      | 8                    | 则两个Survivor区与一个**<u>Eden</u>**区的比值为2:8,一个Survivor区占整个年轻代的1/10 |
| -XX:LargePageSizeInBytes    | 内存页的大小不可设置过大， 会影响Perm的大小                  | 128m                 |                                                              |
| -XX:+UseFastAccessorMethods | 原始类型的快速优化                                           |                      |                                                              |
| -XX:+DisableExplicitGC      | 关闭System.gc()                                              |                      | 禁止显式执行GC，不允许通过代码来触发GC                       |
| -XX:MaxTenuringThreshold    | 垃圾最大年龄                                                 |                      | 如果设置为0的话，则年轻代对象不经过Survivor区<br>直接进入年老代<br/>对于年老代比较多的应用，可以提高效率<br/>如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率该参数只有在串行GC时才有效 |
| -XX:+AggressiveOpts         | 加快编译                                                     |                      |                                                              |
| -XX:+UseBiasedLocking       | 锁机制的性能改善                                             |                      |                                                              |
| -Xnoclassgc                 | 禁用垃圾回收                                                 |                      | 是否回收**<u>方法区</u>**中类信息                            |
| -XX:SoftRefLRUPolicyMSPerMB | 每兆堆空闲空间中SoftReference的存活时间                      | 1s                   | softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap |
| -XX:PretenureSizeThreshold  | 对象超过多大是直接在旧生代分配                               | 0                    | 单位字节<br/>新生代采用Parallel Scavenge GC时无效，<br/>另一种直接在旧生代分配的情况是大的数组对象，<br/>且数组中无外部引用对象 |
| -XX:TLABWasteTargetPercent  | TLAB占eden区的百分比                                         | 1%                   |                                                              |
| -XX:+CollectGen0First       | FullGC时是否先YGC                                            | false                |                                                              |

**并行收集器相关参数**

| 参数                       | 含义                                                   | 默认 | 说明                                                         |
| -------------------------- | ------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| -XX:+UseParallelGC         | FullGC采用ParallelMSC                                  |      | 选择垃圾收集器为并行收集器<br/>此配置仅对年轻代有效<br/>即上述配置下<br>年轻代使用并发收集<br/>而年老代仍旧使用串行收集 |
| -XX:+UseParNewGC           | 设置年轻代为并行收集                                   |      | 可与CMS收集同时使用JDK5.0以上<br/>JVM会根据系统配置自行设置<br/>所以无需再设置此值 |
| -XX:ParallelGCThreads      | 并行收集器的线程数                                     |      | 此值最好配置与处理器数目相等<br/>同样适用于CMS               |
| -XX:+UseParallelOldGC      | 年老代垃圾收集方式为并行收集<br/>(Parallel Compacting) |      | 这个是JAVA6出现的参数选项                                    |
| -XX:MaxGCPauseMillis       | 每次年轻代垃圾回收的最长时间<br/>（最大暂停时间）      |      | 如果无法满足此时间，<br/>JVM会自动调整年轻代大小，<br/>以满足此值 |
| -XX:+UseAdaptiveSizePolicy | 自动选择<br/>年轻代区大小和<br/>相应的Survivor区比例   |      | 设置此选项后，<br/>并行收集器会自动选择<br/>年轻代区大小和相应的Survivor区比例，<br/>以达到目标系统规定的最低相应时间或者收集频率等，<br/>此值建议使用并行收集器时，一直打开 |
| -XX:GCTimeRatio            | 设置垃圾回收时间<br/>占程序运行时间的百分比            |      | 公式为1/(1+n)                                                |
| -XX:+ScavengeBeforeFullGC  | FullGC前调用YGC                                        | true | Do young generation GC prior to a full GC<br/> (Introduced in 1.4.1.) |

**CMS相关参数**

| 参数                                   | 含义                                          | 默认值 | 说明                                                         |
| -------------------------------------- | --------------------------------------------- | ------ | ------------------------------------------------------------ |
| -XX:+UseConcMarkSweepGC                | 使用CMS内存收集                               |        | 测试中配置这个以后-XX:NewRatio=4的配置失效了，<br>原因不明   |
| -XX:+AggressiveHeap                    |                                               |        | 试图是使用大量的物理内存长时间大内存使用的优化，<br>能检查计算资源（内存， 处理器数量）<br/>至少需要256MB内存大量的CPU／内存，<br/>（在1.4.1在4CPU的机器上已经显示有提升） |
| -XX:CMSFullGCsBeforeCompaction         | 多少次后进行内存压缩                          |        | 由于并发收集器不对内存空间进行压缩、整理<br/>所以运行一段时间以后会产生**内存碎片**，<br/>使得运行效率降低<br/>此值设置运行多少次GC以后对内存空间进行<br/>压缩、整理； |
| -XX:+CMSParallelRemarkEnabled          | 降低标记停顿                                  |        |                                                              |
| -XX+UseCMSCompactAtFullCollection      | 在FullGC的时候， 对年老代的压缩               |        | CMS是不会移动内存的；<br/>因此这个非常容易产生碎片， 导致内存不够用，<br/>因此， 内存的压缩这个时候就会被启用。 <br/>增加这个参数是个好习惯。 <br/>可能会影响性能,但是可以消除碎片 |
| -XX:+UseCMSInitiatingOccupancyOnly     | 使用手动定义初始化定义开始CMS收集             |        | 禁止hostspot自行触发CMS GC                                   |
| -XX:CMSInitiatingOccupancyFraction     | 使用CMS作为垃圾回收使用70％<br/>后开始CMS收集 | 92     | 为了保证不出现promotion failed（见下面介绍）错误<br>该值的设置需要满足以下公式**<br/>[CMSInitiatingOccupancyFraction计算公式](https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value)** |
| -XX:CMSInitiatingPermOccupancyFraction | 设置PermGen使用到达<br/>多少比率时触发        | 92     |                                                              |
| -XX:+CMSIncrementalMode                | 设置为增量模式                                |        | 用于单CPU情况                                                |
| -XX:+CMSClassUnloadingEnabled          |                                               |        |                                                              |

**辅助信息**

| 参数                                  | 含义                                                         | 默认值 | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| -XX:+PrintGC                          |                                                              |        | 输出形式：<br/>[GC 118250K->113543K(130112K), 0.0094143 secs] <br/>[Full GC 121376K->10414K(130112K), 0.0650971 secs] |
| -XX:+PrintGCDetails                   |                                                              |        | 输出形式：<br/>[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] <br/>118250K->113543K(130112K), 0.0124633 secs] <br/>[GC DefNew: 8614K->8614K(9088K), 0.0000665 secs 121376K->10414K(130112K), 0.0436268 secs]<br>可通过打印的GC日志的新生代、老年代名称判断 |
| -XX:+PrintCommandLineFlagsjvm         |                                                              |        | 参数可查看默认设置收集器类型                                 |
| -XX:+PrintGCTimeStamps                |                                                              |        |                                                              |
| -XX:+PrintGC:PrintGCTimeStamps        |                                                              |        | 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用<br/>输出形式：<br/>11.851: [GC 98328K->93620K(130112K), 0.0082960 secs] |
| -XX:+PrintGCApplicationStoppedTime    | 打印垃圾回收期间程序暂停的时间<br/>可与上面混合使用          |        | 输出形式：<br>Total time for which application threads were stopped: 0.0468229 seconds |
| -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前，<br/>程序未中断的执行时间<br/>可与上面混合使用 |        | 输出形式：<br/>Application time: 0.5291524 seconds           |
| -XX:+PrintHeapAtGC                    | 打印GC前后的详细堆栈信息                                     |        |                                                              |
| -Xloggc:filename                      | 把相关日志信息记录到文件以便分析<br/>与上面几个配合使用      |        |                                                              |
| -XX:+PrintClassHistogram              | garbage collects before printing the histogram.              |        |                                                              |
| -XX:+PrintTLAB                        | 查看TLAB空间的使用情况                                       |        |                                                              |
| XX:+PrintTenuringDistribution         | 查看每次minor GC后新的存活周期的阈值                         |        | Desired survivor size 1048576 bytes，new threshold 7 (max 15) new threshold 7即标识新的存活周期的阈值为7 |



------



# 集合框架

![JavaCollectionFrame0](./01.Java_part1.assets/JavaCollectionFrame0.png)

## Collection接口

Collection接口是集合的顶层接口，用于描述一组元素。

| 方法                      |    返回值    | 说明                                                         |
| ------------------------- | :----------: | ------------------------------------------------------------ |
| add(E e)                  |   boolean    | 添加一个元素到集合；<br>如果集合中元素被添加操作改变了，则返回 true |
| addAll(Collection c)      |   boolean    | 添加一个集合中所有元素到当前集合中；<br/>如果集合中元素被添加操作改变了，则返回 true |
| clear()                   |     void     | 清除当前集合中所有元素，使集合长度变为0                      |
| contains(Object o)        |   boolean    | 判断当前集合中是否包含指定元素参数；<br/>如果已存在返回true  |
| containsAll(Collection c) |   boolean    | 判断当前集合中是否包含参数集合中的所有元素<br/>如果已存在返回true |
| isEmpty()                 |   boolean    | 判断当前集合是否为空；<br/>如果集合中没有任何元素，返回true  |
| iterator()                | Iterator\<E> | 返回一个迭代器对象，用于遍历集合中的元素                     |
| remove(Object o)          |   boolean    | 从当前集合中删除指定的元素；<br/>如果当集合中包含了多个重复的元素o时，则只删除第一个符合条件的元素；<br/>删除成功返回true； |
| removeAll(Collection c)   |   boolean    | 从当前集合中删除参数集合中的所有元素；<br/>如果该方法改变了当前集合中的元素，返回true |
| retainAll(Collection c)   |   boolean    | 从当前集合中删除不在参数集合范围内的元素；<br/>相当于只保留当前集合与参数集合的交集，其他元素全部删掉；<br/>如果该操作改变了当前集合中的元素，返回true |
| size()                    |     int      | 返回集合中元素的个数                                         |
| toArray()                 |   Object[]   | 把集合中的元素复制到数组中                                   |



## Set接口

Set接口具有与Collection接口完全一样的方法，只是行为上不同，Set中没有重复的元素。



## SortedSet（有序Set接口）

继承自 Set 接口，保持有序集合。

| 方法                                              | 返回值                | 说明                                                         |
| ------------------------------------------------- | --------------------- | ------------------------------------------------------------ |
| comparator()                                      | Comparator<? super E> | 返回集合中的元素排序的比较器；<br>如果此集合使用的是自然排序，则返回null |
| subSet(<br/>E fromElement, <br/>E toElement<br/>) | SortedSet\<E>         | 返回集合中元素范围从fromElement（含）到toElement（不含）的部分元素视图；<br/>如果fromElement和toElement相等，则返回的集合为空；<br/>返回的子集合由当前父集合支持，因此返回集合中的更改反映在父集合中，反之亦然； |
| headSet(<br/>E toElement<br/>)                    | SortedSet\<E>         | 返回集合中元素值**小于**参数toElement的部分元素视图；<br/>返回的子集合由当前父集合支持，因此返回集合中的更改反映在父集合中，反之亦然； |
| tailSet(<br/>E fromElement<br/>)                  | SortedSet\<E>         | 返回此集合中元素**大于等于**参数fromElement的部分元素视图；<br/>返回的子集合由当前父集合支持，因此返回集合中的更改反映在父集合中，反之亦然； |
| first()                                           | \<E>                  | 返回此集合的第一个（最小值）元素                             |
| last()                                            | \<E>                  | 返回此集合的最后一个（最大值）元素                           |
| spliterator()                                     | Spliterator\<E>       | 返回有序集合中元素的迭代器；<br/>迭代器特性：Spliterator.DISTINCT、Spliteratr.SORTED和Spliterater.ORDERED；<br/>如果集合的Comparator为空，则迭代器的Comparator为空；<br/>否则，迭代器的Comparator与集合的Comparator相同或有相同的排序规则； |



## List接口

List接口继承自Collection接口，但还包括如下方法：

| 方法                                                        | 返回值           | 说明                                                         |
| ----------------------------------------------------------- | ---------------- | ------------------------------------------------------------ |
| addAll(<br/>int index, <br/>Collection<? extends E> c<br/>) | boolean          | 将**参数集合**中所有元素添加到当前集合的指定位置上；<br>index：当前集合的位置，从0开始；<br>c：参数集合；<br/>如果集合中元素被添加操作改变了，则返回true； |
| get(<br/>int index<br/>)                                    | \<E>             | 返回集合中指定位置上的元素；<br/>index：当前集合的位置，从0开始； |
| set(<br/>int index, <br/>E element<br/>)                    | \<E>             | 更新集合中指定位置上的元素；<br/>index：当前集合的位置，从0开始；<br/>element：元素；<br/>返回更新之前指定位置上的元素； |
| add(<br/>int index, <br/>E element<br/>)                    | void             | 在集合的指定位置上插入一个元素；<br/>index：当前集合的位置，从0开始；<br/>element：元素； |
| remove(<br/>int index<br/>)                                 | \<E>             | 删除集合中指定位置上的元素；<br/>index：当前集合的位置，从0开始；<br/>返回被删除的元素； |
| indexOf(<br/>Object o<br/>)                                 | int              | 从集合的首端向末端进行查找，查找参数在当前集合中的位置信息；<br/>o：元素信息；<br/>返回集合中元素位置信息，若未找到返回-1； |
| lastIndexOf(<br/>Object o<br/>)                             | int              | 从集合的末端向首端进行查找，查找参数在当前集合中的位置信息；<br/>o：元素信息<br/>返回集合中元素位置信息，若未找到返回-1； |
| listIterator()                                              | ListIterator\<E> | 返回集合元素的迭代器                                         |
| listIterator(<br/>int index<br/>)                           | ListIterator\<E> | 返回集合元素的迭代器；<br/>index：开始迭代集合元素的位置信息 |
| subList(<br/>int fromIndex, <br/>int toIndex<br/>)          | List\<E>         | 返回当前集合中部分数据的**视图**对象；<br/>结果集包含 fromlndex（含） 和 tolndex（不含）之间的所有元素；<br/>返回的子集合由当前父集合支持，因此返回集合中的更改反映在父集合中，反之亦然； |
| replaceAll(<br/>UnaryOperator<E> operator<br/>)             | void             | 用函数接口的返回结果替代原list中的值<br>`replaceAll(t -> t + 1);`表示集合中每个元素值加一； |
| sort(<br/>Comparator<? super E> c<br/>)                     | void             | 使用指定排序规则，对集合中元素排序；                         |
| spliterator()                                               | Spliterator\<E>  | 返回一个可分割迭代器                                         |



## Map接口

叫哈希表、散列表，用于存储键-值对数据（key-value），其中键（key）不允许重复，但值（value）可以重复。

| 方法                                                         |        返回值        | 说明                                                         |
| ------------------------------------------------------------ | :------------------: | ------------------------------------------------------------ |
| clear()                                                      |         void         | 删除集合中的所有键-值对                                      |
| containsKey(<br/>Object key<br/>)                            |       boolean        | 判断集合中是否包含指定的**键**；<br/>如果包含返回true，否则返回false； |
| containsValue(<br/>Object value<br/>)                        |       boolean        | 判断集合的键-值对中，是否有与参数value相等的**值**；<br/>如果包含返回true，否则返回false； |
| get(Object key)                                              |         \<V>         | 返回集合中指定**键**对应的值；<br/>key：键；<br/>返回集合中与参数key对应的值； |
| put(K key, V value)                                          |         \<V>         | 向集合中添加一个键-值对；<br/>key：键；<br/>value：值；<br/>如果集合中已有与参数key相同的键-值对时，<br/>则会覆盖原来的键-值对，并返回替换前的键-值对； |
| putAll(Map m)                                                |         void         | 将参数集合中所有键-值对添加到当前集合中；<br/>m：键-值对集合； |
| remove(Object key)                                           |         \<V>         | 从集合中删除参数中键信息对应的键-值对；<br/>返回被删除键-值对中的值；<br/>如果集合中不存在键信息对应的键-值对，则返回null；<br/>key：键信息； |
| remove(<br/>Object key, <br/>Object value<br/>)              |       boolean        | **JDK8**新特性；<br/>删除集合中与参数key和value相等的键-值对；<br/>key：键；<br/>value：值；<br/>删除成功返回true，否则返回false； |
| entrySet()                                                   | Set<Map.Entry<K, V>> | 返回集合中所有键-值对的Set视图；<br/>对Set视图的更改会反映在Map集合中，反之亦然； |
| keySet()                                                     |       Set\<K>        | 返回集合中所有键的视图；<br/>对视图的更改会反映在Map集合中，反之亦然； |
| values()                                                     |    Collection\<V>    | 返回集合中所有值的视图；<br/>对视图的更改会反映在Map集合中，反之亦然； |
| isEmpty()                                                    |       boolean        | 判断集合是否为空（即不包含任何键-值对）；<br/>如果为空返回true； |
| size()                                                       |         int          | 返回集合中键-值对的个数                                      |
| equals(<br/>Object o<br/>)                                   |       boolean        | 判断参数对象与当前集合是否完全相等；<br>如果类型相同、键-值对个数相等、键-值对完全相等，则返回true； |
| hashCode()                                                   |         int          | 返回集合的哈希值，规则：<br/><img src="./01.Java_part1.assets/JavaMapFrame_1.png" alt="JavaMapFrame_1" style="zoom:50%;" /> |
| getOrDefault(<br>Object key, <br/>V defaultValue<br/>)       |         \<V>         | 返回集合指定键对应的值；<br/>如果集合中不包含指定的键-值对，则返回默认值defaultValue；<br/>key：键；<br/>defaultValue：默认值；<br/>返回参数key对应的值； |
| putIfAbsent(<br/>K key, <br/>V value<br/>)                   |         \<V>         | 如果集合中不包含指定键或键-值对中值为null时，<br/>就将参数key-value作为键-值对添加到集合中；<br/>如果集合中包含指定键，则直接退出方法；<br/>key：键；<br/>value：默认值；<br/>返回参数key对应的值； |
| remove(<br/>Object key, <br/>Object value<br/>)              |       boolean        | 删除集合中与参数key和value相等的键-值对；<br/>key：键；<br/>value：默认值；<br/>删除成功返回true，否则返回false； |
| replace(<br/>K key, <br/>V oldValue, <br/>V newValue<br/>)   |       boolean        | 将集合中与参数key和oldValue相等的键-值对，替换为新值newValue；<br/>key：键；<br/>oldValue：旧值；<br/>newValue：新值；<br/>替换成功返回true，否则返回false； |
| replace(<br/>K key, <br/>V value<br/>)                       |         \<V>         | 替换集合中与参数key相等的键-值对中的值，替换为新值value；<br/>key：键；<br/>value：值；<br/>返回被替换的值； |
| forEach(<br/>BiConsumer<br/><? super K, ? super V> <br/>action<br/>) |         void         | 遍历集合中所有键-值对，并执行函数式接口                      |
| replaceAll(<br/>BiFunction<br/><? super K, ? super V, ? extends V> <br/>function<br/>) |         void         | 将集合中每个键-值对替换为，该键-值对调用指定函数式接口的结果 |
| computeIfAbsent(<br/>K key,<br/>Function<br/><? super K, ? extends V> <br/>mappingFunction<br/>) |         \<V>         | 如果指定的键对应的值为null（没有该键或该键对应的值是null）<br/>那么使用函数式接口计算该键的值，并计算后的值添加到集合中；<br/>key：键；<br/>mappingFunction：函数式接口；<br/>返回键对应的值； |
| computeIfPresent(<br/>K key,<br/>BiFunction<br/><? super K, ? super V, ? extends V><br/>remappingFunction<br/>) |         \<V>         | 如果指定的键对应的值不存在，则返回null；<br/>如果指定的键对应的值存在，根据键-值对带入函数式接口计算得到新值；<br/>如果新值为null，则从集合中删除该键-值对，并返回null；<br/>如果新值不为null，则用新值更新到集合中，并返回新值；<br/>key：键；<br/>remappingFunction：函数式接口； |
| compute(<br/>K key,<br/>BiFunction<br/><? super K, ? super V, ? extends V><br/>remappingFunction<br/>) |         \<V>         | 根据集合中键-值对，使用函数式接口计算得到新值；<br/>如果新值为null，则从集合中删除该键-值对，并返回null；<br/>如果新值不为null，则用新值更新到集合中，并返回新值；<br/>key：键；<br/>remappingFunction：函数式接口； |
| merge(<br/>K key, <br/>V value,<br/>BiFunction<br/><? super V, ? super V, ? extends V><br/>remappingFunction<br/>) |         \<V>         | 如果集合中不存在指定键（或值为null），则删除键-值对，返回参数value；<br/>如果集合中存在指定键，则根据参数value与集合中的值代入函数式接口计算得到一个新值；<br/>如果新值为null，则删除集合中的键-值对，返回null；<br/>如果新值不为null，则将新值更新到集合中，返回新值；<br/>key：键；<br/>value：默认值；<br/>remappingFunction：函数式接口； |



## Map.Entry<K,V>

| 方法                                        | 返回值                      | 说明                                                         |
| ------------------------------------------- | --------------------------- | ------------------------------------------------------------ |
| getKey()                                    | \<K>                        | 返回键信息                                                   |
| getValue()                                  | \<V>                        | 返回值信息                                                   |
| setValue(V value)                           | \<V>                        | 更新值信息                                                   |
| equals(Object o)                            | boolean                     | 判断键-值对与参数对象是否相等，规则如下：<br/><img src="./01.Java_part1.assets/JavaMapFrame_2.png" alt="JavaMapFrame_2" style="zoom:50%;" /> |
| hashCode()                                  | int                         | 返回集合的哈希值，规则：<br/><img src="./01.Java_part1.assets/JavaMapFrame_1.png" alt="JavaMapFrame_1" style="zoom:50%;" /> |
| comparingByKey()                            | Comparator<Map.Entry<K,V>>  | 静态方法；<br/>返回Map.Entry比较规则（键的自然顺序比较）；<br/>返回的比较器是支持可序列化；<br/>返回的比较器参数不支持null，否则抛出NullPointerException |
| comparingByValue()                          | Comparator<Map.Entry<K,V>>  | 静态方法；<br/>返回Map.Entry比较规则（值的自然顺序比较）；<br/>返回的比较器是支持可序列化；<br/>返回的比较器参数不支持null，否则抛出NullPointerException |
| comparingByKey(Comparator<? super K> cmp)   | Comparator<Map.Entry<K, V>> | 静态方法<br/>返回Map.Entry比较规则（键的自然顺序比较）<br/>返回的比较器使用参数cmp用来比较参数<br>返回的比较器是支持可序列化；<br/>返回的比较器参数不支持null，否则抛出NullPointerException |
| comparingByValue(Comparator<? super V> cmp) | Comparator<Map.Entry<K, V>> | 静态方法；<br/>返回Map.Entry比较规则（值的自然顺序比较）；<br/>返回的比较器使用参数cmp用来比较参数<br/>返回的比较器是支持可序列化；<br/>返回的比较器参数不支持null，否则抛出NullPointerException |



## ConcurrentMap<K, V>

继承自Map接口，表示支持高并发情况下线程安全保证的Map。



## SortedMap（有序Map接口）

继承自Map接口，使键（key）保持有序排列。

| 方法                       | 返回值                | 说明                                                         |
| -------------------------- | --------------------- | ------------------------------------------------------------ |
| comparator()               | Comparator<? super K> | 返回集合中的键排序的比较器；<br/>如果集合使用键的自然排序，则返回null； |
| subMap(K fromKey, K toKey) | SortedMap<K,V>        | 返回集合中部分数据的视图，键范围从fromKey（包含）到toKey（不包含）；<br/>如果fromKey和toKey相等，则返回的映射为空；<br/>返回的子集合由当前父集合支持，因此返回集合中的更改反映在父集合中，反之亦然；<br/>当超出范围之外截取集合时，会抛出IllegalArgumentException |
| headMap(K toKey)           | SortedMap<K,V>        | 返回集合中键**小于**toKey的数据视图；<br/>返回的子集合由当前父集合支持，因此返回集合中的更改反映在父集合中，反之亦然；<br/>当超出范围之外截取集合时，会抛出IllegalArgumentException |
| tailMap(K fromKey)         | SortedMap<K,V>        | 返回集合中键大于等于fromKey的数据视图；<br/>返回的子集合由当前父集合支持，因此返回集合中的更改反映在父集合中，反之亦然；<br/>当超出范围之外截取集合时，会抛出IllegalArgumentException |
| firstKey()                 | \<K>                  | 返回集合中第一个（最小的）键；                               |
| lastKey()                  | \<K>                  | 返回集合中最后一个（最大的）键；                             |



## NavigableMap<K,V>

继承自SortedMap接口，带导航功能。

| 方法                                                         | 返回值            | 说明                                                         |
| ------------------------------------------------------------ | ----------------- | ------------------------------------------------------------ |
| lowerEntry(K key)                                            | Map.Entry<K,V>    | 返回小于且最接近key的键-值对（不包含等于) ；<br/>key：键；   |
| lowerKey(K key)                                              | \<K>              | 返回小于且最接近key的键（不包含等于) ；<br/>key：键；        |
| floorEntry(K key)                                            | Map.Entry<K,V>    | 返回小于等于，最接近key的键-值对；<br/>key：键；             |
| floorKey(K key)                                              | \<K>              | 返回小于等于，最接近key的键；<br/>key：键；                  |
| ceilingEntry(K key)                                          | Map.Entry<K,V>    | 返回最接近的大于等于key的键-值对；<br/>key：键；             |
| ceilingKey(K key)                                            | \<K>              | 返回最接近的大于等于key的键；<br/>key：键；                  |
| higherEntry(K key)                                           | Map.Entry<K,V>    | 返回最接近的大于key的键-值对；<br/>key：键；                 |
| higherKey(K key)                                             | \<K>              | 返回最接近的大于key的键；<br/>key：键；                      |
| firstEntry()                                                 | Map.Entry<K,V>    | 返回Map中最小键所在的键-值对Entry；<br/>如果键-值对为空，则返回null； |
| lastEntry()                                                  | Map.Entry<K,V>    | 返回Map中最大键所在的键-值对Entry；<br/>如果键-值对为空，则返回null； |
| pollFirstEntry()                                             | Map.Entry<K,V>    | 移除并返回Map中最小键所在的键-值对Entry；<br/>如果键值对为空，则返回null； |
| pollLastEntry()                                              | Map.Entry<K,V>    | 移除并返回Map中最大键所在的键-值对Entry；<br/>如果键值对为空，则返回null； |
| descendingMap()                                              | NavigableMap<K,V> | 返回一个与原map反向顺序的视图，仍然是同一个map，操作会互相影响 |
| navigableKeySet()                                            | NavigableSet\<K>  | 返回Map中包含的键的NavigableSet集合；                        |
| descendingKeySet()                                           | NavigableSet\<K>  | 返回一个所有key键的视图，顺序是倒序；                        |
| subMap(<br>K fromKey, <br/>boolean fromInclusive,<br/>K toKey,   <br/>boolean toInclusive<br/>) | NavigableMap<K,V> | 返回fromKey到toKey的map视图；<br>仍然是同一个map，操作会互相影响；<br/>fromKey：开始键；<br/>fromInclusive：true表示包含；<br/>toKey：结束键；<br/>toInclusive：true表示包含； |
| headMap(K toKey, boolean inclusive)                          | NavigableMap<K,V> | 返回小于（或等于）参数toKey的键-值对的视图；<br>仍然是同一个map，操作会互相影响；<br>toKey：键值；<br/>inclusive：true表示小于等于； |
| tailMap(K fromKey, boolean inclusive)                        | NavigableMap<K,V> | 返回大于（或等于）参数fromKey的键-值对的视图；<br/>仍然是同一个map，操作会互相影响；<br/>fromKey：键值；<br/>inclusive：true表示大于等于； |



## Queue（队列接口）

队列是先进先出（First In First Out，FIFO）的线性表，只允许在队列的一端进行插入，而在队列的另一端进行删除。向队列中插入元素称为入队，删除元素称为出队。队列可分为阻塞队列/非阻塞队列、有界队列/无界队列、单向链表/双向链表。

![JavaQueueFrame_1](./01.Java_part1.assets/JavaQueueFrame_1.png)

| 方法       | 返回值  | 说明                                                         |
| ---------- | ------- | ------------------------------------------------------------ |
| add(E e)   | boolean | 添加一个元素；<br>如果队列已满，则抛出IIIegaISlabEepeplian异常； |
| offer(E e) | boolean | 添加一个元素；<br/>如果添加成功返回true；<br/>如果添加失败返回false； |
| remove()   | \<E>    | 从队列中删除并返回队列头部的元素；<br/>如果队列为空，则抛出NoSuchElementException异常； |
| poll()     | \<E>    | 从队列中删除并返回队列头部的元素；<br/>如果队列为空，则返回null； |
| element()  | \<E>    | 返回队列头部的元素；<br/>如果队列为空，则抛出NoSuchElementException异常； |
| peek()     | \<E>    | 返回队列头部的元素；<br/>如果队列为空，则返回null            |



## BlockingQueue（阻塞队列接口）

阻塞队列添加空值（null）会抛出 NullPointerException。

阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。

入队：如果元素数量超过队列总数，会使阻塞线程，等待队列的中的元素出列后，元素数量未超过队列总数时，就会解除阻塞状态，进而可以继续入列。

出队：如果队列为空的情况下，也会进行等待（阻塞），待队列有值的时候即会解除阻塞状态，进而继续出列。

| 方法                                                         | 返回值  | 说明                                                         |
| ------------------------------------------------------------ | :-----: | ------------------------------------------------------------ |
| put(E e)                                                     |  void   | 将参数对象插入到阻塞队列中；<br/>当队列容量已满，无法容纳新插入的元素时，就阻塞队列直到空出容量后执行；<br>中断等待线程，会抛出异常；<br/>e：待插入的对象； |
| offer(<br/>E e,<br/>long timeout,<br/>TimeUnit unit<br/>)    | boolean | 将参数对象插入到阻塞队列中；<br/>当队列容量已满，无法容纳新插入的元素时，就阻塞队列直到空出容量或等待超时后执行；<br/>中断等待线程，会抛出异常；<br/>e：待插入的对象；<br/>timeout：超时等待时间；<br/>unit：时间单位；<br/>如果成功返回true； |
| take()                                                       |  \<E>   | 返回并删除队列的头元素；<br>当队列容量已满，无法容纳新插入的元素时，就阻塞队列直到空出容量后执行； |
| poll(<br/>long timeout,<br/>TimeUnit unit<br/>)              |  \<E>   | 返回并删除此队列的头元素；<br>当队列容量已满，无法容纳新插入的元素时，就阻塞队列直到空出容量或等待超时后执行；<br/>timeout：超时等待时间；<br/>unit：时间单位；<br/>返回队列的头元素； |
| remainingCapacity()                                          |   int   | 返回队列的可用容量；<br>如果是有限队列，则返回当前能够接受而不阻塞的元素数量；<br>如果队列容量没有限制，则返回Integer.MAX_VALUE； |
| drainTo(<br/>Collection<? super E> c<br/>)                   |   int   | 从队列中移除所有可用的元素，并将被移除的元素添加到给定集合中；<br/>c：元素迁移后所在的集合；<br>返回已成功迁移元素的数量； |
| drainTo(<br/>Collection<? super E> c,<br/>int maxElements<br/>) |   int   | 从队列中移除所有可用的元素，并将被移除的元素添加到给定集合中；<br/>c：元素迁移后所在的集合；<br/>maxElements：指定最多迁移多少个元素<br/>返回已成功迁移元素的数量； |



## Deque（双向队列接口）

全称 Double ended queue，队列中元素除了本身之外，还有两个引用，一个引用指向前一个元素，另一个引用指向后一个元素。

![Deque0](./01.Java_part1.assets/JavaDeque_0.png)

| 方法                            | 返回值       | 说明                                   |
| ------------------------------- | ------------ | -------------------------------------- |
| addFirst(E e)                   | void         | 头部插入元素，添加失败抛出异常         |
| addLast(E e)                    | void         | 尾部插入元素，添加失败抛出异常         |
| offerFirst(E e)                 | boolean      | 头部插入元素，添加失败返回false        |
| offerLast(E e)                  | boolean      | 尾部插入元素，添加失败返回false        |
| removeFirst()                   | \<E>         | 删除第一个元素，队列为空抛出异常       |
| removeLast()                    | \<E>         | 删除最后一个元素，队列为空抛出异常     |
| pollFirst()                     | \<E>         | 返回并移除头部的元素，队列为空返回null |
| pollLast()                      | \<E>         | 返回并移除尾部的元素，队列为空返回null |
| getFirst()                      | \<E>         | 返回头部元素，队列为空抛出异常         |
| getLast()                       | \<E>         | 返回尾部的元素，队列为空抛出异常       |
| peekFirst()                     | \<E>         | 返回头部元素，队列为空返回null         |
| peekLast()                      | \<E>         | 返回尾部的元素，队列为空返回null       |
| removeFirstOccurrence(Object o) | boolean      | 删除第一次出现的一个指定对象           |
| removeLastOccurrence(Object o)  | boolean      | 删除最后出现的一个指定对象             |
| push(E e)                       | void         | 头部入栈，添加失败抛出异常             |
| pop()                           | \<E>         | 头部出栈，队列为空抛出异常             |
| descendingIterator()            | Iterator\<E> | 降序迭代器                             |



## RandomAccess（快速随机访问）

是一个标记接口，被标记的集合具备快速随机访问的能力，即可随机访问集合中的任何一个元素，采用for循环遍历集合中元素最快，没有实现 RandomAccess 接口的集合，采用迭代器遍历最快。



## Enumeration（枚举遍历接口）

可以枚举集合中的元素，但不能删除元素，这个接口已被迭代器取代。

| 方法              | 返回值  | 说明                                                         |
| ----------------- | ------- | ------------------------------------------------------------ |
| hasMoreElements() | boolean | 返回true表示集合中还有元素可以读取<br>false表示没有元素可以读取了 |
| nextElement()     | \<E>    | 返回下一个元素，如果集合中没有元素了，则抛出NoSuchElementException异常 |



## Iterator（迭代器接口）

迭代器接口，用于遍历集合中的元素。

| 方法                                        | 返回值  | 说明                                                         |
| ------------------------------------------- | ------- | ------------------------------------------------------------ |
| hasNext()                                   | boolean | 判断迭代器是否能读取到下一个元素<br/>如果支持返回true<br/>如果不支持返回false |
| next()                                      | \<E>    | 返回下一个元素                                               |
| remove()                                    | void    | 删除集合里上一次 next 方法返回的元素                         |
| forEachRemaining(<br/>Consumer action<br/>) | void    | 是Java8新特性，可使用 Lambda 表达式来遍历集合元素            |



## ListIterator（列表迭代器接口）

列表迭代器接口是 Iterator 接口的子接口，支持向前遍历、向后遍历、支持修改元素。

|      方法       | 返回值  | 说明                                                         |
| :-------------: | :-----: | ------------------------------------------------------------ |
|   nextIndex()   |  \<E>   | 返回下一个元素的索引；<br/>如果列表迭代器在列表的结尾，则返回列表的大小； |
|  hasPrevious()  | boolean | 是否有上一个元素<br>有返回true<br>没有返回false              |
|   previous()    |  \<E>   | 返回上一个元素                                               |
| previousIndex() |   int   | 返回上一个元素的索引；<br/>如果列表迭代器在列表的开始，则返回-1 |
|    set(E e)     |  void   | 用参数元素，替换上一次执行next()或previous()方法返回的元素   |
|    add(E e)     |  void   | 将参数元素，插入到集合的当前指针位置处                       |

```java
public class TestListIterator {
	
	public static void main(String[] args) {
		ArrayList<String> arrayList = new ArrayList<String>();
		arrayList.add("first");
		arrayList.add("second");
		arrayList.add("third");
		arrayList.add("fourth");
		arrayList.add("fifth");
		
		ListIterator<String> it = arrayList.listIterator();
		while (it.hasNext()) {
			String removeEle = it.next();
			if ("fourth".equals(removeEle)) {
				it.set("updated fourth");
				it.add("sixth");
			}
		}
		System.out.println("执行上述操作后，arrayList的内容为：" + arrayList);
	}
}
```



## Spliterator（可拆分迭代器接口）

接口是为了并行遍历数据源中的元素而设计的迭代器，功能类似于迭代器 Iterator，但是一个是顺序遍历，一个是并行遍历。

| 方法                                                   |           返回值           | 说明                                                         |
| ------------------------------------------------------ | :------------------------: | ------------------------------------------------------------ |
| tryAdvance(<br/>Consumer<? super T> action<br/>)       |          boolean           | 从迭代器中读取下一个值，如果不存在下一个值，返回false；<br/>如果迭代器成功读取了下一个值，将值代入函数式接口执行计算，返回true；<br/>action：函数式接口； |
| forEachRemaining(<br/>Consumer<? super T> action<br/>) |            void            | 将迭代器中剩余的元素作为参数传给函数式接口执行计算；<br/>action：函数式接口； |
| trySplit()                                             |      Spliterator\<T>       | 将迭代器中**部分元素**移动到一个新迭代器中；<br/>子迭代器可以同时遍历集合中的元素，互不影响；<br/>返回子迭代器对象； |
| estimateSize()                                         |            long            | 返回迭代器中元素总数；<br/>估计值，多线程时可随时发生变化；  |
| getExactSizeIfKnown()                                  |            long            | 如果此迭代器特性为SIZED，则返回estimateSize()方法的值，否则为-1； |
| characteristics()                                      |            int             | 返回代表Spliterator特性的编码；<br>可以根据特性来更好地控制和优化迭代器； |
| hasCharacteristics(<br/>int characteristics<br/>)      |          boolean           | 用于检查分离器是否包含参数指定的特征<br>true：表示分隔符中存在特征，否则返回false |
| getComparator()                                        | Comparator<br/><? super T> | 如果此迭代器的源被Comparator排序，则返回该Comparator；<br/>如果源按自然顺序排序，则返回null；<br/>否则，如果源不是SORTED，则抛出IllegalStateException |

**Spliterator特性值**

| 特性值     |                                                              |
| ---------- | ------------------------------------------------------------ |
| CONCURRENT | 表示当前迭代器的数据源是线程安全的，多个线程可以同时添加、修改、删除； |
| SUBSIZED   | 表示当前迭代器的所有子迭代器，直接或间接的trySplit()，都是SIZED和SUBSIZED的； |
| SIZED      | 表示当前迭代器的元素个数是可计数的，即是有界限的；           |
| SORTED     | 按照某种排序方式的顺序迭代其中的元素，排序规则与getComparator()方法有关； |
| NONNULL    | 表示当前迭代器中的元素是非null的；                           |
| IMMUTABLE  | 表示当前迭代器中的元素是不可以改变的，不能增加、不能替换、不能删除； |
| DISTINCT   | 表示当前迭代器中的元素是没有重复的；                         |
| ORDERED    | 表示当前迭代器需要按照原始的顺序遍历集合中的元素；           |

```java
public class TestListReplaceAll {

	public static void main1(String[] args) {
		List<Integer> numList = new ArrayList<>();
		numList.add(1);
		numList.add(2);
		numList.add(3);
		numList.replaceAll(t -> t + 1); // 遍历每个元素，并执行消费者函数
		if (!numList.toString().equals("[2, 3, 4]")) {
			throw new RuntimeException();
		} else {
			System.out.println("执行完毕!");
		}
	}
  
	public static void main2(String[] args) {
		String[] arr = { "1", "2", "3", "4" };
		Spliterator<String> s1 = Arrays.spliterator(arr);
		Spliterator<String> s2 = s1.trySplit(); // 划分一个小迭代器
		Spliterator<String> s3 = s1.trySplit(); // 划分一个小迭代器
		
		System.out.println("迭代器1");
		System.out.println("size: " + s1.estimateSize());
		while (s1.tryAdvance(System.out::println)) {
		}
		
		System.out.println("迭代器2");
		System.out.println("size: " + s2.estimateSize());
		while (s2.tryAdvance(System.out::println)) {
		}
		
		System.out.println("迭代器3");
		System.out.println("size: " + s3.estimateSize());
		while (s3.tryAdvance(System.out::println)) {
		}
	}
}
```



## Fail-Fast机制

如果在遍历非线程安全的集合元素时，同时有其他线程修改了集合中的元素，那么遍历元素的同时会抛出 ConcurrentModificationException 异常。



## ArrayList（动态数组）

底层是数组实现，可根据需要自动扩展数组的容量。

- 继承自AbstractList ，并实现了List接口；
- 因为是基于数组的实现，内存是连续的，可快速随机访问集合中的元素；
- 这是插入和删除慢、但查询快的数据结构；
- 线程不安全；
- 初始容量为10，容量不够自动增长0.5倍，即新容量变为原容量的1.5倍；
- JDK7的时候执行构造方法时就会初始化数组的长度；
- JDK8的时候只有第一次向数组中添加数据的时候才会初始化数组，相当于懒加载；
- 扩容时将旧数组复制到新数组中，再将旧数组引用指向改为新数组；

| 独有方法                             | 返回值 | 说明                                                         |
| ------------------------------------ | :----: | ------------------------------------------------------------ |
| ArrayList()                          |        | 构造方法<br>初始容量为10                                     |
| ArrayList(int initialCapacity)       |        | 构造方法<br/>initialCapacity：初始容量                       |
| ArrayList(Collection<? extends E> c) |        | 构造方法<br/>c：参数集合中的元素，被添加到当前集合中；<br>初始化完成后，当前集合与参数集合的元素个数相等； |



## LinkedList（双向链表）

LinkedList类实现了List接口、Deque（双向队列）接口、Cloneable接口、Serializable接口。

- 随机访问元素速度相对于数组较慢，使用迭代器遍历元素；
- 添加、删除操作速度相对于数组较快，适合频繁插入与删除元素的场景；
- 不是线程安全的；
- 继承于AbstractSequentialList；
- 包含两个重要的成员header（双向链表的表头）和size（双向链表节点个数）；
- 双向链表节点对应LinkedList.Node类，previous：上一个节点，next：下一个节点，element：元素对象；

| 独有方法                              | 返回值 | 说明                                                         |
| ------------------------------------- | :----: | ------------------------------------------------------------ |
| LinkedList()                          |        | 构造方法                                                     |
| LinkedList(Collection<? extends E> c) |        | 构造方法<br/>c：参数集合中的元素，被添加到当前集合中；<br/>初始化完成后，当前集合与参数集合的元素个数相等； |



## Vector（向量类）

Vector是一个线程安全的动态数组；

- 初始容量是10，没有设置增长因子的话，则以2倍速度增长；


- 可以设置增长因子，而ArrayList不可以；
- 是线程安全的，使用synchronized修饰方法；

- 继承自AbstractList抽象类；

- 实现了List接口；

- 实现了RandmoAccess接口，提供快速访问功能；


- 实现了Cloneable接口，支持clone()方法，但只是复制了原向量数组中的对象引用，并没有实现深拷贝；


- 实现了Serializable接口，因此可以进行序列化；

| 独有方法                                             | 返回值  | 说明                                                         |
| ---------------------------------------------------- | :-----: | ------------------------------------------------------------ |
| Vector()                                             |   无    | 构造方法<br/>初始容量是10                                    |
| Vector(<br/>int size<br/>)                           |   无    | 构造方法<br>参数size：指定初始容量<br/>如果容量不够的话，则将容量翻倍； |
| Vector(<br/>int size,<br/>int incr<br/>)             |   无    | 构造方法<br/>参数size：指定初始容量<br/>参数incr：表示扩容时增加的元素数目 |
| Vector(<br/>Collection c<br/>)                       |   无    | 构造方法<br>参数c：将集合参数中所有元素添加到向量中，初始容量与集合参数一致 |
| addElement(<br>Object element<br/>)                  |  void   | 向量末尾增加一个元素                                         |
| capacity()                                           |   int   | 返回容量大小                                                 |
| copyInto(<br/>Object anArray[]<br/>)                 |  void   | 将向量中的所有元素，复制到数组参数中；<br/>anArray：对象数组； |
| elementAt(<br/>int index<br/>)                       | Object  | index：集合中的位置信息，从0开始；<br/>异常返回指定位置上的元素；<br/>若位置信息非法，会抛出ArrayIndexOutOfBoundsExecption |
| ensureCapacity(<br/>int size<br/>)                   |  void   | 将集合的容量扩展到size；<br/>如果集合容量已大于参数size，则不做任何操作，直接退出方法；<br/>如果集合容量小于参数size，则扩展容量到size； |
| firstElement()                                       | Object  | 返回集合的第一个元素；<br/>若集合为空，会抛出NoSuchElementException异常 |
| lastElement()                                        | Object  | 返回集合的最后一个元素；<br/>若集合为空，会抛出NoSuchElementException异常 |
| indexOf(<br/>Object element,<br/>int start<br/>)     |   int   | 从指定参数位置（start）开始搜索，返回参数element在集合中的位置信息；<br/>element：搜索对象；<br/>start：在集合中开始搜索的位置信息，从0开始；<br/>返回参数对象在集合中的位置信息，从0开始；<br/>如果在集合中未找到参数对象，则返回-1； |
| insertElementAt(<br/>Object obj,<br/>int index<br/>) |  void   | 在集合中指定位置上插入元素；<br/>obj：待插入元素；<br/>start：集合中位置信息，从0开始； |
| lastIndexOf(<br/>Object element,<br/>int start<br/>) |   int   | 从集合中指定位置开始向前搜索元素；<br/>element：搜索的元素；<br/>start：搜索起始位置，从0开始；<br/>返回元素在集合中的位置信息，若未找到返回-1； |
| removeAllElements()                                  |  void   | 删除集合中所有元素                                           |
| removeElement(<br/>Object element<br/>)              | boolean | 从集合中删除指定元素；<br>若给定的对象在向量中保存多次，则只删除其第一个实例；<br>删除成功返回true；<br/>删除失败返回false； |
| removeElementAt(<br/>int index<br/>)                 |  void   | 删除集合中指定位置上的元素；<br/>index：集合中的位置信息，从0开始； |
| setElementAt(<br/>Object obj,<br/>int index<br/>)    |  void   | 更换集合中指定位置上的元素；<br/>obj：元素；<br/>index：集合中的位置信息，从0开始； |
| setSize(<br/>int size<br/>)                          |  void   | 将集合容量更改为size；<br/>如果新容量小于原来的容量，超出范围的元素将丢失（变为null）；<br/>如果新容量大于原来的容量，则自动扩容； |
| trimToSize()                                         |  void   | 将集合中数组容量调整为与集合容量一致；                       |
| clone()                                              | Object  | 浅拷贝                                                       |
| toString()                                           | String  | 将集合中元素转换成字符串，格式：[1, 2, 3, 4]                 |



## Stack（栈）

是一种后进先出（LIFO：Last In First Out） 的数据结构，即最后压入的元素最早弹出（pop）来。

- 继承自Vector类；
- 实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口；
- 只有入栈（push）、出栈（pop）、取栈顶元素（peek）的操作；
- 是线程安全的；

| 独有方法         | 返回值  | 说明                                                         |
| ---------------- | ------- | ------------------------------------------------------------ |
| Stack()          |         | 构造方法                                                     |
| push(E item)     | \<E>    | 将元素入栈；<br>返回入栈的元素；                             |
| pop()            | \<E>    | 移除并返回出栈元素；                                         |
| peek()           | \<E>    | 返回栈顶元素，但不会删除该元素；                             |
| empty()          | boolean | 栈是空的返回true，否则返回false；                            |
| search(Object o) | int     | 从栈顶元素开始向下搜索元素参数；<br/>相当于lastIndexOf(o)方法<br/>返回元素在栈中的位置信息，从1开始，不存在返回-1； |



## CopyOnWriteArrayList（写安全动态数组）

是ArrayList的线程安全版本，即会在副本数组中执行写操作，然后将副本数组作为新数组使用。

- 适用于读多写少的并发场景；
- 实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口；
- 写操作安全使用的锁是ReentrantLock类；

| 独有方法                                        | 返回值  | 说明                                                         |
| ----------------------------------------------- | ------- | ------------------------------------------------------------ |
| CopyOnWriteArrayList()                          |         | 构造方法；<br>初始容量为0；                                  |
| CopyOnWriteArrayList(Collection<? extends E> c) |         | 构造方法；<br/>添加集合中所有元素（调用c.toArray()方法）；   |
| CopyOnWriteArrayList(E[] toCopyIn)              |         | 构造方法；<br/>添加数组中所有元素；                          |
| indexOf(E e, int index)                         | int     | 从集合指定的位置开始搜索元素；<br/>e：被搜索元素；<br/>index：搜索起始位置；<br/>返回元素位置信息，从0开始，未找到返回-1； |
| lastIndexOf(E e, int index)                     | int     | 从集合指定的位置开始反向搜索元素；<br/>e：被搜索元素；<br/>index：搜索起始位置；<br/>返回元素位置信息，从0开始，未找到返回-1； |
| addIfAbsent(E e)                                | boolean | 如果元素不存在，则添加到集合中                               |
| addAllAbsent(Collection<? extends E> c)         | int     | 将指定集合参数中尚未添加到此集合中的所有元素，添加到此集合的末尾；<br>添加的顺序按集合参数的迭代器顺序；<br/>返回成功添加元素的个数 |



## CopyOnWriteArraySet（写安全Set）

- 是写操作线程安全的Set实现；
- 内部通过一个CopyOnWriteArrayList 来代理读写等操作；
- 继承自AbstractSet抽象类；
- 实现了Serializable接口；

| 独有方法                                       | 返回值 | 说明                                |
| ---------------------------------------------- | ------ | ----------------------------------- |
| CopyOnWriteArraySet()                          |        | 构造方法；<br/>初始容量为0；        |
| CopyOnWriteArraySet(Collection<? extends E> c) |        | 构造方法；<br/>添加集合中所有元素； |



## HashMap（散列表）

[HashMap详解](https://blog.csdn.net/a6636656/article/details/124148660)

- 实现了Map接口、Cloneable接口（浅拷贝）、Serializable接口；
- 继承自AbstractMap抽象类；
- 是无序的，即不会记录插入的顺序；
- 这是一个插入慢，但查询速度快的数据结构；
- 在Java7中链表散列的数据结构，即由数组 + 链表的构成；
- 在Java8中是由数组 + 链表 + 红黑树构成的；
- 在Java8中数组中单个链表长度大于等于7，且数组长度超过64时才会将链表转为红黑树；
- 在Java8中如果红黑树左子树/右子树的元素数量小于等于6，则将退回到链表；
- 非线程安全，但支持Fail-Fast机制；
- 最多允许一条记录的键（key）为null，允许value为null；
- 负载因子：是扩容机制的阈值（数组容量*负载因子），当超过了这个阈值，会将数组长度容量翻倍；

| 独有方法                                       | 返回值 | 说明                                                         |
| ---------------------------------------------- | ------ | ------------------------------------------------------------ |
| HashMap(int initialCapacity, float loadFactor) |        | 构造方法；<br/>initialCapacity：初始容量；<br/>loadFactor：负载因子； |
| HashMap(int initialCapacity)                   |        | 构造方法；<br/>initialCapacity：初始容量；<br/>默认的负载因子：0.75； |
| HashMap()                                      |        | 构造方法；<br/>默认初始容量：16；<br/>默认的负载因子：0.75； |
| HashMap(Map<? extends K, ? extends V> m)       |        | 构造方法；<br/>添加参数集合中的元素到当前集合；<br/>添加元素顺序取决于entrySet()方法的返回值； |

- 存储原理

  计算键（key）的哈希值，`int hash=key.hashCode();`

  计算键-值对在数组中的下标，即键（key）的哈希值对Entry数组长度进行取余，`int index=hash % Entry[].length;`

  将键-值对保存到Entry类中，`Entry[index]=value;` 

  如果两个键-值对所在的数组下标相同时，将上一个Entry实例中next变量，指向下一个Entry实例（键-值对）；

- 取值原理

  计算键（key）的哈希值，`int hash=key.hashCode();`

  计算键-值对在数组中的下标，即键（key）的哈希值对Entry数组长度进行取余，`int index=hash % Entry[].length;`

  根据上一步计算的下标值，得到数组中的Entry实例，再遍历该Entry实例的链表；

  遍历链表上每个键-值对，查看键的哈希值是否与请求键的哈希值一致；



## TreeMap（树形散列表）

- 是有序的键-值对集合；
- 内部数据结构是红黑树；
- 继承自AbstractMap抽象类；
- 实现了SortMap接口、NavigableMap接口、Cloneable接口（浅拷贝）、Serializable接口；
- 支持null值和null键；
- 使用Comparator接口来实现排序和去除重复元素；
- 非线程安全，但支持Fail-Fast机制；

| 独有方法                                  | 返回值 | 说明                                                         |
| ----------------------------------------- | ------ | ------------------------------------------------------------ |
| TreeMap()                                 |        | 构造方法<br>使用键的自然顺序构造一个新的空TreeMap；<br/>插入到集合中的所有键都必须实现Comparable接口。<br/>所有键都必须是可相互比较的：k1.compareTo（k2）；<br/>不能为集合中的任何键k1和k2引发ClassCastException；<br/>试图将字符串键放入键为整数的集合中时，抛出ClassCastException异常； |
| TreeMap(Comparator<? super K> comparator) |        | 构造方法<br/>构造一个新TreeMap，根据给定的比较器排序；<br/>集合中的键必须由给定的比较器进行相互比较；<br>不能为集合中的任何键k1和k2引发ClassCastException；<br/>试图将字符串键放入键为整数的集合中时，抛出ClassCastException异常； |
| TreeMap(Map<? extends K, ? extends V> m)  |        | 构造一个新TreeMap，包含指定参数集合中的键-值对；<br/>使用键的自然顺序构造一个新的空树映射；<br/>插入到集合中的所有键都必须实现Comparable接口。<br/>所有键都必须是可相互比较的：k1.compareTo（k2）；<br/>不能为集合中的任何键k1和k2引发ClassCastException；<br/>试图将字符串键放入键为整数的集合中时，抛出ClassCastException异常； |
| TreeMap(SortedMap<K, ? extends V> m)      |        | 构造方法<br/>构造一个新的TreeMap，包含指定参数重的键-值对；<br/>新TreeMap排序规则与指定参数集合中的规则一致；<br/>此方法在线性时间内运行； |

```java
public class TestTreeMap {
	public static void main(String[] args) {
		TreeMap<Teacher, String> map = new TreeMap<Teacher, String>(new Comparator<Teacher>() {
			public int compare(Teacher t1, Teacher t2) {
				int num = t1.getAge() - t2.getAge(); // 按年龄排序
				return num != 0 ? num : t1.getName().compareTo(t2.getName()); // 如果年龄相同，再按名字排序
			}
		});

		map.put(new Teacher(1, "张三", 23), "张三");
		map.put(new Teacher(2, "李四", 18), "李四");
		map.put(new Teacher(3, "王五", 22), "王五");
		map.put(new Teacher(4, "赵六", 21), "赵六");
		System.out.println("排序结果：" + map);
	}
}

class Teacher {
	private int id;
	private String name;
	private int age;
	
	public Teacher(int id, String name, int age) {
		this.id = id;
		this.name = name;
		this.age = age;
	}
	
	public int getId() {
		return id;
	}
	
	public void setId(int id) {
		this.id = id;
	}
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
}
```



## Hashtable（线程安全的散列表）

- 键-值对都不能为null；
- 初始容量为11，加载因子为0.75；
- 线程安全，使用synchronized关键字实现的线程同步；
- 继承自Dictionary类；
- 实现了Map接口、Cloneable接口（浅拷贝）、Serializable接口；

| 独有方法                                         | 返回值 | 说明                                                         |
| ------------------------------------------------ | ------ | ------------------------------------------------------------ |
| Hashtable(int initialCapacity, float loadFactor) |        | 构造方法<br>initialCapacity：初始容量；<br/>loadFactor：负载因子； |
| Hashtable(int initialCapacity)                   |        | 构造方法<br/>initialCapacity：初始容量；<br/>默认的负载因子是0.75； |
| Hashtable()                                      |        | 构造方法<br/>默认的初始容量：11；<br/>默认的负载因子是0.75； |
| Hashtable(Map<? extends K, ? extends V> t)       |        | 构造方法，添加参数集合中所有元素；<br/>默认的初始容量：Math.*max*(2*t.size(), 11)；<br/>默认的负载因子是0.75； |



## LinkedHashMap

![JavaLinkedHashMap_0](./01.Java_part1.assets/JavaLinkedHashMap_0.png)

- 本质上是：HashMap + 双向链表；
- 继承自HashMap类；
- 在HashMap基础上，给节点结构加了before指针和after指针，让所有节点形成一个双向链表；
- 双向链表的结构就是键-值对的顺序（插入顺序或访问顺序）；
- 非线程安全，可以使用 `Map m = Collections.synchronizedMap(new LinkedHashMap());`

| 独有方法                                                     | 返回值 | 说明                                                         |
| ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| LinkedHashMap(<br/>int initialCapacity, <br/>float loadFactor<br/>) |        | 构造方法；<br/>initialCapacity：初始容量；<br/>loadFactor：负载因子；<br/>使用插入顺序； |
| LinkedHashMap(<br/>int initialCapacity<br/>)                 |        | 构造方法；<br/>initialCapacity：初始容量；<br/>负载因子：0.75；<br/>使用插入顺序； |
| LinkedHashMap()                                              |        | 构造方法；<br/>初始容量：16<br/>负载因子：0.75；<br/>使用插入顺序； |
| LinkedHashMap(<br/>Map<? extends K, ? extends V> m<br/>)     |        | 构造方法，添加指定参数重的键-值对；<br/>按entrySet()方法顺序添加；<br/>初始容量：16<br/>负载因子：0.75；<br/>使用插入顺序； |
| LinkedHashMap(<br/>int initialCapacity,<br/>float loadFactor,<br/>boolean accessOrder<br/>) |        | 构造方法；<br/>initialCapacity：初始容量；<br/>loadFactor：负载因子；<br/>accessOrder：排序方式<br/>true访问顺序（**LRU算法**）<br/>false插入顺序； |

**按访问顺序排序**

```java
public class TestLinkedHashMap {

	public static void main(String[] args) {
		LinkedHashMap<String, String> map = new LinkedHashMap<String, String>(10, 0.75f, true); // 按访问顺序排序
		map.put("a", "a");
		map.put("b", "b");
		map.put("c", "c");
		map.put("d", "d");
		map.get("c");
		map.get("b");
		map.put("a", "a");
		map.forEach((k, v) -> System.out.println(k));
	}
}
```

输出结果：

```shell
d
c
b
a
```



## ConcurrentHashMap

![JavaConcurrentHashMap_0](./01.Java_part1.assets/JavaConcurrentHashMap_0.png)

- 思路是将数据分成一段一段地存储，然后给每一段数据配一把锁，实现热点分布；
- 支持高并发情况下的线程安全，使用频率比较高；
- 继承自AbstractMap类；
- 实现了ConcurrentMap<K,V>接口、Serializable接口；
- 键-值对都不能为null；
- 默认负载因子0.75，当数组使用率达到75%时，为减少哈希值碰撞，数组长度将扩容一倍；
- Segment数组默认大小为16，容量初始化后就不能改了，并且不是懒加载；
- 在Java7中是基于ReentrantLock实现分段锁，锁的粒度较大；
- 在Java7是基于数组+链表的结构；
- 在Java8中是基于分段锁+CAS保证线程安全，分段锁基于synchronized关键字实现；
- 在Java8中是基于数组+链表+红黑树的结构；

| 独有方法                                                     | 返回值                | 说明                                                         |
| ------------------------------------------------------------ | --------------------- | ------------------------------------------------------------ |
| ConcurrentHashMap()                                          |                       | 构造方法<br>分段个数：16；<br>负载因子，默认为0.75；<br/>    |
| ConcurrentHashMap(<br>int initialCapacity<br/>)              |                       | initialCapacity：分段个数；<br/>负载因子，默认为0.75；<br/>  |
| ConcurrentHashMap(<br/>Map<? extends K, ? extends V> m<br/>) |                       | 构造方法<br/>分段个数：16；<br/>负载因子，默认为0.75；<br/>预估的并发线程数：1 |
| ConcurrentHashMap(<br/>int initialCapacity, <br/>float loadFactor<br/>) |                       | 构造方法<br/>initialCapacity：分段个数；<br/>loadFactor：负载因子；<br/>预估的并发线程数：1 |
| ConcurrentHashMap(<br/>int initialCapacity,<br/>float loadFactor, <br/>int concurrencyLevel<br/>) |                       | 构造方法<br/>initialCapacity：分段个数；<br/>loadFactor：负载因子；<br/>concurrencyLevel：预估的并发线程数 |
| contains(Object value)                                       | boolean               | 与containsValue(value)方法一致                               |
| keys()                                                       | Enumeration\<K>       | 返回键的枚举遍历接口                                         |
| elements()                                                   | Enumeration\<V>       | 返回值的枚举遍历接口                                         |
| mappingCount()                                               | long                  | 返回键-值对的预估值；<br/>如果存在并发插入或删除，则实际计数可能不同； |
| newKeySet()                                                  | KeySetView<K,Boolean> | 静态方法？？？                                               |
| newKeySet(int initialCapacity)                               | KeySetView<K,Boolean> | 静态方法                                                     |
| keySet(V mappedValue)                                        | KeySetView<K,V>       |                                                              |
| forEach(<br/>long parallelismThreshold,<br/>BiConsumer<? super K,? super V> action<br/>) | void                  |                                                              |
| forEach(<br/>long parallelismThreshold,<br/>BiFunction<? super K, ? super V, ? extends U> transformer,<br/>Consumer<? super U> action<br/>) | void                  |                                                              |
| search(<br/>long parallelismThreshold,<br/>BiFunction<? super K, ? super V, ? extends U> searchFunction<br/>) | \<U>                  |                                                              |
| reduce(<br/>long parallelismThreshold,<br/>BiFunction<? super K, ? super V, ? extends U> transformer,<br/>BiFunction<? super U, ? super U, ? extends U> reducer<br/>) | \<U>                  |                                                              |
| reduceToDouble(<br/>long parallelismThreshold,<br/>ToDoubleBiFunction<? super K, ? super V> transformer,<br/>double basis,<br/>DoubleBinaryOperator reducer<br/>) | double                |                                                              |
| reduceToLong(<br/>long parallelismThreshold,<br/>ToLongBiFunction<? super K, ? super V> transformer,<br/>long basis,<br/>LongBinaryOperator reducer<br/>) | long                  |                                                              |
| reduceToInt(<br/>long parallelismThreshold,<br/>ToIntBiFunction<? super K, ? super V> transformer,<br/>int basis,<br/>IntBinaryOperator reducer<br/>) | int                   |                                                              |
| forEachKey(<br/>long parallelismThreshold,<br/>Consumer<? super K> action<br/>) | void                  |                                                              |
| forEachKey(<br/>long parallelismThreshold,<br/>Function<? super K, ? extends U> transformer,<br/>Consumer<? super U> action<br/>) | void                  |                                                              |
| searchKeys(<br/>long parallelismThreshold,<br/>Function<? super K, ? extends U> searchFunction<br/>) | \<U>                  |                                                              |
| reduceKeys(<br/>long parallelismThreshold,<br/>BiFunction<? super K, ? super K, ? extends K> reducer<br/>) | \<K>                  |                                                              |
| reduceKeys(<br/>long parallelismThreshold,<br/>Function<? super K, ? extends U> transformer,<br/>BiFunction<? super U, ? super U, ? extends U> reducer<br/>) | \<U>                  |                                                              |
| reduceKeysToDouble(<br/>long parallelismThreshold,<br/>ToDoubleFunction<? super K> transformer,<br/>double basis,<br/>DoubleBinaryOperator reducer<br/>) | double                |                                                              |
| reduceKeysToLong(<br/>long parallelismThreshold,<br/>ToLongFunction<? super K> transformer,<br/>long basis,<br/>LongBinaryOperator reducer<br/>) | long                  |                                                              |
| reduceKeysToInt(<br/>long parallelismThreshold,<br/>ToIntFunction<? super K> transformer,<br/>int basis,<br/>IntBinaryOperator reducer<br/>) | int                   |                                                              |
| forEachValue(<br/>long parallelismThreshold,<br/>Consumer<? super V> action<br/>) | void                  |                                                              |
| forEachValue(<br/>long parallelismThreshold,<br/>Function<? super V, ? extends U> transformer,<br/>Consumer<? super U> action<br/>) | void                  |                                                              |
| searchValues(<br/>long parallelismThreshold,<br/>Function<? super V, ? extends U> searchFunction<br/>) | \<U>                  |                                                              |
| reduceValues(<br/>long parallelismThreshold,<br/>BiFunction<? super V, ? super V, ? extends V> reducer<br/>) | \<V>                  |                                                              |
| reduceValues(<br/>long parallelismThreshold,<br/>Function<? super V, ? extends U> transformer,<br/>BiFunction<? super U, ? super U, ? extends U> reducer<br/>) | \<U>                  |                                                              |
| reduceValuesToDouble(<br/>long parallelismThreshold,<br/>ToDoubleFunction<? super V> transformer,<br/>double basis,<br/>DoubleBinaryOperator reducer<br/>) | double                |                                                              |
| reduceValuesToLong(<br/>long parallelismThreshold,<br/>ToLongFunction<? super V> transformer,<br/>long basis,<br/>LongBinaryOperator reducer<br/>) | long                  |                                                              |
| reduceValuesToInt(<br/>long parallelismThreshold,<br/>ToIntFunction<? super V> transformer,<br/>int basis,<br/>IntBinaryOperator reducer<br/>) | int                   |                                                              |
| forEachEntry(<br/>long parallelismThreshold,<br/>Consumer<? super Map.Entry<K,V>> action<br/>) | void                  |                                                              |
| forEachEntry(<br/>long parallelismThreshold,<br/>Function<Map.Entry<K,V>, ? extends U> transformer,<br/>Consumer<? super U> action<br/>) | void                  |                                                              |
| searchEntries(<br/>long parallelismThreshold,<br/>Function<Map.Entry<K,V>, ? extends U> searchFunction<br/>) | \<U>                  |                                                              |
| reduceEntries(<br/>long parallelismThreshold,<br/>BiFunction<Map.Entry<K,V>, <br/>Map.Entry<K,V>, ? extends Map.Entry<K,V>> reducer<br/>) | Map.Entry<K,V>        |                                                              |
| reduceEntries(<br/>long parallelismThreshold,<br/>Function<Map.Entry<K,V>, ? extends U> transformer,<br/>BiFunction<? super U, ? super U, ? extends U> reducer<br/>) | \<U>                  |                                                              |
| reduceEntriesToDouble(<br/>long parallelismThreshold,<br/>ToDoubleFunction<Map.Entry<K,V>> transformer,<br/>double basis,<br/>DoubleBinaryOperator reducer<br/>) | double                |                                                              |
| reduceEntriesToLong(<br/>long parallelismThreshold,<br/>ToLongFunction<Map.Entry<K,V>> transformer,<br/>long basis,<br/>LongBinaryOperator reducer<br/>) | long                  |                                                              |
| reduceEntriesToInt(<br/>long parallelismThreshold,<br/>ToIntFunction<Map.Entry<K,V>> transformer,<br/>int basis,<br/>IntBinaryOperator reducer<br/>) | int                   |                                                              |



## ConcurrentSkipListMap

- 继承自AbstractMap类；
- 实现了ConcurrentNavigableMap接口、Cloneable接口（浅拷贝）、Serializable接口；
- 实现了ConcurrentMap接口、NavigableMap接口、SortedMap接口；
- 支持多线程高并发；
- 内部是 SkipList（跳表）结构实现；
- 键是有序的；
- 键-值对都不能为 null；
- 在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是 ConcurrentSkipListMap 的4倍左右；
- 存取时间是log(n)，和线程数几乎无关，也就并发的线程越多，ConcurrentSkipListMap 越能体现出他的优势；

| 独有方法                                                | 返回值 | 说明                                                         |
| ------------------------------------------------------- | ------ | ------------------------------------------------------------ |
| ConcurrentSkipListMap()                                 |        | 构造方法；<br/>使用键的自然顺序规则；                        |
| ConcurrentSkipListMap(Comparator<? super K> comparator) |        | 构造方法；<br/>使用指定参数的键排序规则；<br>comparator：键排序规则； |
| ConcurrentSkipListMap(Map<? extends K, ? extends V> m)  |        | 构造方法；<br/>使用键的自然顺序规则；<br/>m：将集合中所有键-值对添加到当前集合中； |
| ConcurrentSkipListMap(SortedMap<K, ? extends V> m)      |        | 构造方法；<br/>使用指定的SortedMap对象中的排序规则；<br/>m：将SortedMap中键-值对添加到当前集合中； |



## IdentityHashMap

- 继承自AbstractMap接口；
- 实现了Map接口、Serializable接口、Cloneable接口；
- 比较键（key）的时候使用的是`==`，也就是比较的引用；
- 非线程安全；

| 独有方法                                         | 返回值 | 说明                                                         |
| ------------------------------------------------ | ------ | ------------------------------------------------------------ |
| IdentityHashMap()                                |        | 构造方法<br>初始容量：32                                     |
| IdentityHashMap(int expectedMaxSize)             |        | 构造方法<br/>expectedMaxSize：预期的最大值；                 |
| IdentityHashMap(Map<? extends K, ? extends V> m) |        | 构造方法<br/>添加指定集合中的键-值对<br/>初始容量：`(1 + m.size()) * 1.1` |



## WeakHashMap

除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值：

- 继承自AbstractMap类；
- 实现Map接口；
- key的类型是WeakReference（弱引用），如果key被回收，则这个key指向的对象会被从Map集合中移除；
- 非线程安全；

| 独有方法                                           | 返回值 | 说明                                                         |
| -------------------------------------------------- | ------ | ------------------------------------------------------------ |
| WeakHashMap(int initialCapacity, float loadFactor) |        | 构造方法<br/>initialCapacity：初始容量；<br/>loadFactor：负载因子； |
| WeakHashMap(int initialCapacity)                   |        | 构造方法<br/>initialCapacity：初始容量；<br/>负载因子：0.75  |
| WeakHashMap()                                      |        | 构造方法<br/>初始容量：16；<br/>负载因子：0.75；             |
| WeakHashMap(Map<? extends K, ? extends V> m)       |        | 构造方法<br/>初始容量：max(m.size() / 0.75) + 1,16)<br/>负载因子：0.75；<br/>添加指定参数中的键-值对 |



## SynchronousQueue

是一个阻塞队列，内部没有容器，不能存储元素，生产者线程执行队列上的put操作后就会进入阻塞状态，等待消费者线程执行该队列上的take操作。这是一种线程与线程间一对一传递消息的机制；

- 特点

  - 实现了Queue接口、BlockingQueue接口、Serializable接口；
  - 继承自AbstractQueue抽象类；
  - 使用CAS机制实现线程的安全访问；
  - 可以实现线程配对通信机制；

- 策略

  - 公平策略

    公平策略原则是：队尾匹配队头出队（队尾的线程优先被take方法匹配，但在队头的线程优先被唤醒）；

    是基于TransferQueue内部队列实现的公平策略，队列有一个head和tail指针，用于指向当前正在等待匹配的线程节点；

    生产线程T1执行put(1)操作，由于当前没有配对的消费线程，所以T1线程入队列，自旋一小会后睡眠等待；

    接着，生产线程T2执行了put(2)操作，跟前面一样，T2线程也入队列，自旋一小会后睡眠等待；

    这时有一个消费线程K1，执行了take操作，因为此时队尾指向的是T2线程，所以T2线程跟K1线程配对了（一put一take），返回T2线程生产的数据；

    但此时要唤醒的线程并不是T2，而是T1；

  - 非公平策略

    非公平策略原则：先入栈后匹配；

    底层的实现是基于TransferStack类（一个栈）的，栈中用head指针指向栈顶；

    生产线程T1执行put(1)操作，由于当前没有配对的消费线程，所以线程T1入栈，自旋一小会后睡眠等待；

    接着，生产线程T2再次执行了put(2)操作，跟前面一样，线程T2入栈，自旋一小会后睡眠等待；

    又来一个消费线程K1，执行了take操作，这时候发现栈顶为T2线程，匹配成功，但是实现会先把线程K1入栈，然后K1线程循环执行匹配线程T2的逻辑，如果没有并发冲突，就会把栈顶指针直接指向K1线程；

    最后，再来一个消费线程K2，执行了take操作，这跟步骤3的逻辑基本是一致的，线程K2入栈，然后在循环中匹配线程T1，最终全部匹配完毕，栈变为空，恢复初始状态；

- 实例方法

  | 独有方法                       | 返回值 | 说明                                                         |
  | ------------------------------ | ------ | ------------------------------------------------------------ |
  | SynchronousQueue()             |        | 构造方法                                                     |
  | SynchronousQueue(boolean fair) |        | 构造方法；<br>fair：true表示使用公平策略，false使用非公平策略 |

- 案例

  ```java
  // 每一个 put 操作必须等待一个take 操作，否则不能继续添加元素
  public class TestSynchronousQueue {
  	static SynchronousQueue<String> queue = new SynchronousQueue<>();
  	
  	public static void main(String[] args) throws InterruptedException {
  		ExecutorService s = Executors.newCachedThreadPool();
  		s.submit(() -> {
  			try {
  				Thread.sleep(2000);
  				System.out.println("异步线程已读取：" + queue.take());
  			} catch (InterruptedException e) {
  				e.printStackTrace();
  			}
  		});
  		
  		String value = "hello";
  		System.out.println("向阻塞队列中插入元素" + value);
  		queue.put(value);
  		
  		Thread.sleep(5000);
  		s.shutdown();
  		System.out.println("已关闭线程池!");
  	}
  }
  ```



## ArrayBlockingQueue

是一个阻塞式的队列，继承自AbstractBlockingQueue。

- 实现了<a href="##Queue（队列接口）">Queue</a>接口、<a href="##BlockingQueue（阻塞队列接口）">BlockingQueue</a>接口、<a href="##Collection接口">Collection</a>接口、Serializable接口；
- 底层以数组的形式保存数据（实际上可看作一个循环数组）；
- 是一个有界队列，在使用构造方法时，必须要指定队列中数组的长度；

| 方法                                                         | 返回 | 说明                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| ArrayBlockingQueue(<br/>int capacity<br/>)                   |      | 构造方法；<br>capacity：容量大小；<br/>阻塞线程使用非公平策略获取锁； |
| ArrayBlockingQueue(<br/>int capacity, <br/>boolean fair<br/>) |      | 构造方法；<br/>capacity：容量大小；<br/>fair：true表示阻塞线程使用公平策略获取锁，<br/>false表示非公平锁； |
| ArrayBlockingQueue(<br/>int capacity, <br/>boolean fair,<br/>Collection<? extends E> c<br/>) |      | 构造方法；<br/>capacity：容量大小；<br/>fair：true表示阻塞线程使用公平策略获取锁，<br/>false表示非公平锁；<br>c：将集合中按遍历顺序添加到队列中； |



## LinkedTransferQueue





## PriorityBlockingQueue

阻塞优先队列，是一个支持优先级的无界阻塞队列，可以按照自然排序或自定义排序规则在队列中对元素进行排序；

- 实现了<a href="##Queue（队列接口）">Queue</a>接口、<a href="##BlockingQueue（阻塞队列接口）">BlockingQueue</a>接口、<a href="##Collection接口">Collection</a>接口、Serializable接口；
- 不允许存储 null 元素；

| 方法                                                         | 返回值 | 说明            |
| ------------------------------------------------------------ | ------ | --------------- |
| PriorityBlockingQueue()                                      |        | 构造方法；<br/> |
| PriorityBlockingQueue(<br/>int initialCapacity<br/>)         |        | 构造方法；<br/> |
| PriorityBlockingQueue(<br/>int initialCapacity,<br/>Comparator<? super E> comparator<br/>) |        | 构造方法；<br/> |
| PriorityBlockingQueue(<br/>Collection<? extends E> c<br/>)   |        | 构造方法；<br/> |

```java
public class TestPriorityBlockingQueue {

	public static void main(String[] args) {
		PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<Integer>(5);
		Random random = new Random();

		System.out.println("添加数字:");
		for (int i = 0; i < 5; i++) {
			int j = random.nextInt(100);
			System.out.print(j + "  ");
			queue.offer(j);
		}

		System.out.println("\r\n取出数字:");
		for (int i = 0; i < 5; i++) {
			System.out.print(queue.poll() + " ");
		}
	}
}
```



## LinkedBlockingQueue





## TransferQueue





## PriorityQueue





## ConcurrentLinkedQueue





## DelayQueue





## ArrayDeque





## LinkedBlockingDeque





## EnumSet





## LinkedHashSet





## Collections

| 方法                                                         |      返回值       | 说明                                                         |
| ------------------------------------------------------------ | :---------------: | ------------------------------------------------------------ |
| sort(<br/>List<T> list, <br/>Comparator<? super T> c<br/>)   |       void        | 将指定列表按升序排列                                         |
| sort(<br/>List<T> list, <br/>Comparator<? super T> c<br/>)   |       void        | 使用指定的排序规则，对集合中元素排序                         |
| binarySearch(<br/>List<? extends Comparable<? super T>> list, <br/>T key<br/>) |       \<T>        | 使用二分搜索法在集合中搜索对象                               |
| binarySearch(<br/>List<? extends T> list, <br/>T key, <br/>Comparator<? super T> c<br/>) |        int        | 使用二分搜索法在集合中搜索对象                               |
| reverse(<br/>List<?> list<br/>)                              |       void        | 反转指定列表中元素的顺序                                     |
| shuffle(<br/>List<?> list<br/>)                              |       void        | 使用默认的随机源随机排列指定的列表                           |
| shuffle(<br/>List<?> list, <br/>Random rnd<br/>)             |       void        | 使用随机源随机排列指定的列表                                 |
| swap(<br/>List<?> list, <br/>int i, <br/>int j<br/>)         |       void        |                                                              |
| fill(<br/>List<? super T> list, <br/>T obj<br/>)             |       void        | 将集合参数重的所有元素都设置位参数obj                        |
| copy(<br/>List<? super T> dest, <br/>List<? extends T> src<br/>) |       void        | 将集合src重的元素按遍历顺序复制到dest中                      |
| min(<br/>Collection<? extends T> coll<br/>)                  |       \<T>        | 返回集合中的最小值；<br>使用对象上的compareTo方法比较元素大小 |
| min(<br/>Collection<? extends T> coll, <br/>Comparator<? super T> comp<br/>) |       \<T>        | 返回集合中的最小值；<br/>使用参数comp比较元素大小            |
| max(Collection<? extends T> coll)                            |       \<T>        | 返回集合中的最大值；<br/>使用对象上的compareTo方法比较元素大小 |
| max(<br/>Collection<? extends T> coll, <br/>Comparator<? super T> comp<br/>) |       \<T>        | 返回集合中的最大值；<br/>使用参数comp比较元素大小            |
| rotate(<br/>List<?> list, <br/>int distance<br/>)            |       void        | 将集合中的元素旋转指定的距离；<br>list：集合；<br>distance：待旋转列表元素的距离 |
| replaceAll(<br/>List\<T> list, <br/>T oldVal, <br/>T newVal<br/>) |      boolean      | 替换集合中指定对象；<br/>list：集合对象；<br/>oldVal：被替换的对象；<br/>newVal：替换后的对象；<br/>返回true表示替换成功； |
| indexOfSubList(<br/>List\<?> source, <br/>List<?> target<br/>) |        int        | 返回第二个参数在第一个参数中首次出现的位置；<br/>如果没有搜索到集合返回-1；<br>source：在这个集合中搜索；<br>target：被搜索的集合； |
| lastIndexOfSubList(<br/>List\<?> source, <br/>List<?> target<br/>) |        int        | 返回第二个参数在第一个参数中最后一次出现的位置；<br/>如果没有搜索到集合返回-1；<br/>source：在这个集合中搜索；<br/>target：被搜索的集合； |
| unmodifiableCollection(<br/>Collection<? extends T> c<br/>)  |  Collection\<T>   | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| unmodifiableSet(<br/>Set<? extends T> s<br/>)                |      Set\<T>      | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| unmodifiableSortedSet(<br/>SortedSet\<T> s<br/>)             |   SortedSet\<T>   | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| unmodifiableNavigableSet(<br/>NavigableSet\<T> s<br/>)       | NavigableSet\<T>  | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| unmodifiableList(<br/>List<? extends T> list<br/>)           |     List\<T>      | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| unmodifiableMap(<br/>Map<? extends K, ? extends V> m<br/>)   |     Map<K,V>      | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| unmodifiableSortedMap(<br/>SortedMap<K, ? extends V> m<br/>) |  SortedMap<K,V>   | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| unmodifiableNavigableMap(<br/>NavigableMap<K, ? extends V> m<br/>) | NavigableMap<K,V> | 把集合参数包装成一个不可修改的视图；<br/>返回的视图支持读操作，不支持修改操作，会抛UnsupportedOperationException异常；<br/>返回集合中的hashCode和equals方法是依赖Object； |
| synchronizedCollection(<br/>Collection\<T> c<br/>)           |  Collection\<T>   | 将集合参数包装成一个线程安全的集合对象；<br/>在包装对象中使用**synchronized**代码块实现线程安全；<br/>但迭代器、Spliterator或流遍历返回的集合时，不能保证线程安全： |
| synchronizedSet(<br/>Set\<T> s<br/>)                         |      Set\<T>      | 将集合参数包装成一个线程安全的集合对象；<br/>在包装对象中使用**synchronized**代码块实现线程安全；<br/>但迭代器、Spliterator或流遍历返回的集合时，不能保证线程安全： |
| synchronizedSortedSet(<br/>SortedSet\<T> s<br/>)             |   SortedSet\<T>   | 将集合参数包装成一个线程安全的集合对象；<br/>在包装对象中使用**synchronized**代码块实现线程安全；<br/>但迭代器、Spliterator或流遍历返回的集合时，不能保证线程安全： |
| synchronizedNavigableSet(<br/>NavigableSet\<T> s<br/>)       | NavigableSet\<T>  | 将集合参数包装成一个线程安全的集合对象；<br/>在包装对象中使用**synchronized**代码块实现线程安全；<br/>但迭代器、Spliterator或流遍历返回的集合时，不能保证线程安全： |
| synchronizedList(<br/>List\<T> list<br/>)                    |     List\<T>      | 将集合参数包装成一个线程安全的集合对象；<br/>在包装对象中使用**synchronized**代码块实现线程安全；<br/>但迭代器、Spliterator或流遍历返回的集合时，不能保证线程安全： |
| synchronizedMap(<br/>Map<K,V> m<br/>)                        |     Map<K,V>      | 将集合参数包装成一个线程安全的集合对象；<br/>在包装对象中使用**synchronized**代码块实现线程安全；<br/>但迭代器、Spliterator或流遍历返回的集合时，不能保证线程安全： |
| synchronizedSortedMap(<br/>SortedMap<K,V> m<br/>)            |  SortedMap<K,V>   | 将集合参数包装成一个线程安全的集合对象；<br/>在包装对象中使用**synchronized**代码块实现线程安全；<br/>但迭代器、Spliterator或流遍历返回的集合时，不能保证线程安全： |
| checkedCollection(<br/>Collection<E> c,<br/>Class<E> type<br/>) |  Collection\<E>   | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedQueue(<br/>Queue\<E> queue, <br/>Class\<E> type<br/>) |     Queue\<E>     | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedSet(<br/>Set\<E> s, <br/>Class\<E> type<br/>)         |      Set\<E>      | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedSortedSet(<br/>SortedSet\<E> s,<br/>Class\<E> type<br/>) |   SortedSet\<E>   | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedNavigableSet(<br/>NavigableSet<E> s,<br/>Class<E> type<br/>) | NavigableSet\<E>  | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedList(<br/>List\<E> list, <br/>Class\<E> type<br/>)    |     List\<E>      | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedMap(<br/>Map<K, V> m,<br/>Class\<K> keyType,<br/>Class<V> valueType<br/>) |     Map<K, V>     | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedSortedMap(<br/>SortedMap<K, V> m,<br/>Class<K> keyType,<br/>Class<V> valueType<br/>) |  SortedMap<K,V>   | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| checkedNavigableMap(<br/>NavigableMap<K, V> m,<br/>Class\<K> keyType,<br/>Class\<V> valueType<br/>) | NavigableMap<K,V> | 将集合包装成一个带动态类型安全检查的视图；<br/>任何向视图里插入错误类型元素的行为，会导致ClassCastException异常；<br/>但对于在视图生成之前已在集合存在的元素，不会做类型检查；<br/>泛型机制提供了编译时的类型检查，但可用强制类型转换绕过该机制；<br/>通常这不是问题，因为编译器会对所有未检查的操作发出警告；<br/>可以使用该方法实现类型安全检查； |
| emptyIterator()                                              |   Iterator\<T>    | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptyListIterator()                                          | ListIterator\<T>  | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptyEnumeration()                                           |  Enumeration\<T>  | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptySet()                                                   |      Set\<T>      | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptySortedSet()                                             |   SortedSet\<E>   | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptyNavigableSet()                                          | NavigableSet\<E>  | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptyList()                                                  |     List\<T>      | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptyMap()                                                   |     Map<K,V>      | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptySortedMap()                                             |  SortedMap<K,V>   | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| emptyNavigableMap()                                          | NavigableMap<K,V> | 返回一个没有元素的迭代器；<br/>迭代器不可变的；              |
| singleton(T o)                                               |      Set\<T>      | 返回一个仅包含参数对象的不可变集合；<br>返回的集合是可序列化的； |
| singletonList(T o)                                           |     List\<T>      | 返回一个仅包含参数对象的不可变集合；<br/>返回的集合是可序列化的； |
| singletonMap(<br/>K key, <br/>V value<br/>)                  |     Map<K,V>      | 返回一个仅包含参数对象的不可变集合；<br/>返回的集合是可序列化的； |
| nCopies(<br/>int n, <br/>T o<br/>)                           |     List\<T>      | 创建一个不可变集合，并向集合中添加n个o对象，再返回不可变集合；<br/>返回的列表是可序列化的； |
| reverseOrder()                                               |  Comparator\<T>   | 返回一个比较器，其比较规则与自然顺序相反；<br/>**自然排序**是指对象的compareTo方法； |
| reverseOrder(<br/>Comparator<T> cmp<br/>)                    |  Comparator\<T>   | 将指定比较器参数进行包装，并逆转比较规则；                   |
| enumeration(<br/>final Collection\<T> c<br/>)                |  Enumeration\<T>  | 返回集合的枚举，这枚举是用集合的迭代器包装来的；             |
| list(<br/>Enumeration\<T> e<br/>)                            |   ArrayList\<T>   | 遍历枚举中的元素，并添加到一个ArrayList对象中，返回ArrayList对象； |
| frequency(<br/>Collection<?> c, <br/>Object o<br/>)          |        int        | 返回在第一个参数中与第二个参数相等的元素数；<br>判断元素相等的规则：`o\==null ？e==null : o.equals(e)` |
| disjoint(<br/>Collection\<?> c1, <br/>Collection<?> c2<br/>) |      boolean      | 如果两个参数没有交集的话，则返回true；                       |
| addAll(<br/>Collection<? super T> c, <br/>T... elements<br/>) |      boolean      | 按第二个数组参数顺序添加到第一个参数集合中；<br>返回true表示至少成功添加了一个对象；<br/>返回false表示全部添加失败； |
| newSetFromMap(<br/>Map<E, Boolean> map<br/>)                 |      Set\<E>      | 将参数中键的集合包装成一个Set集合，并返回该Set集合；         |
| asLifoQueue(<br/>Deque\<T> deque<br/>)                       |     Queue\<T>     | 将一个双向队列对象包装成一个后进先出（FIFO）的队列；<br/>方法add被映射到push，remove被映射到pop等等； |



------



# 线程（Thread）

线程是虚拟机中进行调度运算的最小单位，虚拟机中可同时运行多个线程，线程有共享的内存空间，也有独立的内存空间；



## 多线程原理

线程调度器通过调度策略给每个线程分配一个CPU的时间片（TimeSlicing，是分给线程的运行时间），每个线程执行完一个时间片后，线程调度器会切换到下一个线程执行时间片，又因为时间片非常短（一般是几十毫秒），这个切换运行线程的过程给人的感觉像是有多个线程在同时运行；



## 线程调度器

每个虚拟机中都有一个线程调度器（Thread Scheduler），负责为所有处于就绪状态（Runnable）的线程分配CPU时间。

Java虚拟机的线程调度算法是抢占式的 (preemptive)；

线程调度器的策略：

- 抢占式调度策略

  调度器先分配CPU时间给优先级高的线程，即优先级高的线程抢占了CPU时间；

  当线程的优先级相同时，调度器采用非抢占式的轮转的调度顺序，来分配CPU时间；

- 协同式调度策略

  指一个程执行完后，主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但有一个致命弱点：如果一个线程编写有问题，运行到一半就一直 堵塞，那么可能导致整个系统崩溃。



## 上下文切换

多线程运行时，每当线程调度器要切换到下一个线程运行前，会保存上个线程的运行状态（保存在线程各自的程序计数器中），以便线程调度器下次再切换到这个线程时，能恢复到正确的执行位置，这种线程状态从保存到恢复的过程就是一次上下文切换。

减少上下文切换的方法：

- 减少线程的创建：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；
- 无锁并发编程：多线程竞争锁时，会触发上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁；
- CAS算法：Atomic 包使用 CAS 算法来更新数据，而不需要加锁；
- 协程（虚拟线程）：在线程内部实现多任务的调度，并在单个线程里维持多个任务间的切换，指多个函数；



## 创建线程方式

- 继承 Thread 类

  继承 `Thread`类并重写 `run()` 方法；

  ```java
  public class MYThread extends Thread{
    @Override
    public void run() {
    }
  }
  ```

- 实现 Runnable 接口

  继承并实现 `Runnable` 接口中的 `run()` 方法；

  将 `Runnable` 接口的实现对象作为 `Thread` 类的构造方法参数；

  ```java
  new Thread(new Runnable() {
    public void run() {
    }
  }).start();
  ```

- 实现 Callable 接口

  是Java5新特性，继承并实现 `Callable` 接口中的 `call()` 方法，这个方法是有返回值、可声明抛出异常；

  创建 `FutureTask` 的实例对象，并将 `Callable` 接口的实现对象作为构造方法参数传入；

  将 `FutureTask` 的实例对象，作为 `Thread` 类的构造方法参数传入；

  ```java
  CallableTest callableTest = new CallableTest();
  FutureTask<Integer> futureTask = new FutureTask<Integer>(callableTest);
  Thread thread = new Thread(futureTask);
  thread.start();
  ```



## 优先级

在创建线程时，默认取得所属线程组的优先级作为默认值；

可以通过`setPriority(int newPriority)`实例方法来更改线程的优先级，但是线程的优先级不能高于所属线程组的优先级；

可以通过`getPriority()`实例方法得到线程的优先级；

默认优先级是 `Thread.NORM_PRIORITY=5`

最低优先级是 `Thread.MIN_PRIORITY=1`

最高优先级是 `Thread.MAX_PRIORITY=10`



## 守护线程

线程分为用户线程与守护线程，守护线程是用来服务用户线程的，GC线程就是一个典型的守护线程。

在创建线程时，默认会取得所属线程组的守护线程标志作为默认值。

可以通过执行线程的 `setDaemon(true)` 实例方法，将线程变为守护线程，但需要在执行start()方法前设置。

守护线程的生命依赖于用户线程，即当所有用户线程都运行结束后，JVM会自动终止所有守护线程。



## 生命周期

![这里写图片描述](./01.Java_part1.assets/JavaThreadDeclarationCycle_0.jpeg)

| 生命周期             | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| 新建状态（New）      | 线程创建后就是新建状态；<br>同时JVM也为线程分配了程序计数器区、VM栈区、本地方法区； |
| 就绪状态（Runnable） | 调用线程的start()实例方法后，线程就转为就绪状态；<br>表示线程可随时进入运行状态，什么时候分配CPU资源，取决于JVM里线程调度器的调度； |
| 运行状态（Running）  | 程序调度器为处于就绪状态的线程分配了CPU时间片后<br>线程就转为运行状态了，并要运行run()方法 |
| 阻塞状态（Blocked）  | 因某种原因线程放弃CPU使用权，暂时停止运行，直到再次进入就绪状态，才有机会变为运行状态；<br>**等待（WAITING）**：执行 wait()，join()，LockSupport.park() 方法时，JVM会把该线程放入等待池中；<br><br/>**阻塞（BLOCKED）**：线程在获取对象的同步锁（synchronized）时，若该锁被其他线程占用，<br>则该线程会进入对象监视器等待队列中；<br><br/>**限时等待（TIMED_WAITING）**：线程在设定的等待时间内时所处的状态，以下方法会设置定等待时间：<br>Thread.sleep <br/>带时限（timeout）的 Object.wait <br/>带时限（timeout）的 Thread.join <br/>LockSupport.parkNanos <br/>LockSupport.parkUntil |
| 等待状态（Waiting）  | 线程进入阻塞状态是被动的，而线程进入等待状态是主动的。       |
| 死亡状态（Dead）     | run() 或 call() 方法执行完成，线程变为死亡状态；<br/>线程抛出一个未捕获的 Exception 或 Error；<br/>直接调用该线程的 stop() 方法来结束该线程，该方法容易导致死锁，通常不推荐使用； |



## 用户调度

| 方式         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| **线程睡眠** | Thread.sleep(long millis) 静态方法，millis参数是睡眠时间，以毫秒为单位；<br>使线程转到阻塞状态；<br>不会释放当前线程所持有的锁；<br>当睡眠结束后，就转为就绪状态（Runnable）；<br>可以使用线程对象上 interrupt() 方法唤醒已 sleep 的线程，但会抛出 InterruptedException 异常；<br>sleep()之所以是静态方法，表示只作用于当前线程，不建议调用其他线程的 sleep 方法，否则会有线程死锁问题，因为不会释放锁。 |
| **线程让步** | Thread.yield() 静态方法；<br/>不会阻塞线程；<br/>不会释放当前线程所持有的锁；<br>暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程；<br/>将该线程从运行状态转入就绪（Runnable）状态，线程再次获取到CPU时间片时就会开始运行；<br>很有可能：当线程调用了 yield() 方法暂停之后进入就绪状态，又马上抢占了CPU的执行权，继续执行；<br>yield()之所以是静态方法，表示只作用于当前线程，不建议调用其他线程的 yield 方法，否则会有线程死锁问题，因为不会释放锁。 |
| **线程等待** | 指 Object 类中的 wait() 实例方法，等价于 wait(0)；<br>指一个线程已得到了某个对象的同步锁，然后又执行了 wait() 方法暂时让出某个对象的同步锁，<br/>以便其他正在等待此锁的线程可以得到同步锁并运行；<br>需要配合 synchronized 代码块使用；<br/>注意 wait 方法只让当前的线程进入等待状态；<br/>释放当前线程所持有的对象锁；<br>直到其他线程调用此对象的 notify() 方法、notifyAll() 唤醒方法或越过了超时时间的限制；<br/>唤醒线程后，就转为就绪（Runnable）状态；<br>可以使用线程对象上 interrupt() 方法唤醒已 wait 的线程，但会抛出 InterruptedException 异常； |
| **通知唤醒** | 指 Object 类中的 notify() 实例方法；<br/>调用某个对象上的 notify() 方法，会唤醒这个对象监视器上，正在等待的线程；<br/>如果所有线程都在此对象上等待，则会选择唤醒对象监视器上等待的一个线程，取决于cpu调度；<br/>类似的方法还有一个 notifyAll()，唤醒在此对象监视器上等待的所有线程；<br>需要配合 synchronized 代码块使用；<br/>注意：notify() 或者 notifyAll() 方法不会释放锁，必须等到 synchronized 方法或者同步代码块执行完才真正释放锁； |
| **线程暂停** | 使用suspend()方法暂停线程，线程变为挂起状态，但还持有锁，使用resume()方法使线程进入就绪状态；<br>线程操作同一个共享数据时，如果一个线程暂停了，其他线程再去取共享数据时，会出现数据不一致问题； |
| **线程加入** | 指线程类中的join()实例方法；<br/>在当前线程 t1 中调用线程 t2 的 join() 方法，表示线程 t1 立即进入阻塞状态，<br/>直到线程 t2 运行结束，当前线程 t1 再由阻塞转为就绪状态等待运行；<br/>注意当执行线程 t2 上的 join() 方法时，会释放线程 t2 实例对象的锁（因为 join 方法是 synchronized 修饰的，<br>也就是说 t1 线程得到了 t2 对象上的锁），但不会释放其它对象锁；<br>可以使用线程对象上 interrupt() 方法唤醒已 join 的线程，但会抛出 InterruptedException 异常； |
| **打断阻塞** | 指线程类上的interrupt()实例方法，意思是打断线程上的阻塞状态；<br>实际上只是将线程的中断标志设置为 true，线程仍会继续运行；<br>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待状态，<br/>或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。<br/><br/>若线程在以上阻塞与等待状态时，调用了这个线程的 interrupt() 方法，<br/>那么它的 “中断状态” 会被清除并且会收到一个 InterruptedException 异常。<br/>例如，线程通过wait()进入阻塞状态，此时通过 interrupt() 中断该线程；<br/>调用interrupt()会立即将线程的中断标记设为 true，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为 false，<br/>同时，会产生一个 InterruptedException 的异常。 <br/><br/>如果线程被阻塞在一个Selector选择器中，那么通过 interrupt() 中断它时；<br/>线程的中断标记会被设置为true，并且它会立即从选择操作中返回。<br/>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。 <br/><br/>中断一个“已终止的线程”不会产生任何操作，但一样会抛出 InterruptedException。 |
| **线程I/O**  | 线程执行某些 IO 操作，因为等待相关的资源而进入了阻塞状态；<br/>比如说监听 System.in，但是尚且没有收到键盘的输入，则进入阻塞状态； |



## 中断机制

首先`Thread.stop`、`Thread.suspend`、`Thread.resume`方法因不安全都己经被废弃了。

Java6提供了新的中断机制，即中断标识协商机制，在每个线程对象中都有一个中断标志，表示线程是否已被中断（true表示已中断，false表示未中断），通过调用线程对象的 `interrupt()` 方法将中断标志设置为true，接着需要程序员编写代码，通过 `Thread.isInterrupted()` 实例方法不断地检测中断标志来判断是否应终止线程，如果需终止线程还需要自己实现终止的业务逻辑（一般直接退出run方法即可）。

注意：开发人员也可以自定义一个 volatile 类型或 AtomBoolean 类型的中断标志位；

- interrupt()实例方法

  Thread.interrupt() 表示中断线程，只是将线程中断标志修改为true，线程是否退出取决于具体的实现；

  如果线程 t1 处于被阻塞状态，通过线程 a1 调用线程 t1 对象的 interrupt 方法，线程 t1 将立即退出被阻塞状态，并抛出一个 InterruptedException 异常，同时会清除中断标记（即 t1 线程调用 isInterrupted() 会返回 false）；

- interrupted()静态方法

  当线程调用Thread.interrupted()静态方法来返回中断状态时，中断状态会被重置为false；

  也就是说连续两次调用返回结果不一样，因为第二次再调用时中断状态已经被清除，将返回一个false；

- isInterrupted()实例方法

  方法只返回线程中断标志值（true表示已中断，false表示未中断），不会重置中断标志；



## 线程通信

线程间通信是协调线程间共享资源的重要的手段。Object类中 `wait() / notify() / notifyAll()` 方法可以用于线程间通信关于资源的锁的状态。



## 异常处理

可在`run()`方法中用try/catch语句捕获处理异常信息，但不推荐，更优雅的做法是使用未捕获异常处理器来处理线程运行期间抛出的异常；

- 未捕获异常处理器

  是Java5新特性，是指 `Thread.UncaughtExceptionHandler` 接口；

  线程可用 `setUncaughtExceptionHandler` 实例方法设置一个未捕获异常处理器；

  如果线程没有设置独立的未捕获异常处理器，默认使用该线程所属的线程组来处理异常，因为线程组实现了`Thread.UncaughtExceptionHandler`接口；

  线程组处理异常流程如下：

  1. 如果该线程组有父线程组，那么调用父线程组的 `uncaughtException` 方法；
  
  2. 否则，如果 `Thread.getDefaultExceptionHandler` 方法返回一个非空的处理器，则调用该处理器；
  
      可用 `Thread.setDefaultUncaughtExceptionHandler` 方法为所有线程设置一个默认的未捕获异常处理器；
  
  3. 否则，如果Throwable是ThreadDeath的一个实例（ThreadDeath对象由stop方法产生，而该方法已过时），什么都不做；
  
  4. 否则，使用System.err输出线程的名字以及异常的出错位置及原因；

  ```java
  public static void main(String[] args) {
  		UncaughtExceptionHandler eh = new UncaughtExceptionHandler() {
  			@Override
  			public void uncaughtException(Thread t, Throwable e) {
  				System.err.println("这是线程独立的异常处理器 ..");
  			}
  		};
  		
  		UncaughtExceptionHandler eh1 = new UncaughtExceptionHandler() {
  			@Override
  			public void uncaughtException(Thread t, Throwable e) {
  				System.err.println("所有线程默认的异常处理器 ..");
  			}
  		};
  		
  		Thread.setDefaultUncaughtExceptionHandler(eh1);
      // Thread.currentThread().setUncaughtExceptionHandler(eh);
  		
  		throw new RuntimeException("test");
  }
  ```



## 挂钩线程

挂钩线程（Hook Thread），当即将退出JVM（收到了中断信号）的时候，会执行挂钩线程中定义的业务逻辑。

```java
Runtime.getRuntime().addShutdownHook(new MyThread()); // 注册一个 shutdown hook thread
```



## 线程死锁

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。

**原因：**

- 交叉锁：

  比如线程A持有R1的锁等待R2的锁，线程B持有R2的锁等待R1的锁；

- 不可被剥夺条件

  指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源；

- 请求并持有条件

  指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源；

- 环路等待条件

  指在发生死锁时，必然存在一个（线程 — 资源）的环形链，即线程集合 {T0，T1，T2，…，Tn} 中的 T0 正在等待一个 T1 占用的资源，T1正在等待 T2 占用的资源，······Tn 正在等待已被 T0 占用的资源；

- 死循环

  比较常见，使用`jstack`等工具看不到死锁，但是程序不工作，`CPU`占有率高，这种死锁也叫系统假死，难以排查和重现；

**排查：**

- jps -l 命令
- jstack 进程编号
- jconsole（图形化方式）

**解决：**

只需要破坏掉至少一个构造死锁的必要条件即可，目前只有请求并持有和环路等待条件是可以被破坏的。



## 线程饥饿

如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为线程饥饿。

而该线程被饥饿致死正是因为它得不到CPU运行时间的机会。

解决饥饿的方案被称之为公平性（即所有线程均能公平地获得运行机会），使用Lock锁方式来替代同步锁提高公平性。



## 实例方法

| 方法                                                         | 返回值                           | 说明                                                         |
| ------------------------------------------------------------ | -------------------------------- | ------------------------------------------------------------ |
| Thread.currentThread()                                       | Thread                           | 静态方法 <br/>返回当前线程对象                               |
| Thread.holdsLock(Object o)                                   | boolean                          | 静态方法 <br/>判断线程是否拥有某个对象的锁                   |
| getId()                                                      | long                             | 返回线程编号                                                 |
| setName(String name)                                         | void                             | 设置线程名                                                   |
| getName()                                                    | String                           | 返回线程名                                                   |
| start()                                                      | void                             | 使用同步锁synchronized<br>启动线程，线程转入就绪状态         |
| run()                                                        | void                             | 调用Runnable接口，执行线程                                   |
| getState()                                                   | State                            | 返回线程状态                                                 |
| ~~stop()~~                                                   | ~~void~~                         | ~~过时方法~~                                                 |
| ~~stop(Throwable obj)~~                                      | ~~void~~                         | ~~过时方法~~                                                 |
| ~~destroy()~~                                                | ~~void~~                         | ~~过时方法~~                                                 |
| ~~suspend()~~                                                | ~~void~~                         | ~~过时方法~~                                                 |
| ~~resume()~~                                                 | ~~void~~                         | ~~过时方法~~                                                 |
| interrupt()                                                  | void                             | 详见本笔记的《中断机制》章节                                 |
| interrupted()                                                | boolean                          | 详见本笔记的《中断机制》章节                                 |
| isInterrupted()                                              | boolean                          | 详见本笔记的《中断机制》章节                                 |
| isAlive()                                                    | boolean                          | 判断当前的线程是否处于活动状态<br>活动状态就是线程已经启动且尚未终止，那么这时候线程就是存活的，则返回true，否则则返回false； |
| setPriority(int newPriority)                                 | void                             | 详见本笔记的《优先级》章节                                   |
| getPriority()                                                | int                              | 详见本笔记的《优先级》章节                                   |
| getThreadGroup()                                             | ThreadGroup                      | 返回当前线程所属的线程组                                     |
| activeCount()                                                | int                              | 此方法返回线程组及其子组中活动线程数的估计值（线程可能会变化） |
| enumerate(Thread tarray[])                                   | int                              | 将线程组及其子组中的每个活动线程复制到指定的数组中           |
| join(long millis)                                            | void                             | 使用同步锁synchronized<br/>让当前线程进入**<u>等待状态</u>**，等到被调用join的线程执行完毕才执行继续执行当前线程； |
| join(long millis, int nanos)                                 | void                             | 重载方法                                                     |
| join()                                                       | void                             | 重载方法，没有超时时间                                       |
| dumpStack()                                                  | void                             | 打印当前线程的堆栈跟踪到标准错误流                           |
| setDaemon(boolean on)                                        | void                             | 详见本笔记的《守护线程》章节                                 |
| isDaemon()                                                   | boolean                          | 判断当前线程是否是守护线程                                   |
| checkAccess()                                                | void                             | 判断当前运行的线程是否有修改线程的权限<br>如果不允许当前线程访问该线程，则抛出此异常 |
| getContextClassLoader()                                      | ClassLoader                      | 返回该线程的上下文类加载器                                   |
| setContextClassLoader(<br/>ClassLoader cl<br/>)              | void                             | 设置该线程的上下文类加载器<br>如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器 |
| getStackTrace()                                              | StackTraceElement[]              | 返回表示线程堆栈转储的堆栈跟踪元素数组                       |
| Thread.getAllStackTraces()                                   | Map<Thread, StackTraceElement[]> | 静态方法 <br>返回所有活动线程的堆栈跟踪的一个映射            |
| Thread.setDefaultUncaughtExceptionHandler(<br/>UncaughtExceptionHandler eh<br/>) | void                             | 静态方法<br>设置线程组的未捕获异常处理器                     |
| Thread.getDefaultUncaughtExceptionHandler()                  | UncaughtExceptionHandler         | 静态方法<br>返回线程组的未捕获异常处理器                     |
| setUncaughtExceptionHandler(<br/>UncaughtExceptionHandler eh<br/>) | void                             | 当线程由于未捕获的异常而突然终止时调用的默认处理程序         |
| getUncaughtExceptionHandler()                                | UncaughtExceptionHandler         | 返回当线程由于未捕获的异常而突然终止时调用的默认处理程序     |



## 虚拟线程

虚拟线程是 Java19引入的一种轻量级线程框架，也叫：协程、纤程、绿色线程、用户态线程等。

是为了提升高并发IO密集型任务的吞吐量，可以高效通过少数线程去调度大量虚拟线程；

虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，能最大化线程的执行效率；

虚拟线程使用普通线程相同的接口，最大的好处是无需修改任何代码，就可以将现有的IO操作异步化获得更大的吞吐能力；

计算密集型任务不应使用虚拟线程，只能通过增加CPU核心解决，或者利用分布式计算资源；

虚拟线程的接口和普通线程一样，唯一区别在于创建虚拟线程只能通过特定方法；

虚拟线程在Java19中是预览功能（默认未开启），可使用`--enable-preview`参数启用，如`java --source 19 --enable-preview Main.java`

**使用方式：**

- 直接创建虚拟线程并运行：

  ```java
  // 传入Runnable实例并立刻运行:
  Thread vt = Thread.startVirtualThread(() -> {
      System.out.println("Start virtual thread...");
      Thread.sleep(10);
      System.out.println("End virtual thread.");
  });
  ```

- 创建虚拟线程但不自动运行，而是手动调用`start()`开始运行：

  ```java
  // 创建VirtualThread:
  Thread.ofVirtual().unstarted(() -> {
      System.out.println("Start virtual thread...");
      Thread.sleep(1000);
      System.out.println("End virtual thread.");
  });
  // 运行:
  vt.start();
  ```

- 通过虚拟线程的ThreadFactory创建虚拟线程，然后手动调用`start()`开始运行：

  ```java
  // 创建ThreadFactory:
  ThreadFactory tf = Thread.ofVirtual().factory();
  // 创建VirtualThread:
  Thread vt = tf.newThread(() -> {
      System.out.println("Start virtual thread...");
      Thread.sleep(1000);
      System.out.println("End virtual thread.");
  });
  // 运行:
  vt.start();
  ```

  直接调用`start()`实际上是由`ForkJoinPool`的线程来调度的。我们也可以自己创建调度线程，然后运行虚拟线程：

  ```java
  // 创建调度器:
  ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
  // 创建大量虚拟线程并调度:
  ThreadFactory tf = Thread.ofVirtual().factory();
  for (int i=0; i<100000; i++) {
      Thread vt = tf.newThread(() -> { ... });
      executor.submit(vt);
      // 也可以直接传入Runnable或Callable:
      executor.submit(() -> {
          System.out.println("Start virtual thread...");
          Thread.sleep(1000);
          System.out.println("End virtual thread.");
          return true;
      });
  }
  ```

  由于虚拟线程属于非常轻量级的资源，因此，用时创建，用完就扔，不要池化虚拟线程；

**使用限制：**

注意到只有以虚拟线程方式运行的代码，才会在执行IO操作时自动被挂起并切换到其他虚拟线程。普通线程的IO操作仍然会等待，例如，我们在`main()`方法中读写文件，是不会有调度和自动挂起的。

可以自动引发调度切换的操作包括：

- 文件IO；
- 网络IO；
- 使用Concurrent库引发等待；
- Thread.sleep()操作；

这是因为JDK为了实现虚拟线程，已经对底层相关操作进行了修改，这样应用层的Java代码无需修改即可使用虚拟线程。无法自动切换的语言需要用户手动调用`await`来实现异步操作：

```java
async function doWork() {
    await readFile();
    await sendNetworkData();
}
```

在虚拟线程中，如果绕过JDK的IO接口，直接通过JNI读写文件或网络是无法实现调度的。此外，在`synchronized`块内部也无法调度。



## ThreadGroup

![img](./01.Java_part1.assets/JavaThreadGroup_0.png)

线程组表示一组线程的集合，可将一些功能相似的线程放到同一个线程组中，这样可以批量管理线程组中所有线程。

线程组内部是树状结构，也可以包含其他线程组，每个线程都能访问自己所属的线程组对象。

除了初始线程组外，每个线程组都有一个父线程组。

| 线程组方法                               |   返回值    | 说明                                                         |
| :--------------------------------------- | :---------: | ------------------------------------------------------------ |
| getName()                                |   String    | 返回线程组的名称                                             |
| getParent()                              | ThreadGroup | 返回当前组所属的线程组，即上级线程组                         |
| checkAccess()                            |    void     | 当前运行的线程是否具有修改线程组的权限                       |
| activeCount()                            |     int     | 此方法返回线程组及其子组中活动线程数的估计值（线程可能会变化） |
| activeGroupCount()                       |     int     | 此方法返回线程组及其子组中活动组数量的估计值（线程可能会变化） |
| ~~stop()~~                               |  ~~void~~   | ~~此方法用于停止线程组中的所有线程，已过时~~                 |
| destroy()                                |    void     | 销毁线程组及其所有子组，但不会销毁组内的线程                 |
| isDestroyed()                            |   boolean   | 判断线程组是否已被销毁                                       |
| ~~suspend()~~                            |  ~~void~~   | ~~挂起线程组中的所有线程，包括当前线程，已过时~~             |
| ~~resume()~~                             |  ~~void~~   | ~~按顺序批量调用组内所有线程的`suspend()`方法，已过时~~      |
| parentOf(ThreadGroup g)                  |   boolean   | 判断当前对象是否是属于参数或参数的上级线程组                 |
| enumerate(Thread[] list)                 |     int     | 将线程组及其子组中的每个活动线程复制到指定的数组中           |
| interrupt()                              |    void     | 中断线程组中的所有线程                                       |
| isDaemon()                               |   boolean   | 是否为守护线程组                                             |
| setDaemon(boolean d)                     |    void     | 设置线程组是否是守护线程组<br>注意此属性会传到给组中每一个线程 |
| setMaxPriority(int pri)                  |    void     | 此方法设置组的优先级<br>注意参数不能高于当前线程组的上级线程组的优先级；<br>注意这个优先级会传递给组内的所有线程 |
| getMaxPriority()                         |     int     | 返回线程组的优先级                                           |
| uncaughtException(Thread t, Throwable e) |    void     | 如果有上级线程组，则使用上级线程组的`uncaughtException(t, e)`方法执行参数；<br>否则使用`Thread.UncaughtExceptionHandler`接口处理参数<br>如果上步未执行，则只是打印异常信息及错误位置 |
| list()                                   |    void     | 使用 `System.out` 输出当前线程组信息、组中线程信息、子线程组信息 |



## ThreadLocal

线程变量，表示 ThreadLocal 中的变量是每个线程独有的，该变量对其他线程是不可见的。

ThreadLocal仅仅是个变量访问的入口，每个线程都有一个ThreadLocalMap对象，ThreadLocalMap用于保存线程变量。

调用 ThreadLocal 的 set() 方法时，实际上就是往 ThreadLocalMap 设置值，key 是 ThreadLocal 对象，value 值是传递进来的变量。

调用 ThreadLocal 的 get() 方法时，实际上就是从 ThreadLocalMap 获取值，key 是 ThreadLocal 对象，返回线程变量。

![ThreadLocalMap](./01.Java_part1.assets/ThreadLocalMap.png)

一定要在不使用某个ThreadLocal对象后，手动调用remove方法来删除数据。

| 方法          | 返回值 | 说明                                                  |
| ------------- | ------ | ----------------------------------------------------- |
| ThreadLocal() | 无     | 构造方法                                              |
| get()         | <T>    | 从线程的ThreadLocalMap中获取设置的值。                |
| set(T value)  | void   | 将参数对象保存到当前线程的ThreadLocalMap中            |
| remove()      | void   | 将ThrealLocal对应的值从当前线程的ThreadLocalMap中删除 |

问题：

- 内存泄漏

  ThreadLocalMap类中键（key）是弱引用，当外面强引用的KEY被设置为null或不再被使用时，当GC时这个ThreadLocal就没有任何一条链路能够引用到，势必会被回收。这样一来ThreadLocalMap中就会出现键（key）为 null 的 Entry，会造成内存泄漏；

- 系统BUG

  如果是在线程池中，不仅仅会有内存泄露的问题，因为线程池中的线程是重复使用的，意味者这个线程的ThreadLocalMap对象也是重复使用的，如果不手动调用remove方法删除数据，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug；

例如：

```java
HttpServletRequest xxx = ...;
ThreadLocal<HttpServletRequest> LOCAL = new ThreadLocal<HttpServletRequest>();
try {
  LOCAL.set(xxx);
} finally {
  LOCAL.set(null); // 使用完毕后，一定要删除数据
}
```



## 线程转储

是指 Java虚拟机的活动线程列表，也可看成是线程活动的日志，对于分析系统瓶颈和死锁非常有用，可通过 jstack工具生成线程转储文件。



## jstack

https://www.jianshu.com/p/08b816d9b34f

可以生成虚拟机当前时点的线程快照，线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，在发生线程死锁、死循环、长时间暂停等情况时，可以根据线程快照来快速分析定位问题所在。

jstack工具可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息。

```shell
$ jstack [option] LVMID

选项：
-F : 当正常输出请求不被响应时，强制输出线程堆栈
-l : 除堆栈外，显示关于锁的附加信息
-m : 如果调用到本地方法的话，可以显示C/C++的堆栈
```

例如：

```shell
# 输出线程转储信息到文件或控制台
$ jstack PID >> mydumps.dump

# 输出线程转储信息到控制台
$ jstack PID
```



```shell
$ jstack -l 11494|more
2016-07-28 13:40:04
Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.71-b01 mixed mode):

"Attach Listener" daemon prio=10 tid=0x00007febb0002000 nid=0x6b6f waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
        - None

"http-bio-8005-exec-2" daemon prio=10 tid=0x00007feb94028000 nid=0x7b8c waiting on condition [0x00007fea8f56e000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000cae09b80> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
        - None
      .....
```



------



# 锁与同步器

| 锁类型                   | 说明                                                         |                                                              |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 乐观锁                   | 先取数，再加锁                                               | CAS                                                          |
| 悲观锁                   | 先加锁，再取数                                               | synchronized 作用于实例方法上时，锁的是对象<br/>synchronized(对象) {} 同步代码块，锁的是小括号中的对象；<br/>synchronized 作用于静态方法上使用时，表示类锁，锁的是 Class 对象； |
| 可重入锁/递归锁          | 也叫递归锁，是指同一个线程在外层方法获取锁的时候，<br/>再进入该线程的内层方法会自动获取锁（前提，锁对象得是同一个对象）<br/>不会因为之前己经获取过还没释放而阻塞； | ReentrantLock和synchronized都是可重入锁；                    |
| 可中断锁                 | 是指线程在等待获取锁过程中可被中断                           |                                                              |
| 互斥锁                   | 对资源读取和写入的时候拆分为二部分处理，读的时候可以多线程一起读，写的时候必须同步地写； |                                                              |
| 读写锁                   | 读锁和写锁不能同时使用，是互斥的；                           |                                                              |
| 公平锁                   | 是指多个线程按照申请锁的顺序来获取锁，类似于排队买票，先来的先得 | ReentrantLock<br/>ReentrantReadWriteLock                     |
| 非公平锁                 | 是指多个线程获取锁的顺序，不是按照申请顺序，有可能造成优先级反转或饥饿的状态（某个线程一直得不到锁） | ReentrantLock                                                |
| ⾃旋锁（SpinLock）       | 是线程通过CAS获取预期的⼀个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程⼀直在运⾏中，相对⽽⾔没有使⽤太多的操作系统资源，⽐较轻量 |                                                              |
| 自适应锁                 | 自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有这的状态来决定的 |                                                              |
| 偏向锁/轻量级锁/重量级锁 | 这三种锁的状态，都是针对Synchronized锁升级过程来说的<br/>偏向锁：对象头中记录线程ID，下次进入时直接比较线程ID，相同则直接进入即可；<br/>轻量锁：当⼀个线程获取到锁后，如果有第⼆个线程来竞争锁，会升级为轻量级锁；<br/>重量锁：轻量级锁⾃旋次数过多，仍然没有获取到锁，则会升级为重量级锁； | Synchronized                                                 |
| 邮戳锁                   | 也叫票据锁                                                   |                                                              |
| 分段锁                   | 分段锁其实是一种锁的设计，例如ConcurrentHashMap，其并发的实现就是通过分段锁的形式来实现高效的并发操作 |                                                              |
| 隐式锁                   | 即 synchronized 关键字使用的锁                               |                                                              |
| 显式锁                   | 即 Lock 也有 ReentrantLock 这种可重入锁                      |                                                              |
| 排他锁                   | 同一时间只有一个线程能获得锁                                 | ReentrantLock和synchronized全部都是排他锁                    |
| ⾏锁                     | 锁某⾏数据，锁粒度最⼩，并发度⾼                             |                                                              |
| 表锁                     | 锁整张表，锁粒度最⼤，并发度低                               |                                                              |
| 间隙锁                   | 锁的是⼀个区间                                               |                                                              |
| 共享锁                   | 也就是读锁，⼀个事务给某⾏数据加了读锁，其他事务也可以读，但是不能写 |                                                              |
| 独享锁/排它锁            | 也就是写锁，⼀个事务给某⾏数据加了写锁，其他事务不能读，也不能写 |                                                              |



------



## CAS

CAS是 Java提供的非阻塞原子操作，是乐观锁（先取数再加锁），底层使用Unsafe类实现，更新值之前先与期望值比较，如果与期望值一致则更新且返回true，如果不一致则不更新且返回一个false。

Unsafe提供的CAS方法（如compareAndSwapxxX）底层实现即为CPU指令cmpxchg，执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是多核系统就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行CAS操作，也就是说CAS的原子性实际上是CPU实现独占的，比起用synchronized重量级锁，这里的排他时间要短很多，所以在多线程情况下性能会比较好。

**原子操作**

在Java Concurrency API中有哪些原子类（atomic classes）

原子操作是指一个不受其他操作影响的操作任务单元，原子操作是在多线程环境下避免数据不一致必须的手段。

int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。

在java.util.concurrent.atomic包中添加原子变量类之后，这种情况才发生了改变。所有原子变量类都公开比较并设置原语（与比较并交换类似），这些原语都是使用平台上可用的最快本机结构（比较并交换、加载链接/条件存储，最坏的情况下是旋转锁）来实现的。 

java.util.concurrent.atomic 包中提供了原子变量的 9 种风格（AtomicInteger； AtomicLong； AtomicReference； AtomicBoolean；原子整型；长型；引用；及原子标记引用和戳记引用类的数组形式，其原子地更新一对值）。

| CAS操作常用类               | 说明                                                         |
| :-------------------------- | ------------------------------------------------------------ |
| AtomicBoolean               | 一种原子性地读写布尔类型变量的解决方案                       |
| AtomicInteger               | 用于多线程下线程安全的数据读写操作，避免使用锁同步，底层采用CAS实现<br>内部的存储值使用**<u>volatile</u>**修饰，因此多线程之间是修改可见的。 |
| AtomicLong                  | AtomicLong是作用是对长整形进行原子操作。                     |
| AtomicLongArray             | 是对长整形数组进行原子操作，可以用原子方式更新其元素的 long 数组 |
| AtomicReference             | 原子引用                                                     |
| AtomicReferenceArray        | 以原子的方式更新值                                           |
| AtomicintegerArray          | 以原子的方式更新值                                           |
| AtomicLongFieldUpdater      | 控制精确的对数组中的某个成员进行加锁                         |
| AtomicintegerFieldUpdater   | 控制精确的对数组中的某个成员进行加锁                         |
| AtomicReferenceFieldUpdater | 控制精确的对数组中的某个成员进行加锁                         |
| AtomicStampedReference      | 原子引用类：可以精确控制对象中的 public volitate 修饰的变量值<br>使用流水号/版本号判断是否与期望值相符 |
| AtomichlarkableReference    | 使用一个boolean值作为参数，通过比较这个参数来判断是否发生变化，只能变化一次 |
| DoubleAdder                 | 从JDK8开始提供的API，实现了热点分离细化了锁的粒度，大幅提升高并发能力 |
| LongAdder                   | 从JDK8开始提供的API，实现了热点分离细化了锁的粒度，大幅提升高并发能力 |
| DoubleAccumulator           | 类似于 LongAdder 类的热点分离类，提供了自定义的函数功能，初始化时传入一个自定义方法与一个初始值 |
| LongAccumulator             | 类似于 LongAdder 类的热点分离类，提供了自定义的函数功能，初始化时传入一个自定义方法与一个初始值 |

**缺点：**

- 大量并发访问资源时，CAS操作会导致空循环占用大量CPU资源；
- Atomicinteger等会导致出现ABA问题，如：资源A被其他线程修改为B，后又被其他线程改回为A，这次对于其他线程是看不出有变化的过程，可以用 AtomicStampedReference解决；

从下面流程图可以看出来，大量的线程同时并发修改一个AtomicInteger，可能有很多线程会不停的自旋，进入一个无限重复的循环中。这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。在大量线程高并发更新 AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。



## LongAdder

是Java8新特性，使用分段CAS以及自动分段迁移技术，可以大幅度提升多线程高并发时性能。

![CAS0](./01.Java_part1.assets/CAS0.png)

LongAdder核心思想就是热点分离，这一点和 ConcurrentHashMap 的设计思想相似。就是将value值分离成一个数组，当多线程访问时，通过hash算法映射到其中的一个数字进行计数。而最终的结果，就是这些数组的求和累加，这样一来就减小了锁的粒度。



------



## volatile机制

<a href="https://blog.csdn.net/laohuangaa/article/details/122755171">volatile关键字</a>修饰变量时，表示变量值被一个线程变更过，其他线程会立即可见，不会出现脏读，但会出现不可重复读问题；

- volatile特性

  - 可见性

    当一个线程修改用volatile修饰的变量时，修改后的变量值对于其他要读写该变量的线程来说是立即可见的；

    底层原理是基于CPU的缓存一致性协议（MESI 协议）实现的，线程在写voliate变量的时候，会在该指令前加一个CPU的lock指令，处理器会将缓存写回到主内存中，然后再基于总线嗅探机制通知其他处理器更新缓存中该数据的状态为无效，其他处理器对这个数据进行读和写操作时，会重新从主内存中把该数据读到处理器缓存中；

  - 有序性

    会禁⽌编译器对volatile变量临界区代码的指令重排，从⽽保证程序有序性运行；

    底层原理是基于内存屏障（Memory Barrier，内存栅栏）实现的，编译器在遇到对volatile变量的读写代码时，会在变量前后插入JVM内存屏障指令，防止编译器对临界区代码进行指令重排；

    - 为什么有内存屏障

      在JMM规范中约定了代码并不一定会按照编写顺序运行，编译器会对指令进行重排优化，如果不想使用指令重排时，可以使用内存屏障指令；

    - 写屏障（Store Memory Barrier）

      写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后；

      ```java
      public void actor2(Result r) {
        num = 2;
        ready = true; // ready是被volatile修饰的, 赋值带写屏障
        // 写屏障
      }
      ```

    - 读屏障（Load Memory Barrier）

      读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前；

      ```java
      public void actor1(Result r) {
        // 读屏障
        // ready是被volatile修饰的, 读取值带读屏障
        if(ready) {
           r.r1 = num + num;
        } else {
           r.r1 = 1;
        }
      }
      ```

    - 内存屏障类型

      | 类型           | 抽象场景                     | 解释                                   |
      | -------------- | ---------------------------- | -------------------------------------- |
      | LoadLoad屏障   | 读指令1; LoadLoad; 读指令2   | 表示读指令1一定会在读指令2的前面执行； |
      | StoreStore屏障 | 写指令1; StoreStore; 写指令2 | 表示写指令1一定会在写指令2的前面执行； |
      | LoadStore屏障  | 读指令; LoadStore; 写指令2   | 表示读指令1一定会在写指令2的前面执行； |
      | StoreLoad屏障  | 写指令1; StoreLoad; 读指令2  | 表示写指令1一定会在读指令2的前面执行； |

  - 不保证原子性

    多个线程可以同时对volatile变量进行修改，这时会互相覆盖变量值，导致无法实现原子性；

- volatile变量和atomic变量不同

  - volatile底层是基于内存屏障来实现的，atomic是基于与预期值比较方式来实现的；
  - volatile不支持原子操作，atomic是原子操作类；

- 需要注意的缺点

  因为volatile底层实现是基于嗅探机制，大量使用时可能引起总线风暴（即由于volatile的缓存一致性协议需要不断的从主内存嗅探和CAS循环需要大量无效交互，会导致总线带宽达到峰值），往往使用synchronize或者Lock来代替；



------



## synchronized

[Synchronized基础概念](https://blog.csdn.net/Roker_966/article/details/127447306)

同步锁，synchronized是关键字，底层是在JVM层面实现的同步锁，可以在对象上加锁（锁会升级）与释放锁，锁信息保存在对象头中，出现异常会自动释放锁；

- 作用范围

  - 修饰实例方法

    锁住的是实例方法所属的对象；

  - 修饰静态方法

    锁住的是Class对象；

  - 修饰代码块

    锁住的是所有以该对象为锁的代码块；

    同步块是更好的选择，因为不会锁住整个对象，同步方法会锁住整个对象；

- 优化策略

  在JDK1.5之前同步锁是一个重量级锁，在JDK1.5中增加了CAS自旋；

  在JDK1.6中增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁等优化策略，性能得到了极大的提升；

  - 自适应自旋

    是指自旋的次数不再是固定的，如果线程通过自旋成功获得了锁，那么下次自旋次数会增加，因为虚拟机认为既然上次成功了，那么下次自旋也很有可能会再次成功。反之，如果很少有自旋能成功获得锁，那么在以后要获得这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费**CPU**资源；

  - 锁消除

    在JIT编译时，会通过对运行上下文的扫描，经过逃逸分析，判断出某段代码不存在竞争的可能性，就会将这段代码的锁消除；

  - 锁粗化

    这也是一种优化，通过扩大锁的范围，从而减少了加锁与释放的频率；

    ```java
    public class Test {
        public void method() {
            for (int i = 0; i < 10000; i ++) {
                synchronized (this) {
                    System.out.println("运行时发现不存在竞争");
                }
            }
        }
    }
    ```

    被优化为：

    ```java
    public class Test {
        public void method() {
            synchronized (this) {
                for (int i = 0; i < 10000; i++) {
                    System.out.println("运行时发现不存在竞争");
                }
            }
        }
    }
    ```

- 锁的状态与升级

  同步锁有四种状态：无锁、偏向锁、轻量级锁、重量级锁。锁升级的过程如下所示，升级是单向的（从低到高升级），不会出现锁的降级；

  1. 无锁

     当对象被创建，且还没有线程访问，这个时候对象处于无锁状态，其**Mark Word**中的信息如下表所示；

     | 锁状态   | 25bit          | 4bit         | 1bit（是否为偏向锁） | 2bit（锁标志位） |
     | -------- | -------------- | ------------ | -------------------- | ---------------- |
     | 无锁状态 | 对象的hashcode | 对象分代年龄 | 0                    | 01               |

  2. 偏向锁

     当锁处于无锁状态，有线程尝试获得同步锁时，会用CAS指令，将对象头的**Mark Word**中线程ID登记为当前线程的ID，如果成功，则表示得到了同步锁；

     | 锁状态 | 23bit  | 2bit  | 4bit         | 1bit（是否为偏向锁） | 2bit（锁标志位） |
     | ------ | ------ | ----- | ------------ | -------------------- | ---------------- |
     | 偏向锁 | 线程ID | Epoch | 对象分代年龄 | 1                    | 01               |

     优点：加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差距；

     缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗；

  3. 轻量级锁

     在偏向锁的基础上，有另外一个线程V来尝试获得对象上的锁，如果对象头中存储的线程ID和线程V不一致，会升级为轻量级锁，在线程的栈中创建一个锁记录（Lock Record，结构如下表所示），用于存储锁对象的Mark Word的拷贝（官方称为Displaced Mark Word），然后线程尝试使用CAS指令将对象头中Mark Word的前30位地址修改为锁记录的指针。如果成功，则获得锁；如果失败，则继续尝试使用CAS指令来获取锁；

     | 属性      | 说明                                                         |
     | --------- | ------------------------------------------------------------ |
     | Owner     | 初始时为NULL表示当前没有任何线程拥有该monitor record， 当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL; |
     | EntryQ    | 关联一个系统互斥锁（semaphore），阻塞所有试图得到monitor record失败的线程； |
     | RcThis    | 表示blocked或waiting在该monitor record上的所有线程的个数；   |
     | Nest      | 用来实现重入锁的计数；                                       |
     | HashCode  | 保存从对象头拷贝过来的HashCode值（可能还包含GC age）；       |
     | Candidate | 用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞<br/>或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有<br/>两种可能的值，0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁； |

     | 锁状态   | 23bit+2bit+4bit+1bit                | 2bit（锁标志位） |
     | -------- | ----------------------------------- | ---------------- |
     | 轻量级锁 | 指向栈中锁记录（Lock Record）的指针 | 00               |

  4. 重量级锁

     如果线程通过CAS自旋不能获得锁，那么就会升级成为重量级锁，对象的Mark Word如下所示，指向一个监视器（Monitor）；

     | 锁状态   | 23bit+2bit+4bit+1bit         | 2bit（锁标志位） |
     | -------- | ---------------------------- | ---------------- |
     | 重量级锁 | 指向互斥量（重量级锁）的指针 | 10               |

     监视器的是用C++实现的，数据结构如下所示；

     |        属性         | 默认值 | 说明                                                         |
     | :-----------------: | :----: | ------------------------------------------------------------ |
     |       _header       |  NULL  | 猜测是对象头地址                                             |
     |       _count        |   0    | 线程获取锁的次数，获取锁时count数值加1，释放锁时count值减1   |
     |      _waiters       |   0    | 等待线程数                                                   |
     |     _recursions     |   0    | 发生线程重入时，计数器加1，退出时计数器减1                   |
     |       _object       |  NULL  | 存储该monitor的对象                                          |
     |       _owner        |  NULL  | 持有 Monitor 的线程地址，即对象头的Mark Word属性的部分值     |
     |      _WaitSet       |  NULL  | 等待队列，是由ObjectWaiter构成的单向链表；<br>用于存放调用 wait() 方法的线程； |
     |    _WaitSetLock     |   0    |                                                              |
     |    _Responsible     |  NULL  |                                                              |
     |        _succ        |  NULL  |                                                              |
     |        _cxq         |  NULL  | 锁竞争队列（ContentionList）是由ObjectWaiter构成的单向链表；<br>所有请求锁的线程首先会被放在这个队列中；<br/>cxq是一个临界资源<br/>在队头添加新节点，通过CAS指令改变队头的指针为新增节点，新增节点的 next 指向后续节点；<br/>因此cxq是一个后进先出的stack（栈）； |
     |      FreeNext       |  NULL  |                                                              |
     |     _EntryList      |  NULL  | 竞争候选列表（EntryList）是由ObjectWaiter构成的双向链表；<br>cxq队列会存在多个线程并发访问，为了降低cxq队列的并发压力而建立了EntryList；<br>cxq队列中有资格成为候选资源的线程会被移动到EntryList队列中；<br>在EntryList队列中选择一个线程（一般为队头）为 Ready 状态，即 OnDeck |
     |      _SpinFreq      |   0    | 自旋的频率                                                   |
     |     _SpinClock      |   0    | 自旋的次数；<br>如果线程被阻塞的时间很短，则该线程可能刚进入阻塞状态又马上要被唤醒，这个操作很耗时；<br>为了解决这种短暂的阻塞，最好的办法就是先自旋一定次数，再让线程进入阻塞； |
     |    OwnerIsThread    |   0    |                                                              |
     | _previous_owner_tid |   0    | 上一次获得锁的线程信息                                       |

     **加锁流程：**

     ![JavaSynchronizedMonitor](./01.Java_part1.assets/JavaSynchronizedMonitor.png)

     - 持有锁

       如果Monitor的所有者（owner）为null，则用CAS自旋指令将owner修改为该线程地址，进入数（count）设置为1；

       如果线程已获得该锁，则再次进入Monitor时，重入数（recursions）加1；

     - 进入等待队列

       当得到锁的线程调用对象的wait()方法时会释放锁：owner恢复位null、count--、recursions--，线程进入到WaitSet等待队列中；

       直到其他线程调用对象上的notify()或notifyAll()方法唤醒线程，把被唤醒的线程从WaitSet队列转移到EntryList队列中；

       配合同步代码块使用notify/notifyAll/wait方法：因为会用到对象的Monitor，所以不在同步代码块中使用会抛IllegalMonitorStateException异常；

     - 进入阻塞队列

       如果有线程已获得了同步锁，则其他线程再尝试获得锁时，首先用CAS自旋指令尝试获得锁（非公平锁机制）；

       如果CAS自旋获得锁失败，则线程会进入cxq队列中等待；

     - 释放锁

       在释放锁之前，如果EntryList队列为空，且cxq队列不为空，持有锁的线程会将cxq队列中的元素转移到EntryList队列中；

       持有锁的线程会在EntryList队列中选择一个线程（一般为队头），将其线程状态设置为就绪状态，即OnDeck线程；

       持有锁的线程会将Monitor的owner恢复为null、count--、recursions--，线程状态变为死亡状态；

       OnDeck线程重新竞争锁，如果竞争成功，则持有锁，等待分配CPU资源；

       如果竞争失败，线程依然会停留在EntryList队列中（位置不变）；

- **相关参数**

  | 参数                          | 说明                                     | 默认值      | JDK版本 |
  | ----------------------------- | ---------------------------------------- | ----------- | ------- |
  | -XX:+UseBiasedLocking         | 开启偏向锁                               | 开启        | JDK1.6  |
  | -XX:BiasedLockingStartupDelay | 启动后多久开启偏向锁                     | 4（单位秒） | JDK1.6  |
  | -XX:+UseHeavyMonitors         | 禁用偏向锁和轻量锁，只用重量锁（无值型） | 未开启      |         |
  | -XX:+DoEscapeAnalysis         | 开启逃逸分析（无值型）                   | 开启        |         |
  | -XX:-Eliminatelocks           | 开启锁消除（无值型）                     | 未开启      |         |
  | -XX:+UseSpinning              | 开启自旋锁（无值型）                     | 开启        | JDK1.6  |
  | -XX:PreBlockSpin              | 在指定自旋锁次数后升级                   | 10（次）    | JDK1.6  |

- **双重锁的单例模式**

  ```java
  // 单例延迟加载模式
  private Person person;
  public Person getPerson2() {
  	if(this.person == null) {
       this.person = new Person();
  	}
    return this.person;
  }
  
  // 双重锁的单例延迟加载模式
  private volatile Person person;
  public Person getPerson() {
  	if(this.person == null) {
  		synchronized(this) {
        if(this.person == null) {
          this.person = new Person();
        }
      }
  	}
    return this.person;
  }
  ```

  如上所示第5行初始化Person对象时分三步：（1）给 Person 分配内存（2）调用 Person 构造方法来初始化成员变量（3）将对象指向分配的内存空间；因为编译器会对指令进行重排，则可能导致（2）和（3）的执行顺序互换。如果先执行了（3）,此时`this.person`引用不为null，这时其他线程再访问这个方法时，就得到了还执行初始化的对象，导致报错；可以用volatile+synchronized+DCL（双检查）的模式解决上诉问题，如上示例中第11-21行代码！



------



## AQS

队列同步器，ASQ是 AbstractQueuedSynchronizer类的缩写，是锁和同步器的框架，内部使用一个用 volatile修饰的 int变量 state来表示同步状态，`state>=n` 表示已有 n 个线程竞争锁，`state==0` 表示锁是空闲状态，如果同时有多个线程尝试获取锁，会导致线程安全性问题，使用CAS机制保证state互斥变量的原子性。使用 `LockSupport.park` 方法阻塞未获取到锁的线程，并把阻塞线程按照 FIFO的原则加入到一个双向链表CHL中，当锁被释放后，会从双向链表的头部唤醒下一个等待的线程去竞争锁；

使用 AQS框架可以实现排他锁和共享琐：

实现排他锁（Exclusive）只需实现 tryAcquire与 tryRelease方法。

实现共享锁（Share）只需实现 tryAcquireShared与 tryReleaseShared方法。

| 抽象方法                            | 返回值  | 说明                                                         |
| ----------------------------------- | :-----: | ------------------------------------------------------------ |
| isHeldExclusively()                 | boolean | 抽象方法；<br>该线程是否正在独占锁；<br/>只有用到Condition才需要去实现这个方法； |
| tryAcquire(<br/>int arg<br/>)       | boolean | 抽象方法；<br/>独占方式；<br>尝试获取锁，成功返回 true，失败返回 false；<br>arg：为尝试获取锁的次数； |
| tryRelease(<br/>int arg<br/>)       | boolean | 抽象方法；<br/>独占方式；<br/>尝试释放锁，成功返回 true，失败返回 false；<br>arg：为释放锁的次数； |
| tryAcquireShared(<br/>int arg<br/>) |   int   | 抽象方法；<br/>共享方式；<br/>尝试获取锁；<br>arg：为尝试获取锁的次数；<br>返回值为负数表示失败；<br/>返回值为0表示成功，但没有剩余可用资源；<br/>返回值为正数表示成功，且有剩余资源； |
| tryReleaseShared(<br/>int arg<br/>) | boolean | 共享方式；<br/>尝试释放资源，成功返回 true，失败返回false；<br>arg：为尝试释放锁的次数； |

注意：排他锁是不响应线程中断操作的，即中断某个阻塞的线程是不会抛出 InterruptedException异常的，而是再次去判断其前驱节点是否为 head节点，决定是否争抢同步状态。如果其前驱节点不是 head节点或者争抢同步状态失败，那么再次阻塞等待；




------



## Lock接口

是Java5新特性，Lock方式比synchronized灵活，接口的实现类大都基于AQS框架，底层主要靠 volatile 和 CAS，使用FIFO的CLH同步队列保存被阻塞的线程；

| Lock接口方法                                     |  返回值   | 说明                                                         |
| ------------------------------------------------ | :-------: | ------------------------------------------------------------ |
| lock()                                           |   void    | 获取锁，如果锁不可用，则当前线程将被阻塞，直到获取到锁；     |
| lockInterruptibly()                              |   void    | 获取锁，如果锁不可用，则当前线程将被阻塞；<br>线程在等待获取锁时，如果遇到线程中断会抛出异常，退出等待； |
| tryLock()                                        |  boolean  | 如果锁可用，立即返回true；<br/>如果锁不可用，立即返回false；<br/>不会阻塞当前线程； |
| tryLock(<br/>long time, <br/>TimeUnit unit<br/>) |  boolean  | 如果锁可用，则此方法立即返回true；<br/>如果锁不可用，则当前线程转为阻塞状态，直到发生以下三种情况之一为止：<br/>当前线程获取到该锁；<br/>当前线程被中断；<br/>在指定时间内得到了锁，返回true；<br>在指定时间内没得到锁，返回false； |
| unlock()                                         |   void    | 释放锁；<br/>释放锁的操作放在finally块中进行，确保锁一定被被释放，防止死锁的发生； |
| newCondition()                                   | Condition | 条件变量；<br/>Condition接口的作用与Object的wait()/notify()方法类似，可以让线程进入等待状态，并唤醒线程； |



------



## Condition接口

是Java5新特性，与Object的wait()/notify()方法类似，能使阻塞线程、唤醒被阻塞的线程，Condition接口的实现完全使用Java代码；

| Condition接口方法                              | 返回值  | 说明                                                         |
| ---------------------------------------------- | :-----: | ------------------------------------------------------------ |
| await()                                        |  void   | 阻塞当前线程；<br>该方法可以被中断，会抛出InterruptedException异常 |
| awaitUninterruptibly()                         |  void   | 阻塞当前线程；<br/>但这个方法等待过程中不能响应中断操作；    |
| awaitNanos(<br/>long nanosTimeout<br/>)        |  long   | 阻塞线程，直到耗尽指定纳秒；<br>当线程被中断、等待超时、被signal()/signalAll()唤醒，会退出阻塞状态； |
| await(<br/>long time, <br/>TimeUnit unit<br/>) | boolean | 阻塞线程，直到耗尽指定的时间；<br/>当线程被中断、等待超时、被signal()/signalAll()唤醒，会退出阻塞状态； |
| awaitUntil(<br/>Date deadline<br/>)            | boolean | 阻塞线程，直到超过了指定时间；<br/>当线程被中断、越过了指定的时间、被signal()/signalAll()唤醒，会退出阻塞状态； |
| signal()                                       |  void   | 只随机唤醒一个等待的线程                                     |
| signalAll()                                    |  void   | 唤醒所有在锁上等待线程                                       |



------



## ReadWriteLock接口

是Java5新特性，读写锁接口是用来提升并发程序性能的锁分离技术；

| 方法        | 返回值 | 说明               |
| ----------- | ------ | ------------------ |
| readLock()  | Lock   | 返回一个专用的读锁 |
| writeLock() | Lock   | 返回一个专用的写锁 |



------



## ReentrantLock

叫可重入锁，是一个基于AQS框架和Lock接口的可重入的互斥锁。

| 独有方法                                | 返回值  | 说明                                                    |
| --------------------------------------- | ------- | ------------------------------------------------------- |
| ReentrantLock()                         |         | 构造方法；<br>是非公平锁；                              |
| ReentrantLock(boolean fair)             |         | 构造方法；<br>fair：true表示公平锁，false表示非公平锁； |
| getHoldCount()                          | int     | 返回当前线程调用lock()方法的次数                        |
| isHeldByCurrentThread()                 | boolean | 判断当前线程是否已持有此锁                              |
| isLocked()                              | boolean | 判断是否已有线程持有此锁                                |
| isFair()                                | boolean | 判断是否是公平锁                                        |
| getOwner()                              | Thread  | 返回拥有此锁的线程，没有返回null                        |
| hasQueuedThreads()                      | boolean | 判断是否有正在等待获取此锁的线程                        |
| hasQueuedThread(Thread thread)          | boolean | 判断指定线程是否正在等待获取此锁                        |
| getQueueLength()                        | int     | 返回正等待获取此锁的线程数（预估数）                    |
| hasWaiters(Condition condition)         | boolean | 判断是否有正等待此锁指定同步条件的线程                  |
| getWaitQueueLength(Condition condition) | int     | 返回在条件队列中与此锁关联的大概的线程数                |

例如：

```java
public class TestReentrantLock {
    private String[] elements = new String[10]; // 容器底层的数据结构
    private Lock lock = new ReentrantLock(); // 锁对象
    private Condition notFullCondition = lock.newCondition(); // 不为满条件
    private Condition notEmptyCondition = lock.newCondition(); // 不为空条件
    private int elementCount; // 数组elements中的元素数量
    private int putIndex; // 写指针
    private int takeIndex; // 读指针

    // 生产者
    public void put(String element) throws InterruptedException {
        lock.lock();
        try {
            while (elementCount == elements.length) {
                notFullCondition.await();
            }
            elements[putIndex] = element;
            if (++putIndex == elements.length) {
                putIndex = 0;
            }
            elementCount++;
            System.out.println("after put:" + Arrays.asList(elements));
            notEmptyCondition.signal();
        } finally {
            lock.unlock();
        }
    }

    // 消费者
    public String take() throws InterruptedException {
        lock.lock();
        try {
            while (elementCount == 0) {
                notEmptyCondition.await();
            }
            String element = elements[takeIndex];
            elements[takeIndex] = null;
            if (++takeIndex == elements.length) {
                takeIndex = 0;
            }
            elementCount--;
            System.out.println("after take:" + Arrays.asList(elements));
            notFullCondition.signal();
            return element;
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        BoundedContainer boundedContainer = new BoundedContainer(); // 启动10个读线程和10个写线程
        IntStream.range(0, 10).forEach(i -> new Thread(() -> {
            try {
                boundedContainer.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start());

        IntStream.range(0, 10).forEach(i -> new Thread(() -> {
            try {
                boundedContainer.put("hi");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start());
    }
}
```



------



## ReentrantReadWriteLock

叫可重入读写锁，是Java5新特性，基于AQS框架实现了读写锁的分离，读锁是共享的，写锁是独占的，且读锁和写锁之间是互斥的；

- 实现了<a href="##ReadWriteLock接口">ReadWriteLock</a>接口、Serializable接口；
- 读写锁都支持非公平锁和公平锁（非公平锁的吞吐量高于公平锁）；
- 读写锁都支持重入；
- 读锁是共享锁，即读锁可以由多个读线程同时获得，读锁不支持条件变量[Condition](##Condition接口)接口；
- 写锁是排他锁，即写锁只能由一个线程获得；
- 不能同时使用读写锁来执行读写操作；
- 写锁优先级高于读锁；
- 不支持锁升级（未释放读锁时获得写锁，会导致线程阻塞），只能先释放读锁，再获得写锁。即获得读锁 -> 释放读锁 -> 获取写锁 -> 释放写锁；
- 锁降级：写锁降级为读锁，顺序是：获得写锁 -> 获得读锁 -> 释放写锁 -> 释放读锁；

| 方法                                              | 返回值  | 说明                                                         |
| ------------------------------------------------- | :-----: | ------------------------------------------------------------ |
| ReentrantReadWriteLock()                          |         | 构造方法；<br/>初始化一个非公平锁；                          |
| ReentrantReadWriteLock(<br/>boolean fair<br/>)    |         | 构造方法；<br/>fair：true表示公平锁，false表示非公平锁；     |
| isFair()                                          | boolean | 返回true表示公平锁；<br/>返回false表示非公平锁；             |
| getReadLockCount()                                |   int   | 返回写锁被获取的次数；<br/>该次数不等于获取锁的线程数，因为同一个线程可以多次获取支持重入锁； |
| isWriteLocked()                                   | boolean | 返回true表示写锁已被获取；<br/>返回false表示写锁现在可用；   |
| isWriteLockedByCurrentThread()                    | boolean | 返回true表示当前线程已得到了写锁                             |
| getWriteHoldCount()                               |   int   | 返回当前线程获取写锁的次数，但不包括已释放的写锁             |
| getReadHoldCount()                                |   int   | 返回当前线程获取读锁的次数，但不包括已释放的读锁；<br>Java6之后使用ThreadLocal保存当前线程获取的次数 |
| hasQueuedThreads()                                | boolean | 返回true表示已有线程尝试获取锁时，被阻塞；                   |
| hasQueuedThread(<br/>Thread thread<br/>)          | boolean | 判断指定线程参数，是否正在等待获取读锁或写锁                 |
| getQueueLength()                                  |   int   | 返回正等待获取读锁或写锁的线程数量（预估值）                 |
| hasWaiters(<br/>Condition condition<br/>)         | boolean | 返回true表示已有线程调用Condition中的方法被阻塞；<br>返回false表示没有因为Condition中的方法被阻塞的线程； |
| getWaitQueueLength(<br/>Condition condition<br/>) |   int   | 返回在锁上因为被Condition接口中方法阻塞的线程数量（预估值）；<br/>例如有5个线程，每个线程都绑定在同一个**Condition**对象上，<br/>并且调用了该**Condition**对象的**await**()方法，<br/>则调用getWaitQueueLength(Condition condition)方法返回的是5； |

```java
public class TestReentrantReadWriteLock {
	private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
	private final static Lock readLock = readWriteLock.readLock();
	private final static Lock writeLock = readWriteLock.writeLock();
	private final static List<Integer> list = new ArrayList<Integer>();

	public static void main(String[] args) {
		new Thread(() -> write()).start();
		new Thread(() -> write()).start();
		new Thread(() -> read()).start();
		new Thread(() -> read()).start();
	}

	// 读方法
	public static void read() {
		readLock.lock();
    try {
      for (Integer data : list) {
        System.out.println(Thread.currentThread().getName() + ", 读取数据:" + data);
      }
      
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			readLock.unlock();
		}
	}

	// 写方法
	public static void write() {
		writeLock.lock();
		for (int i = 0; i < 5; i++) {
			System.out.println(Thread.currentThread().getName() + ", 写数据:" + i);
			list.add(i);
		}
		writeLock.unlock();
	}
}
```

```java
// 读写锁结合
public class TestCombineReentrantReadWriteLock {
	private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
	private static Lock readLock = lock.readLock();
	private static Lock writeLock = lock.writeLock();
	
	public static void main(String[] args) {
//		new Thread(() -> test1()).start();
		new Thread(() -> test0()).start();
	}
	
	// 读写锁结合使用时，没有释放读锁的话，就会阻塞
	public static void test1() {
		readLock.lock();
		System.out.println("会被阻塞");
		writeLock.lock();
		writeLock.unlock();
		readLock.unlock();
	}
	
	// 读写锁结合使用时，先释放读锁的话，就可以正常执行
	public static void test0() {
		readLock.lock(); // 加读锁
		readLock.unlock(); // 释放读锁
		readLock.lock(); // 加读锁
		readLock.unlock(); // 释放读锁
		writeLock.lock(); // 加写锁
		System.out.println("可以正常加锁与解锁");
		writeLock.unlock(); // 释放写锁
	}
}
```



------



## LockSupport

是一个线程阻塞工具，是Java5新特性，类中都是静态方法，底层是基于Unsafe类实现的，使用许可（permit）机制来让线程在任意位置被阻塞，阻塞之后也有对应的唤醒方法，即每个线程都有一个许可（permit）状态，且只有1和0两个值，默认是0表示没有许可，1表示有许可。

如果调用 `LockSupport.park()` 方法时当前线程的permit是0，那么当前线程就会阻塞，直到别的线程将当前线程的permit设置为1才会被唤醒。

如果调用 `LockSupport.park()` 方法时当前线程的permit是1，那么将permit设置为0，并立即返回，不会阻塞当前线程。

当前线程调用 `LockSupport.unpark(thread)` 方法时，会将当前线程的permit变1，再调用 `LockSupport.park()` 方法permit变0，不会有被阻塞的效果。

| 静态方法                                 | 返回值 | 说明                                                         |
| ---------------------------------------- | :----: | ------------------------------------------------------------ |
| unpark(Thread thread)                    |  void  | 唤醒处于阻塞状态的线程，将线程通行permit设置为1；<br/>若线程未启动，则无效果； |
| park()                                   |  void  | 阻塞当前线程<br>通过分配许可证，可以唤醒线程；<br/>通过其他线程中断已阻塞的线程，可以唤醒线程； |
| park(Object blocker)                     |  void  | 重载方法                                                     |
| parkNanos(long nanos)                    |  void  | 阻塞当前线程 <br/>通过分配许可证，可以唤醒线程；<br/>通过其他线程中断已阻塞的线程，可以唤醒线程；<br/>阻塞时间超过了指定纳秒，可以唤醒线程 |
| parkUntil(long deadline)                 |  void  | 阻塞当前线程，直到指定的截止日（从1970年到deadline时间的毫秒数）<br>通过分配许可证，可以唤醒线程；<br>通过其他线程中断已阻塞的线程，可以唤醒线程；<br>已超过规定的截止时间，可以唤醒线程 |
| parkNanos(Object blocker, long nanos)    |  void  | 重载方法                                                     |
| parkUntil(Object blocker, long deadline) |  void  | 重载方法                                                     |
| getBlocker(Thread t)                     | Object | 返回线程中的blocker对象                                      |

**关于参数blocker的说明：**

因为在Java5之前使用synchronized实现线程同步时，可用线程dump查看线程的阻塞对象，方便定位，但在Java5推出的LockSupport时缺遗漏了这一点，导致在线程dump时无法提供阻塞对象的信息。因此在Java6中，LockSupport新增了3个带有blocker对象的park方法，从dump线程的信息能看出不同之处：

调用 `park()` 方法的线程转储信息：

```
"main" #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)
        at learn.LockSupportDemo.main(LockSupportDemo.java:7)
```

调用 `park(Object blocker)` 方法的线程转储信息：

```
"main" #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x048c2d18> (a java.lang.String)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at learn.LockSupportDemo.main(LockSupportDemo.java:7)
```

从上面线程日志可以看出，带Object的park方法相较于无参的park方法会增加 `parking to wait for <0x048c2d18> (a java.lang.String）`信息，开发人员可以快速定位问题。



------



## StampedLock

邮戳锁（stamp）、票据锁，是Java8新特性，是对[ReadWriteLock](##ReadWriteLock接口)锁的改进，可大幅提升读操作频繁写操作少场景下的吞吐量；

邮戳锁解决了线程饥饿（Starvation）问题，也就是写入线程迟迟无法竞争得到锁定，而一直处于等待状态；

StampedLock的状态是由邮戳stamp和模式（写，悲观读，乐观读）两个部分组成的；

| 模式                                 | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| Reading<br/>（悲观读模式）           | 功能和ReentrantReadwritelock的读锁类似                       |
| Writing <br/>（写模式）              | 功能和ReentrantReadwriteLock的写锁类似                       |
| 0ptimisticReading<br/>（乐观读模式） | 所谓的乐观读模式，就是指当读操作频繁、而写操作很少的情况下，乐观地认为写操作与读操作同时发生的几率很少，因此在读操作前不需要先获取读锁（要获取stamp），只要在程序完成读操作之后，通过stamp判断在读操作过程中是否发生了写操作，再采取后续的措施（可以重新读取变更信息，或者抛出异常） ，这种改进大幅提升了程序的吞吐量！ |

-  实现了 Serializable 接口；

- 不是重入锁，类名没有按约定用 Re 开头；

- 不支持 Condition 接口；

- 获取stamp时，如果返回的是0，表示未得到锁，返回非0表示加锁成功；

- 要保证线程一定会释放锁，一定要在 `finally{}` 块中调用 `unLock()` 方法；

- 如果线程阻塞在 `readLock()` 或 `writeLock()` 上时，此时调用该阻塞线程的 `interrupt()` 方法，会导致CPU飙升；

  如果需要支持中断功能，可以用 `readLockInterruptibly()` 和 `writeLockInterruptibly()` 方法获取stamp；

| 方法                                                  |    返回值     | 说明                                                         |
| ----------------------------------------------------- | :-----------: | ------------------------------------------------------------ |
| StampedLock()                                         |               | 构造方法                                                     |
| writeLock()                                           |     long      | 阻塞式获取读锁，并返回一个邮戳，不支持线程的interrupt()方法，会导致CPU飙升 |
| tryWriteLock()                                        |     long      | 尝试获取写锁，如返回0表示没有获得锁，不阻塞线程              |
| tryWriteLock(<br/>long time, <br/>TimeUnit unit<br/>) |     long      | 尝试获取写锁，如返回0表示没有获得锁，不阻塞线程              |
| writeLockInterruptibly()                              |     long      | 阻塞式获取写锁（支持线程中断interrupt()操作），返回一个邮戳； |
| unlockWrite(<br/>long stamp<br/>)                     |     void      | 释放写锁，与writeLock()方法配对使用；                        |
| tryUnlockWrite()                                      |    boolean    | 尝试释放当前使用的写锁，如果线程持有写锁则立即释放并返回true，否则返回false； |
| readLock()                                            |     long      | 阻塞式获取锁，并返回一个邮戳，不支持线程的interrupt()方法，会导致CPU飙升 |
| tryReadLock()                                         |     long      | 尝试获得写锁，如返回0表示没有获得锁，不阻塞线程；            |
| tryReadLock(<br/>long time , <br/>TimeUnit unit<br/>) |     long      | 尝试获得写锁，如返回0表示没有获得锁，不阻塞线程；            |
| readLockInterruptibly()                               |     long      | 阻塞式获取读锁（支持线程中断interrupt()操作），返回一个邮戳； |
| unlockRead (<br/>long stamp<br/>)                     |     void      | 如果锁定状态与给定的戳匹配，则释放读锁；                     |
| tryUnlockRead()                                       |    boolean    | 尝试释放当前使用的读锁，如果线程持有读锁则立即释放并返回true，否则返回false； |
| tryOptimisticRead()                                   |     long      | 获取乐观读锁：<br>邮戳锁尝试进入乐观读模式（并没有加锁，也就是不会有CAS机制且不会阻塞线程）；<br/>如果邮戳锁当前不处于写模式下，本方法才会返回非0的邮戳stamp；<br/>等读操作执行完毕后，需使用validate(stamp)方法做邮戳校验；<br/>如果通过校验，表示这期间确实没有写操作，数据可以安全使用；<br/>如果没通过校验，需要重新获取读锁，保证数据安全； |
| tryConvertToOptimisticRead(<br/>long stamp<br/>)      |     long      | 转换模式<br>将其他锁转为乐观读模式；<br>当前邮戳为持有读或写锁，则直接释放读写锁，并返回释放后的观察者邮戳值；<br>当前邮戳持有乐观锁，若乐观锁邮戳有效，则返回观察者邮戳； |
| tryConvertToReadLock(<br/>long stamp<br/>)            |     long      | 转换模式<br/>将其他锁转为读模式；<br/>当前邮戳为持有写锁模式，则会释放写锁并获取读锁，并返回读锁邮戳；<br/>当前邮戳为持有读锁模式，则直接返回当前读锁邮戳；<br/>当前邮戳持有乐观锁，通过CAS立即获取读锁，则返回读锁邮戳；否则，获取失败返回0； |
| tryConvertToWriteLock(<br/>long stamp<br/>)           |     long      | 转换模式<br/>将其他锁转为写锁；<br/>当前邮戳为持有写锁模式，直接返回当前的邮戳；<br/>当前邮戳为持有读锁模式，则会释放读锁并获取写锁，并返回写锁邮戳；<br/>当前邮戳持有乐观锁，通过CAS立即获取写锁，成功则返回写锁邮戳，失败则返回0； |
| isWriteLocked()                                       |    boolean    | 判断锁的当前状态（模式）<br>判断是不是WriteLocked；          |
| isReadLocked()                                        |    boolean    | 判断锁的当前状态（模式）<br>判断是不是ReadLocked；           |
| asReadLock()                                          |     Lock      | 返回ReadLock视图；                                           |
| asWriteLock()                                         |     Lock      | 返回WriteLock视图；                                          |
| asReadWriteLock()                                     | ReadWriteLock | 返回一个ReadWriteLock视图；                                  |
| validate(long stamp)                                  |    boolean    | 校验乐观锁的stamp是否正确，如果错误需要重新获取读锁；        |
| unlock(long stamp)                                    |     void      | 释放锁，如果锁的状态匹配给入的stamp，释放锁的对应模式；      |

例如：

```java
class TestStampedLock {
   private double x, y;
   private final StampedLock sl = new StampedLock();
   
   // 写锁-排他锁
   void move(double deltaX, double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }
   
   // 乐观读 案例
   double distanceFromOrigin() { // A read-only method
     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁
     double currentX = x, currentY = y; //将两个字段读入本地局部变量
     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？
        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁
        try {
          currentX = x; // 将两个字段读入本地局部变量
          currentY = y; // 将两个字段读入本地局部变量
        } finally {
           sl.unlockRead(stamp);
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }
   
   // 悲观读 案例
   void moveIfAtOrigin(double newX, double newY) { // upgrade
     // Could instead start with optimistic, not read mode
     long stamp = sl.readLock();
     try {
       while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合
         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁
         if (ws != 0L) { //这是确认转为写锁是否成功
           stamp = ws; //如果成功 替换票据
           x = newX; //进行状态改变
           y = newY; //进行状态改变
           break;
         } else { //如果不能成功转换为写锁
           sl.unlockRead(stamp); //我们显式释放读锁
           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试
         }
       }
     } finally {
       sl.unlock(stamp); //释放读锁或写锁
     }
   }
}
```



## RedLock





## CountDownLatch（计数器）

也叫门阀、计数器、闭锁，是一个基于AQS框架的多线程同步工具，通过一个计数器来实现的，每当一个线程完成了自己的任务，计数器的值就相应得减一，当计数器到达零时，表示所有的线程都已执行完毕，然后等待的线程就可以恢复执行任务。

| 方法                                               | 返回值  | 说明                                                         |
| -------------------------------------------------- | :-----: | ------------------------------------------------------------ |
| CountDownLatch(int count)                          |   无    | 参数 count 是计数器的初始值（一般需要多少个线程执行，count就设为几） |
| countdown()                                        |  void   | 计数器值减一，直到 count 被减为0，代表所有线程执行完毕；<br>此时会唤醒所有等待的线程； |
| await()                                            |  void   | 使当前线程进入同步队列进行等待，直到计数器的值被减到 0 或者当前线程被中断，当前线程就会被唤醒； |
| await (<br/>long timeout, <br/>TimeUnit unit<br/>) | boolean | 带超时时间的 `await()` 方法                                  |
| getCount()                                         |  long   | 获取当前计数器的值                                           |

例如：

```java
public class TestCountdownLatch {
	public static void main(String[] args) {
		ExecutorService service = Executors.newFixedThreadPool(3);
		final CountDownLatch latch = new CountDownLatch(3);
		for (int i = 1; i <= 3; i++) {
			Runnable runnable = new Runnable() {
				public void run() {
					try {
						System.out.println("子线程" + Thread.currentThread().getName() + "开始执行");
						Thread.sleep((long) (Math.random() * 10000));
						System.out.println("子线程" + Thread.currentThread().getName() + "执行完成");
						latch.countDown(); // 当前线程调用此方法，则计数减一
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			};
			service.execute(runnable);
		}
		
		try {
			System.out.println("主线程" + Thread.currentThread().getName() + "等待子线程执行完成...");
			latch.await(); // 阻塞当前线程，直到计数器的值为0
			System.out.println("主线程" + Thread.currentThread().getName() + "开始执行...");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
```



## CyclicBarrier（循环屏障）

循环屏障（谐音：赛克里可白俄瑞额儿 ），**不是**基于AQS框架，而是基于ReentrantLock和Condition方式来实现的，能让线程到达屏障（即await方法）后被阻塞，直等到被阻塞的线程数与打开屏障所要求的数量相等时，才会打开屏障放行，即唤醒所有已到达屏障后被阻塞的线程，让被阻塞线程继续向下执行。但是注意在打开屏障放行后，该屏障点还可以继续阻塞之后到达屏障的线程，如此循环往复。

突破屏障：如果一个线程已被屏障拦截且处于阻塞状态，则该线程一旦被中断（调用interrupt()方法）或等待超时了，那么该屏障点就算是被突破了，所有处于阻塞的线程都将被唤醒（会抛出BrokenBarrierException异常）并被放行。屏障被突破后将不可再使用，但可使用reset()方法重置。

| 方法                                                         | 返回值  | 说明                                                         |
| ------------------------------------------------------------ | ------- | ------------------------------------------------------------ |
| CyclicBarrier(int parties)                                   | 无      | 构造方法；<br/>parties：表示参与方数量（打开屏障所需的线程数）; |
| CyclicBarrier(<br/>int parties, <br/>Runnable barrierAction<br/>) | 无      | 构造方法；<br/>parties：表示参与方数量（打开屏障所需的线程数）;<br/>barrierAction：表示屏障动作；即打开屏障，放行被阻塞的线程前，用最后到达屏障的线程去执行屏障动作； |
| getParties()                                                 | int     | 返回能打开屏障的线程数量（即构造方法中的**parties**值）      |
| await()                                                      | int     | 屏障点 (common barrier point)<br/>到达这个方法的线程会被阻塞，进入等待状态，直到所有线程都到达屏障点； |
| await(<br/>long timeout, <br/>TimeUnit unit<br/>)            | int     | 重载方法，可以设置线程在阻塞状态的超时时间与单位             |
| isBroken()                                                   | boolean | 判断此屏障是否已被突破                                       |
| reset()                                                      | void    | 将屏障重置为初始状态；<br>所有在屏障处等待的线程将会被唤醒并且抛出BrokenBarrierException |
| getNumberWaiting()                                           | int     | 返回当前在屏障处等待的线程数量。此方法主要用于调试和断言。   |

例如：

```java
public class TestCyclicBarrier {
	
	public static void main(String[] args) {
		CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -> {
			System.out.println("人满发车了");
		});
		System.out.println("一车3人，车满发车");
		for (int i = 0; i < 10; i++) {
			int finalI = i;
			new Thread(() -> {
				System.out.println("第" + finalI + "个人上车了");
				try {
					cyclicBarrier.await();
				} catch (InterruptedException e) {
					e.printStackTrace();
				} catch (BrokenBarrierException e) {
					e.printStackTrace();
				}
			}).start();
		}
	}
}
```

每辆车最多坐满3个人就发车，最后第10个人上车了，但是由于不满3个人，所以线程一直没发车，直到等到3个人满时才会发车；

```http
一车3人，车满发车
第0个人上车了
第1个人上车了
第2个人上车了
人满发车了
第3个人上车了
第4个人上车了
第5个人上车了
人满发车了
第6个人上车了
第9个人上车了
第8个人上车了
人满发车了
第7个人上车了
```



## Semaphore（信号量）

是 Java5新特性，是一个计数信号量并发工具，内部通过一个许可集合，来控制同时访问资源的线程个数。

比如在公园里面只有五个板凳，如果有十个人要坐的话，那么同时能坐上去的人就只能有五个，还剩下五个人只能等待。当五个人中有一个人离开后，其中在等待的五个人中又有一个人可以使用了，依次下去，直到所有人都坐上。

| 方法                                                    | 返回值     | 说明                                                         |
| ------------------------------------------------------- | ---------- | ------------------------------------------------------------ |
| Semaphore(<br/>int permits, <br/>boolean fair<br/>)     | 无         | 构造方法 <br/>参数permits表示许可证数目，表示同时可以允许多少线程进行访问；<br>参数fair表示是否是公平策略的（默认false，表示非公平策略）；<br>如果为公平策略，则按照请求时间获得许可，即先发送的请求先获得许可；<br>如果为非公平策略，则先发送的请求末必先获得许可，这有助于提高程序的吞吐量，<br/>但是有可能导致某些请求始终获取不到许可； |
| acquire()                                               | void       | 获取一个许可，若无许可则会一直阻塞等待，直到获得许可         |
| acquire (<br/>int permits<br/>)                         | void       | 获取permits个许可，若无许可能够获得，则会一直等待，直到获得许可 |
| acquireUninterruptibly()                                | void       | 获取一个许可，若无许可则会一直阻塞等待，直到获得许可，不允许被中断 |
| acquireUninterruptibly(<br/>int permits<br/>)           | void       | 获取permits个许可，若无许可能够获得，则会一直等待，直到获得许可，不允许被中断 |
| release()                                               | void       | 释放一个许可。注意，在释放许可之前，得先获得许可             |
| release(<br/>int permits<br/>)                          | void       | 释放permits个许可。注意，在释放许可之前，得先获得许可        |
| tryAcquire()                                            | boolean    | 尝试获取一个许可<br>若获取成功，则立即返回true；<br>若获取失败，则立即返回false<br>取许可的线程不会被阻塞； |
| tryAcquire (<br/>long timeout, <br/>TimeUnit unit<br/>) | boolean    | 尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false |
| tryAcquire(<br/>int permits<br/>)                       | boolean    | 尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false |
| availablePermits()                                      | int        | 返回此信号量中可用许可证的数量                               |
| drainPermits()                                          | int        | 立即将剩下的信号量一次性消耗光，并且返回所消耗的信号量       |
| isFair()                                                | Boolean    | 判断当前信号量是否使用公平策略                               |
| hasQueuedThreads()                                      | boolean    | 判断是否有线程在同步队列等待许可                             |
| getQueueLength()                                        | int        | 返回正在等待获取许可证的线程数                               |
| getQueuedThreads()                                      | Collection | 返回所有等待获取许可证的线程集合                             |

例如：

```java
public class TestSemaphore {
	
	public static void main(String[] args) {
		Semaphore s = new Semaphore(10, true);
		for (int i = 0; i < 20; i++) {
			new Thread(() -> {
				try {
					if (s.availablePermits() == 0) {
						System.out.println(Thread.currentThread().getName() + "车位不足");
					}
					
					System.out.println(Thread.currentThread().getName() + "开始停车");
					s.acquire(); // 当前线程申请获取一个许可证
					int st = new Random().nextInt(10);
					
					System.out.println(Thread.currentThread().getName() + "停" + st + "秒");
					TimeUnit.SECONDS.sleep(st);
					s.release(); // 释放当前线程使用的许可证
					System.out.println(Thread.currentThread().getName() + "停车完毕");
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}, i + "号车").start();
		}
	}
}
```



## Exchanger（交换器）

是 Java5新特性，是一个在线程间交换对象的并发工具。

| 方法                                                         | 返回值 | 说明                                                         |
| ------------------------------------------------------------ | :----: | ------------------------------------------------------------ |
| Exchanger()                                                  |   无   | 构造方法                                                     |
| exchange(V x)                                                |   V    | 当一个线程中调用Exchanger对象的exchange方法之后，<br/>会等待其他线程调用相同实例对象的exchange方法；<br>当两个线程都调用exchange方法之后，传入的参数就会交换； |
| exchange(<br/>V x, <br/>long timeout, <br/>TimeUnit unit<br/>) |   V    | 重载方法，增加了超时等待时间                                 |

例如：

```java
public class TestExchanger {
	
	public static void main(String[] args) {
		Exchanger<String> exchanger = new Exchanger<>();
		new Thread(() -> {
			try {
				String aa = exchanger.exchange("V1");
				System.out.println(Thread.currentThread().getName() + aa);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}, "T1").start();
		
		new Thread(() -> {
			try {
				String bb = exchanger.exchange("V2");
				System.out.println(Thread.currentThread().getName() + bb);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}, "T2").start();
	}
}
```



------



# IO框架

![JavaIOFrame_0](./01.Java_part1.assets/JavaIOFrame_0.png)

**根据数据的流向分类**：

- **输入流**：读取数据；
- **输出流**：写出数据；

**根据数据类型分类**：

- **字节流**

  数据流中最小的数据单元是字节；

  - 字节输入流 读取数据 InputStream；
  - 字节输出流 写入数据 OutputStream；

  ![JavaIOFrame_bytes](./01.Java_part1.assets/JavaIOFrame_bytes.jpg)

- **字符流**

  数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节（无论中文还是英文都是两个字节）；

  - 字符输入流：读取数据 Reader；
  - 字符输出流：写入数据 Writer；

  ![JavaIOFrame_chars](./01.Java_part1.assets/JavaIOFrame_chars.jpg)

- **字节流转为字符流**

  - FileReader继承自InputStreamReader，在InputStreamReader的构造方法是以InputStream为参数，将字节转换成字符；
  - FileWriter继承自OutputStreamWriter，在OutputStreamWriter的构造方法是以OutputStream为参数，将字节转换成字符；

  ![JavaIOFrame_byte2char](./01.Java_part1.assets/JavaIOFrame_byte2char.jpg)

  ![JavaIOFrame_byte2char_1](./01.Java_part1.assets/JavaIOFrame_byte2char_1.jpg)



------



# 日期时间

Epoch，指的是一个特定的时间：1970-01-01 00:00:00 UTC。



## unix时间戳

Unix系统中时间纪元是1970年1月1日0点0分0秒，时间戳是指从格林威治时间1970年1月1日0时0分0秒开始到现在共经历的毫秒数。



## 时区

全球共划分为 24 个时区。在过去世界各地各自使用当地时间，在1884年的国际会议上制定了全球性标准，明确以英国伦敦格林威治这个地方为零度经线的起点（亦称为本初子午线），并以地球由西向东每24小时自转一周360°，每隔经度15°，时差1小时。而每15°的经线则称为该时区的中央经线，将全球划分为24个时区，其中包含23个整时区及180°经线左右两侧的2个半时区。就全球的时间来看，东经的时间比西经要早，也就是如果格林威治时间是中午12时，则中央经线15°E的时区为下午1时，中央经线30°E时区的时间为下午2时；反之，中央经线15°W的时区时间为上午11时，中央经线30°W时区的时间为上午10时。以台湾为例，台湾位于东经121°，换算后与格林威治就有8小时的时差。如果两人同时从格林威治的0°各往东、西方前进，当他们在经线180°时，就会相差24小时，所以经线180°被定为国际换日线，由西向东通过此线时日期要减去一日，反之，若由东向西则要增加一日。



## GMT

格林威治标准时间（Greenwich Mean Time，简称 G.M.T.）1675年旧皇家观测所（Old Royal Observatory）正式成立，到了1884年决定以通过格林威治的子午线作为划分地球东西两半球的经度零度。观测所门口墙上有一个标志24小时的时钟，显示当下的时间，对全球而言，这里所设定的时间是世界时间参考点，全球都以格林威治的时间作为标准来设定时间，这就是我们耳熟能详的「格林威治标准时间」的由来，该标志在手表上，则代表此表具有两地时间功能，也就是同时可以显示原居地和另一个国度的时间。

GMT+08:00 或者 UTC+08:00 表示东八区 UTC/GMT +9:00 表示东九区。



## UTC

世界协调时间（Coordinated Universal  Time，简称 U.T.C.）又称世界统一时间、世界标准时间、国际协调时间，多数的两地时间表都以GMT来表示，但也有些两地时间表上看不到GMT字样，出现的反而是UTC这3个英文字母，究竟何谓UTC？事实上，UTC指的是世界标准时间，是经过平均太阳时（以格林威治时间GMT为准）、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。所以基本上UTC的本质强调的是比GMT更为精确的世界时间标准。

UTC 与 GMT 的含义相同，只不过 UTC 比 GMT 更加精准，GMT = UTC + 0。



## DST

夏日节约时间（Daylight Saving Time，简称 D.S.T.）又称夏令时，可以看作是一种特殊的时区偏移修正。指的是在夏天天亮的较早的时候把时间调快一个小时（实际上不一定是一个小时），从而节省能源（灯火），在英国则称为夏令时间（Summer Time）。这个构想于1784年由美国班杰明·富兰克林提出来，1915年德国成为第一个正式实施夏令日光节约时间的国家，以削减灯光照明和耗电开支。自此以后，全球以欧洲和北美为主的约70个国家都引用这个做法。目前被划分成两个时区的印度也正在商讨是否全国该统一实行夏令日光节约时间。欧洲手机上也有很多GSM系统的基地台，除了会传送当地时间外也包括夏令日光节约时间，做为手机的时间标准，使用者可以自行决定要开启或关闭。



## CST

CST可以同时表示美国，澳大利亚，中国，古巴四个国家的标准时间：

- 中国标准时间（China Standard Time，简称 C.S.T.），UT+8:00
- 美国中部标准时间（Central Standard Time）UT-6:00
- 澳大利亚标准时间（Central Standard Time） UT+9:30
- 古巴标准时间（Cuba Standard Time）UT-4:00



## ISO8601

国际标准化组织的国际标准ISO 8601是日期和时间的表示方法。

日历日期表示法：年为4位数，月为2位数，月中的日为2位数，比如2004-05-03或20040503。

顺序日期表示法：可以将一年内的天数直接表示，平年365天，闰年366天。如2004年5月3日可以表示为2004-125或2004125。

日历星期和日表示法：可以用2位数表示年内第几个日历星期，再加上一位数表示日历星期内第几天，但日历星期前要加上一个大写字母W，如2004年5月3日可写成2004-W19-1或2004W191。但2005-W011是从2005年1月3日开始的，前几天属于上年的第53个日历星期。每个日历星期从星期一开始，星期日为第7天。

时间表示法：小时、分钟、秒钟都用2位数表示，对UTC时间最后加一个大写字母Z，其他时区用实际时间加时差表示。如UTC时间下午2点30分5秒表示为14:30:05Z或143005Z，当时的北京时间表示为22:30:05+08:00或223005+0800，也可以简化成223005+08。



## Date类

java.util.Date类来封装当前的日期和时间，不适用于国际化，已被弃用。

| 方法                  | 返回值  | 说明                                                         |
| --------------------- | ------- | ------------------------------------------------------------ |
| after(Date date)      | boolean | 若当调用此方法的Date对象在指定日期之后返回true,否则返回false |
| before(Date date)     | boolean | 若当调用此方法的Date对象在指定日期之前返回true,否则返回false |
| clone( )              | Object  | 返回此对象的副本                                             |
| compareTo(Date date)  | int     | 比较当调用此方法的Date对象和指定日期。两者相等时候返回0；<br/>调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数 |
| compareTo(Object obj) | int     | 如果 obj 是 Date 类型，则等同于 compareTo(Date) ；<br/>如果 obj 不是 Date 类型，则抛出ClassCastException |
| equals(Object date)   | boolean | 当调用此方法的Date对象和指定日期相等时候返回true，否则返回false |
| getTime( )            | long    | 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数 |
| hashCode( )           | int     | 返回此对象的哈希码值                                         |
| setTime(long time)    | void    | 用自1970年1月1日00:00:00 GMT 以后 time 毫秒数设置时间和日期  |
| toString( )           | String  | 把此 Date 对象转换为以下形式的字符串： dow mon dd hh:mm:ss zzz yyyy <br/>其中： dow 是一周中的某一天 （Sun, Mon, Tue, Wed, Thu, Fri, Sat） |



## SimpleDateFormat

SimpleDateFormat类主要用于日期的处理和格式化。

```java
public class SimpleDateFormatTest {

	public static void main(String[] args) {
		Date date = new Date();
		System.out.println("一般日期输出：" + date + ", 时间戳：" + date.getTime());

		SimpleDateFormat sdf0 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String time0 = sdf0.format(date.getTime());// 这个就是把时间戳经过处理得到期望格式的时间
		System.out.println("格式化结果：" + time0);

		SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
		String time1 = sdf1.format(date.getTime());
		System.out.println("格式化结果：" + time1);
	}
}
```

pattern字母：

| **字母** | **描述**                                             | **示例**                                                     | 表示              |
| :------- | :--------------------------------------------------- | :----------------------------------------------------------- | ----------------- |
| G        | 纪元标记，根据语言环境显示                           | Locale.CHINA 语言环境下，<br/>如：公元；Locale.US语言环境下<br>AD（Anno Domini，in the year of the Lord，主的元年） <br>BC（Before Christ） | Text              |
| y        | 四位年份 <br>yy 表示2位年份 <br>yyyy 表示4位年份     | 1996 <br>96                                                  | Year              |
| M        | 年中的月份                                           | July<br>Jul<br>07                                            | Month             |
| d        | 一个月的日期                                         | 10                                                           | Number            |
| h        | 12小时（1-12）                                       | 12                                                           | Number            |
| H        | 一天中的小时 (0~23)                                  | 22                                                           | Number            |
| m        | 小时中的分钟数（0-59）<br>一般用mm表示分钟数，前导0  | 30                                                           | Number            |
| s        | 分钟中的秒数（0-59）<br>一般使用ss表示秒数，前导0    | 55                                                           | Number            |
| S        | 毫秒数 <br>一般使用 SSS 表示毫秒数                   | 978                                                          | Number            |
| E        | 星期中的天数                                         | Tuesday<br>Tue                                               | Text              |
| D        | 年中的天数                                           | 360                                                          | Number            |
| F        | 一个月中第几周                                       | 3（表示一个月中的第三周）                                    | Number            |
| w        | 一年中第几周                                         | 40（表示一年中的第40周）                                     | Number            |
| W        | 月份中第几周                                         | 1                                                            | Number            |
| a        | 标记或上午/下午标记                                  | AM（ante meridiem）指上午<br/>PM（post meridiem）指下午      | Text              |
| k        | 一天中的小时（1~24）<br>与 HH 相似                   | 24                                                           | Number            |
| K        | （0~11）格式小时 <br>与 hh 相似                      | 10                                                           | Number            |
| z        | 时区                                                 | Pacific Standard Time<br>PST<br>GMT-08:00                    | General time zone |
| Z        | 时区                                                 | -0800                                                        | RFC 822 time zone |
| '        | 文本定界符<br>文本可以使用单引号引起来，以免进行解释 | 'Today is ' yyyy-MM-dd                                       | Text              |
| "        | 表示一个单引号                                       |                                                              | Text              |

例如：

|          日期时间模式          |             实际输出结果             | 说明             |
| :----------------------------: | :----------------------------------: | ---------------- |
|      yyyy-MM-dd HH:mm:ss       |         2022-11-04 10:07:26          | 不带毫秒格式     |
|    yyyy-MM-dd HH:mm:ss.SSS     |       2022-11-04 10:07:26.729        | 带毫秒的         |
|    yyyy年MM月dd日 HH:mm:ss     |       2022年11月04日 10:20:32        | 带年月日         |
|  yyyy年MM月dd日 E a HH:mm:ss   | 2022年11月04日 星期五 上午 10:20:32  | 带年月日星期上午 |
|     yyyy-MM-dd E HH:mm:ss      |      2022-11-04 星期五 10:11:10      | 横杠带星期       |
|    yyyy-MM-dd E a HH:mm:ss     |   2022-11-04 星期五 上午 10:17:02    | 横杠带星期时段   |
|         yyyyMMddHHmmss         |            20221104101110            | 无分隔符精确到秒 |
|      yyyy/MM/dd HH:mm:ss       |         2022/11/04 10:11:10          | 左斜杠格式       |
|    yyyy/MM/dd HH:mm:ss.SSS     |       2022/11/04 10:11:10.136        | 左斜杠带毫秒     |
|     yyyy/MM/dd E HH:mm:ss      |      2022/11/04 星期五 10:11:10      | 左斜杠带星期     |
| "yyyy.MM.dd G 'at' HH:mm:ss z" |    2001.07.04 AD at 12:08:56 PDT     |                  |
|       "EEE, MMM d, ''yy"       |           Wed, Jul 4, '01            |                  |
|            "h:mm a"            |               12:08 PM               |                  |
|    "hh 'o''clock' a, zzzz"     | 12 o'clock PM, Pacific Daylight Time |                  |
|          "K:mm a, z"           |             0:08 PM, PDT             |                  |
| "yyyyy.MMMMM.dd GGG hh:mm aaa" |      02001.July.04 AD 12:08 PM       |                  |
|  "EEE, d MMM yyyy HH:mm:ss Z"  |    Wed, 4 Jul 2001 12:08:56 -0700    |                  |
|        "yyMMddHHmmssZ"         |          010704120856-0700           |                  |
|  "yyyy-MM-dd'T'HH:mm:ss.SSSZ"  |     2001-07-04T12:08:56.235-0700     |                  |



## System.out.printf

`System.out.printf` 方法也可以格式化日期和时间，使用两个字母格式，以 **%t** 开头并且以下面表格中的一个字母结尾。

| 转换符 | 说明                        | 示例                             |
| :----- | :-------------------------- | :------------------------------- |
| c      | 包括全部日期和时间信息      | 星期六 十月 27 14:21:20 CST 2007 |
| F      | "年-月-日"格式              | 2007-10-27                       |
| D      | "月/日/年"格式              | 10/27/07                         |
| r      | "HH:MM:SS PM"格式（12时制） | 02:25:51 下午                    |
| T      | "HH:MM:SS"格式（24时制）    | 14:28:16                         |
| R      | "HH:MM"格式（24时制）       | 14:28                            |
| %n     | 表示换行符                  |                                  |
| %S     | 将字符串以大写形式输出      |                                  |

例如：

```java
public class SystemOutPrintfTest {

	public static void main(String[] args) {
		Date date = new Date();
		System.out.printf("全部日期和时间信息：%tc%n", date); // c的使用
		System.out.printf("年-月-日格式：%tF%n", date); // f的使用
		System.out.printf("月/日/年格式：%tD%n", date); // d的使用
		System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n", date); // r的使用
		System.out.printf("HH:MM:SS格式（24时制）：%tT%n", date); // t的使用
		System.out.printf("HH:MM格式（24时制）：%tR", date); // R的使用
	}
}
```

输出结果：

```shell
全部日期和时间信息：星期六 二月 04 22:42:54 CST 2023
年-月-日格式：2023-02-04
月/日/年格式：02/04/23
HH:MM:SS PM格式（12时制）：10:42:54 下午
HH:MM:SS格式（24时制）：22:42:54
HH:MM格式（24时制）：22:42
```



## Calendar

Calendar是一个日历抽象类。

| 方法                       |     返回值      | 说明                                                         |
| -------------------------- | :-------------: | ------------------------------------------------------------ |
| Calendar.YEAR              |                 | 年份                                                         |
| Calendar.MONTH             |                 | 月份                                                         |
| Calendar.DATE              |                 | 日期                                                         |
| Calendar.DAY_OF_MONTH      |                 | 一个月的日期，从1-31                                         |
| Calendar.HOUR              |                 | 12小时制的小时                                               |
| Calendar.HOUR_OF_DAY       |                 | 24小时制的小时                                               |
| Calendar.MINUTE            |                 | 分钟                                                         |
| Calendar.SECOND            |                 | 秒                                                           |
| Calendar.DAY_OF_WEEK       |                 | 星期几                                                       |
| add(int which,int val)     |      void       | 将 val 加到 which 所指定的时间或者日期中，如果需要实现减的功能，可以加一个负数；<br/>which 必须是 Calendar 类定义的字段之一，比如：Calendar.HOUR |
| after(Object calendarObj)  |     boolean     | 如果调用 Calendar 对象所包含的日期比 calendarObj 指定的对象所包含的日期晚，返回 true，否则返回 false |
| before(Object calendarObj) |     boolean     | 如果调用 Calendar 对象所包含的日期比 calendarObj 指定的对象所包含的日期早，返回 true，否则返回 false |
| clear()                    |      void       | 对调用对象包含的所有时间组成部分清零                         |
| clear(int which)           |      void       | 对调用对象包含的 which 所指定的时间组成部分清零              |
| equals(Object calendarObj) |     boolean     | 如果调用 Calendar 对象所包含的日期和 calendarObj 指定的对象所包含的日期相等，返回 true，否则返回 false |
| get(int calendarField)     |       int       | 返回调用 Calendar 对象的一个时间组成部分的值，这个组成部分由 calendarField指定，可以被返回的组成部分如：Calendar.YEAR，Calendar.MONTH 等 |
| getInstance()              | static Calendar | 返回使用默认地域和时区的一个 Calendar 对象                   |
| getTime()                  |      Date       | 返回一个和调用对象时间相等的 Date 对象                       |
| isSet(int which)           |     boolean     | 如果调用对象所包含的 which 指定的时间部分被设置了，返回 true，否则返回 false |
| set(int year,int month)    |      void       | 设置调用对象的各种日期和时间部分                             |
| setTime(Date d)            |      void       | 从 Date 对象 d 中获得日期和时间部分                          |
| setTimeZone(TimeZone t)    |      void       | 设置调用对象的时区为 t 指定的那个时区                        |

例如：

```java
public class CalendarTest {
	
	public static void main(String[] args) {
		Date date = new Date();
		
		Calendar cr = Calendar.getInstance();
		cr.setTime(date);
		int year = cr.get(Calendar.YEAR);
		int month = cr.get(Calendar.MONTH) + 1;
		int dayOfMonth = cr.get(Calendar.DAY_OF_MONTH);
		int hour = cr.get(Calendar.HOUR_OF_DAY);
		int minute = cr.get(Calendar.MINUTE);
		int second = cr.get(Calendar.SECOND);
		int millse = cr.get(Calendar.MILLISECOND);
		
		StringBuilder buf = new StringBuilder(21);
		buf.append(year);
		buf.append('-');
		
		if (month <= 9) {
			buf.append('0');
		}
		buf.append(month);
		
		buf.append('-');
		
		if (dayOfMonth <= 9) {
			buf.append('0');
		}
		buf.append(dayOfMonth);
		
		buf.append(' ');
		
		if (hour <= 9) {
			buf.append('0');
		}
		buf.append(hour);
		
		buf.append(':');
		
		if (minute <= 9) {
			buf.append('0');
		}
		buf.append(minute);
		
		buf.append(':');
		
		if (second <= 9) {
			buf.append('0');
		}
		buf.append(second);
		
		buf.append(':');
		
		if (millse <= 9) {
			buf.append('0');
			buf.append('0');
		} else if (millse <= 99) {
			buf.append('0');
		}
		buf.append(millse);
		System.out.println(buf);
	}
}
```



## GregorianCalendar

公历日历，GregorianCalendar是Calendar抽象类的具体实现。

Calendar类的 getInstance() 方法返回一个 GregorianCalendar，被初始化为默认的地域和时区下的当前日期和时间。

GregorianCalendar类定义了两个字段：AD 和 BC，分别代表公元前和公元后。

| 方法                                                         | 返回值        | 说明                                                         |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ |
| AD                                                           |               | 公元前、主耶稣诞生前、主前                                   |
| BC                                                           |               | 公元后、主耶稣诞生后、主后                                   |
| CE                                                           |               | 公元前、主耶稣诞生前、主前，从第一年开始                     |
| BCE                                                          |               | 公元后、主耶稣诞生后、主后，从零年开始                       |
| add(int field, int amount)                                   | void          | 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中 |
| computeFields()                                              | void          | 转换UTC毫秒值为时间域值                                      |
| computeTime()                                                | void          | 覆盖Calendar ，转换时间域值为UTC毫秒值                       |
| equals(Object obj)                                           | boolean       | 比较此 GregorianCalendar 与指定的 Object                     |
| get(int field)                                               | int           | 获取指定字段的时间值                                         |
| getActualMaximum(int field)                                  | int           | 返回当前日期，给定字段的最大值                               |
| getActualMinimum(int field)                                  | int           | 返回当前日期，给定字段的最小值                               |
| getGreatestMinimum(int field)                                | int           | 返回此 GregorianCalendar 实例给定日历字段的最高的最小值      |
| getGregorianChange()                                         | Date          | 获得格里高利历的更改日期                                     |
| getLeastMaximum(int field)                                   | int           | 返回此 GregorianCalendar 实例给定日历字段的最低的最大值      |
| getMaximum(int field)                                        | int           | 返回此 GregorianCalendar 实例的给定日历字段的最大值          |
| getTime()                                                    | Date          | 获取日历当前时间                                             |
| getTimeInMillis()                                            | long          | 获取用长整型表示的日历的当前时间                             |
| getTimeZone()                                                | TimeZone      | 获取时区                                                     |
| getMinimum(int field)                                        | int           | 返回给定字段的最小值                                         |
| hashCode()                                                   | int           |                                                              |
| isLeapYear(int year)                                         | boolean       | 确定给定的年份是否为闰年                                     |
| roll(int field, boolean up)                                  | void          | 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段 |
| set(int field, int value)                                    | void          | 用给定的值设置时间字段                                       |
| set(int year, int month, int date)                           | void          | 设置年、月、日的值。                                         |
| set(<br/>int year, <br/>int month, <br/>int date, <br/>int hour, <br/>int minute<br/>) | void          | 设置年、月、日、小时、分钟的值                               |
| set(<br/>int year, <br/>int month, <br/>int date, <br/>int hour, <br/>int minute, <br/>int second<br/>) | void          | 设置年、月、日、小时、分钟、秒的值                           |
| setGregorianChange(Date date)                                | void          | 设置 GregorianCalendar 的更改日期                            |
| setTime(Date date)                                           | void          | 用给定的日期设置Calendar的当前时间                           |
| setTimeInMillis(long millis)                                 | void          | 用给定的long型毫秒数设置Calendar的当前时间                   |
| setTimeZone(TimeZone value)                                  | void          | 用给定时区值设置当前时区                                     |
| toZonedDateTime                                              | ZonedDateTime | 将此对象转换为ZonedDateTime，表示时间线上与此GregorianCalendar相同的点 |
| String                                                       | toString()    | 返回代表日历的字符串                                         |

例如：

```java
public class GregorianCalendarTest {
	
	public static void main(String[] args) {
		String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
		System.out.println("当前时间：");
		
		SimpleTimeZone stz = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
		stz.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
		stz.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
		
		Calendar c = new GregorianCalendar(stz);
		c.setTime(new Date());
		
		System.out.println("ERA: " + c.get(Calendar.ERA));
		System.out.println("YEAR: " + c.get(Calendar.YEAR));
		System.out.println("MONTH: " + c.get(Calendar.MONTH));
		System.out.println("WEEK_OF_YEAR: " + c.get(Calendar.WEEK_OF_YEAR));
		System.out.println("WEEK_OF_MONTH: " + c.get(Calendar.WEEK_OF_MONTH));
		System.out.println("DATE: " + c.get(Calendar.DATE));
		System.out.println("DAY_OF_MONTH: " + c.get(Calendar.DAY_OF_MONTH));
		System.out.println("DAY_OF_YEAR: " + c.get(Calendar.DAY_OF_YEAR));
		System.out.println("DAY_OF_WEEK: " + c.get(Calendar.DAY_OF_WEEK));
		System.out.println("DAY_OF_WEEK_IN_MONTH: " + c.get(Calendar.DAY_OF_WEEK_IN_MONTH));
		System.out.println("AM_PM: " + c.get(Calendar.AM_PM));
		System.out.println("HOUR: " + c.get(Calendar.HOUR));
		System.out.println("HOUR_OF_DAY: " + c.get(Calendar.HOUR_OF_DAY));
		System.out.println("MINUTE: " + c.get(Calendar.MINUTE));
		System.out.println("SECOND: " + c.get(Calendar.SECOND));
		System.out.println("MILLISECOND: " + c.get(Calendar.MILLISECOND));
		System.out.println("ZONE_OFFSET: " + (c.get(Calendar.ZONE_OFFSET) / (60 * 60 * 1000)));
		System.out.println("DST_OFFSET: " + (c.get(Calendar.DST_OFFSET) / (60 * 60 * 1000)));
		
		System.out.println("Current Time, with hour reset to 3");
		c.clear(Calendar.HOUR_OF_DAY); // so doesn't override
		c.set(Calendar.HOUR, 3);
		System.out.println("ERA: " + c.get(Calendar.ERA));
		System.out.println("YEAR: " + c.get(Calendar.YEAR));
		System.out.println("MONTH: " + c.get(Calendar.MONTH));
		System.out.println("WEEK_OF_YEAR: " + c.get(Calendar.WEEK_OF_YEAR));
		System.out.println("WEEK_OF_MONTH: " + c.get(Calendar.WEEK_OF_MONTH));
		System.out.println("DATE: " + c.get(Calendar.DATE));
		System.out.println("DAY_OF_MONTH: " + c.get(Calendar.DAY_OF_MONTH));
		System.out.println("DAY_OF_YEAR: " + c.get(Calendar.DAY_OF_YEAR));
		System.out.println("DAY_OF_WEEK: " + c.get(Calendar.DAY_OF_WEEK));
		System.out.println("DAY_OF_WEEK_IN_MONTH: " + c.get(Calendar.DAY_OF_WEEK_IN_MONTH));
		System.out.println("AM_PM: " + c.get(Calendar.AM_PM));
		System.out.println("HOUR: " + c.get(Calendar.HOUR));
		System.out.println("HOUR_OF_DAY: " + c.get(Calendar.HOUR_OF_DAY));
		System.out.println("MINUTE: " + c.get(Calendar.MINUTE));
		System.out.println("SECOND: " + c.get(Calendar.SECOND));
		System.out.println("MILLISECOND: " + c.get(Calendar.MILLISECOND));
		System.out.println("ZONE_OFFSET: " + (c.get(Calendar.ZONE_OFFSET) / (60 * 60 * 1000))); // in hours
		System.out.println("DST_OFFSET: " + (c.get(Calendar.DST_OFFSET) / (60 * 60 * 1000))); // in hours
	}
}
```

输出结果：

```shell
当前时间：
ERA: 1
YEAR: 2023
MONTH: 1
WEEK_OF_YEAR: 5
WEEK_OF_MONTH: 1
DATE: 4
DAY_OF_MONTH: 4
DAY_OF_YEAR: 35
DAY_OF_WEEK: 7
DAY_OF_WEEK_IN_MONTH: 1
AM_PM: 0
HOUR: 7
HOUR_OF_DAY: 7
MINUTE: 29
SECOND: 46
MILLISECOND: 932
ZONE_OFFSET: -8
DST_OFFSET: 0
Current Time, with hour reset to 3
ERA: 1
YEAR: 2023
MONTH: 1
WEEK_OF_YEAR: 5
WEEK_OF_MONTH: 1
DATE: 4
DAY_OF_MONTH: 4
DAY_OF_YEAR: 35
DAY_OF_WEEK: 7
DAY_OF_WEEK_IN_MONTH: 1
AM_PM: 0
HOUR: 3
HOUR_OF_DAY: 3
MINUTE: 29
SECOND: 46
MILLISECOND: 932
ZONE_OFFSET: -8
DST_OFFSET: 0
```



## LocalDate（日期）

是Java8新特性，因为原有的日期和时间API计算比较困难且非线程安全，为了解决此问题吸收了**Joda-Time**框架的精华，使用新加入的 java.time 包替换原有 java.util 包中的日期与时间。

LocalDate只能表示日期

```java
LocalDate ld = LocalDate.now();                  // 当前时间  now() / now(ZoneId zone) 
LocalDate ld = LocalDate.now(Clock.systemUTC()); // 从指定时钟获得的当前日期
LocalDate ld = LocalDate.now(ZoneId.systemDefault());  // 日期来自指定时区的系统时钟
LocalDate ld = LocalDate.of(2018, 11, 30);             // 从给定的年、月、日中获得LocalDate实例，输入数据类型为int
LocalDate ld = LocalDate.of(2018, Month.NOVEMBER, 30); // 从给定的年（int）、月（Month）和日（int）给出LocalDate实例
LocalDate ld = LocalDate.ofEpochDay(500);              // 从给定的纪元日数中给出LocalDate实例
LocalDate ld = LocalDate.ofInstant(Instant.now(), ZoneId.systemDefault()); // 从给定的Instant和ZoneId给出LocalDate实例
LocalDate ld = LocalDate.ofYearDay(2018, 02);          // 从给定的年份和年份中的天数给出LocalDate实例，输入数据类型为 int
LocalDate ld = LocalDate.parse("2018-10-01");          // 从给定的文本字符串实例化日期
LocalDate ld = LocalDate.parse("15-03-2018", DateTimeFormatter.ofPattern("dd-MM-yyyy")); //从给定格式的文本字符串中获得LocalDate实例。输出的LocalDate将是yyyy-MM-dd格式
LocalDate ld = LocalDate.from(LocalDate.now());        // 从给定的时间对象中获得LocalDate实例

LocalDate ld = LocalDate.now().plus(15, ChronoUnit.DAYS); // 通过增加给定的数量返回LocalDate实例
LocalDate ld = LocalDate.now().plus(Period.ofDays(15)); // 添加指定的TemporalAmount返回LocalDate实例
LocalDate ld = LocalDate.now().plusDays(15);            // 添加指定的天数返回LocalDate实例
LocalDate ld = LocalDate.now().plusWeeks(long weeksToAdd); // 添加指定的周数返回 LocalDate 实例，用法与plusDays类似
LocalDate ld = LocalDate.now().plusMonths(long weeksToAdd); // 添加指定的月数返回 LocalDate 实例，用法与plusDays类似
LocalDate ld = LocalDate.now().plusYears(long weeksToAdd); // 添加指定的年数返回 LocalDate 实例，用法与plusDays类似

LocalDate ld = LocalDate.now().minus(15, ChronoUnit.DAYS);    // 减去给定的数量返回LocalDate实例
LocalDate ld = LocalDate.now().minus(Period.ofDays(15));      // 减去指定的TemporalAmount返回LocalDate实例
LocalDate ld = LocalDate.now().minusDays(long daysToSubtract);// 减少指定的天数返回LocalDate实例
LocalDate ld = LocalDate.now().minusWeeks(long weeksToSubtract); // 减少指定的周数返回 LocalDate 实例，用法与minusDays相似
LocalDate ld = LocalDate.now().minusMonths(long monthsToSubtract); // 减少指定的月数返回 LocalDate 实例，用法与minusDays相似
LocalDate ld = LocalDate.now().minusYears(long yearsToSubtract); // 减少指定的年数返回 LocalDate 实例，用法与minusDays相似

LocalDate ld = LocalDate.now().with(DayOfWeek.SUNDAY);       // 获取本周的星期日
LocalDate ld = LocalDate.now().with(ChronoField.YEAR, 2017); // 修改日期的年份
LocalDate ld = LocalDate.now().withDayOfMonth(10);           // 修改日期为月份中的 10 号
LocalDate ld = LocalDate.now().withDayOfYear(110);           // 修改当前的第 110 天
LocalDate ld = LocalDate.now().withMonth(6);                 // 修改日期的月份
LocalDate ld = LocalDate.now().withYear(2017);               // 修改年份

LocalDate.now().get(ChronoField.YEAR);             // 返回当前年份
LocalDate.now().getChronology();                   // 获取日期格式，例如：ISO
LocalDate.now().getDayOfMonth();                   // 获取日期是月中的第几号，为int类型
LocalDate.now().getDayOfWeek();                    // 获取日期是星期几，返回DayOfWeek
LocalDate.now().getEra();                          // "CE " 从第一年开始，"BCE " 从零年开始
LocalDate.now().getLong(ChronoField.YEAR);         // 指定字段的值，返回long类型
LocalDate.now().getMonth();                        // 获取日期的月份，返回值为Month类型
LocalDate.now().getMonthValue();                   // 获取月份，取值范围为1-12的int类型
LocalDate.now().getYear();                         // 获取年份，返回int类型

LocalDate localDate = LocalDate.parse("2018-02-18");  // 将字符串转为日期
String formattedDate = localDate.format(DateTimeFormatter.ofPattern("MMM dd, yyyy")); // 使用 DateTimeFormatter 格式化日期

LocalDate.now().atTime(int hour, int minute)                               // 修改当前时间的小时和分钟
LocalDate.now().atTime(int hour, int minute, int second)                   // 修改当前时间的小时、分钟、秒钟
LocalDate.now().atTime(int hour, int minute, int second, int nanoOfSecond) // 修改当前时间的小时、分钟、秒钟、毫秒
LocalDate.now().atTime(LocalTime time)                                     // 使用另一个日期更新

OffsetDateTime  offsetDateTime  = localDate.atTime(OffsetTime.now());      // 输出为2018-05-02T17:54:37.104+08:00

// 将日期转换为指定类型，且小时分钟秒都是0
LocalDateTime ldt = LocalDate.now().atStartOfDay();                        // 2021-06-13T00:00 
ZonedDateTime zdt = LocalDate.now().atStartOfDay(ZoneId.systemDefault());  // 2021-06-13T00:00+08:00[Asia/Shanghai]

LocalDate.now().isAfter(ChronoLocalDate other)            // 检查此日期是否在给定日期之后，返回 boolean
LocalDate.now().isBefore(ChronoLocalDate other)           // 检查此日期是否在给定日期之前，返回 boolean
LocalDate.now().isEqual(ChronoLocalDate other)            // 检查此日期是否等于给定日期，返回 boolean

LocalDate.now().isLeapYear()                              // 检查年份是否为闰年
LocalDate.now().isSupported(ChronoField.DAY_OF_MONTH)     // 检查是否支持给定字段。在从日期获取任何字段之前，我们可以检查该字段是否受支持，否则我们可能会出错。
LocalDate.now().isSupported(ChronoUnit.HOURS)             // 检查是否支持给定的单位。在使用加减之前，我们可以检查是否支持给定的单位，否则我们可能会出错。

LocalDate.now().lengthOfMonth()                     // 给出月份的最大天数，例如 28、29、30、31
LocalDate.now().lengthOfYear()                      // 给出年份的最大天数 365 或 366（闰年）

// Java 9 中引入了 datesUntil 方法

// 从该日期开始到指定日期的日期流，指定的日期将被排除在结果中
Stream<LocalDate> lds = LocalDate.parse("2018-02-18").datesUntil(LocalDate.parse("2018-02-22"));
localDateStream.forEach(date -> System.out.println(date));
输出结果：
2018-02-18
2018-02-19
2018-02-20
2018-02-21

// datesUntil 通过 period 来设置增量步长的Stream
localDateStream = LocalDate.parse("2018-02-18").datesUntil(LocalDate.parse("2018-02-22"), Period.ofDays(2));
localDateStream.forEach(date -> System.out.println(date));  
输出结果：
2018-02-18
2018-02-20 

// 计算此日期和指定日期之间的时期为 Period
Period period = LocalDate.parse("2018-02-18").until(LocalDate.parse("2018-03-28"));
System.out.println(period.getDays()); // 10 因为 P1M10D，28-18=10

// 计算距指定日期（不包括）的时间量
long val = LocalDate.parse("2018-02-18").until(LocalDate.parse("2018-03-28"), ChronoUnit.DAYS);
System.out.println(val); // 38 二个日期之间差了 38 天

// 将此日期与指定日期进行比较
System.out.println(LocalDate.parse("2018-02-18").equals(LocalDate.parse("2018-02-18")));    // true

// 检查此日期是否等于指定日期
System.out.println(LocalDate.parse("2018-02-18").compareTo(LocalDate.parse("2018-02-25"))); // -7

// 方法将指定的时间对象调整为与此对象具有相同的日期。
LocalDate.parse("2018-02-18").adjustInto(LocalDate.parse("2017-03-20")) // 2018-02-18 

// query方法使用指定的查询方式查询
TemporalQueries.precision()                                       // 查询最小的支持单位，返回TemporalQuery的实例
TemporalUnit unit = localDate.query(TemporalQueries.precision()); // 查询日期支持的最小单位，因为日期的最小但是天，所以返回 Days

// 给出日期所在月的起始日与结束日
ValueRange vrange = LocalDate.parse("2018-02-18").range(ChronoField.DAY_OF_MONTH);
System.out.println(vrange);   // 1 - 28

// 给出日期所在周的起始日与结束日
ValueRange vrange = LocalDate.parse("2018-02-18").range(ChronoField.DAY_OF_WEEK);
System.out.println(vrange);   // 1 – 7

// 返回从 1970-01-01 00:00:00 UTC 到 2018-02-18 之间的天数
System.out.println(LocalDate.parse("2018-02-18").toEpochDay());   // 17580 天

// 计算从 1970-01-01 00:00:00 UTC 到 2018-02-18 之间的秒数，并返回 long 值。在Java 9中引入
System.out.println(LocalDate.parse("2018-02-18").toEpochSecond(LocalTime.now(), ZoneOffset.MAX));  // 1518921065
```



## LocalTime（时间）

LocalTime，只能表示时间，不能表示日期和时区。

```
LocalTime.now();                                                 // 获取当前时间
LocalTime.now(Clock clock)                                       // 获取指定时钟的时间
LocalTime.now(ZoneId zone)                                       // 获取指定时区的时间

LocalTime.of(int hour, int minute)                               // 指定小时和分钟，秒
LocalTime.of(int hour, int minute, int second)                   // 指定小时、分钟、秒
LocalTime.of(int hour, int minute, int second, int nanoOfSecond) // 指定小时、分钟、秒、毫秒

LocalTime.ofSecondOfDay(long secondOfDay)                        // 指定一天中的秒数数来初始化时间
LocalTime.ofNanoOfDay(long nanoOfDay)                            // 指定一天中的毫秒数来初始化时间
LocalTime.from(ZonedDateTime.now())                              // 返回一个时间副本
LocalTime.parse("10:51:01.167526700")                            // 将字符串转为LocalTime，格式一般是 10:15 或者 10:15:30
LocalTime.parse(CharSequence text, DateTimeFormatter formatter)  // 将字符串转为LocalTime，格式与formatter格式一致

LocalTime.now().isSupported(TemporalField field)                 // 判断时间是否支持小时属性
LocalTime.now().isSupported(TemporalUnit unit)                   // 判断时间是否支持指定属性
LocalTime.now().range(TemporalField field)                       // 给出日期所在月的起始时间与结束时间

LocalTime.now().get(TemporalField field)                         // 返回int通用方法，通过传入参数可以获取时、分、秒、毫秒、纳秒
LocalTime.now().getLong(TemporalField field)                     // 返回long通用方法，通过传入参数可以获取时、分、秒、毫秒、纳秒
LocalTime.now().getHour()                                        // 获取小时 ，返回0到23
LocalTime.now().getMinute()                                      // 获取分钟，返回0到59
LocalTime.now().getSecond()                                      // 获取秒，返回0到59
LocalTime.now().getNano()                                        // 获取纳秒，返回0到999,999,999

LocalTime.now().with(TemporalAdjuster adjuster)                  // 返回此时的调整副本。
LocalTime.now().with(TemporalField field, long newValue)         // 返回此时间的副本，并将指定字段设置为新值。
LocalTime.now().withHour(int hour)                               // 设置小时
LocalTime.now().withMinute(int minute)                           // 设置分钟
LocalTime.now().withSecond(int second)                           // 设置秒钟
LocalTime.now().withNano(int nanoOfSecond)                       // 设置毫秒

LocalTime.now().truncatedTo(TemporalUnit unit)                   // 返回此LocalTime的副本，并截断时间

LocalTime.now().plus(TemporalAmount amountToAdd)                 // 加一个时间单位
LocalTime.now().plus(long amountToAdd, TemporalUnit unit)        // 加一个时间单位
LocalTime.now().plusHours(long hoursToAdd)                       // 增加小时
LocalTime.now().plusMinutes(long minutesToAdd)                   // 增加分钟
LocalTime.now().plusSeconds(long secondstoAdd)                   // 增加秒数
LocalTime.now().plusNanos(long nanosToAdd)                       // 增加毫秒

LocalTime.now().minus(TemporalAmount amountToSubtract)           // 
LocalTime.now().minus(long amountToSubtract, TemporalUnit unit)  // 当前时间减掉指定单位量的数值

LocalTime.now().minusHours(long hoursToSubtract)                 // 减掉小时
LocalTime.now().minusMinutes(long minutesToSubtract)             // 减掉分钟
LocalTime.now().minusSeconds(long secondsToSubtract)             // 减掉秒钟 
LocalTime.now().minusNanos(long nanosToSubtract)                 // 减掉毫秒

// query方法使用指定的查询方式查询
TemporalQueries.precision()                                      // 查询最小的支持单位，返回TemporalQuery的实例
LocalTime.now().query(TemporalQueries.precision())               // 查询日期支持的最小单位，因为时间的最小但是毫秒所以返回 Nanos
LocalTime.now().adjustInto(Temporal temporal)                    // 指定的时间对象调整为与此LocatTime对象相同的时间。
LocalTime.now().until(Temporal endExclusive, TemporalUnit unit)  // 用于使用TemporalUnit计算两个LocalTime对象之间的时间量
LocalTime.now().format(DateTimeFormatter formatter)              // 将时间转为指定格式的字符串

LocalTime.now().atDate(LocalDate date)                           // 用于将此LocalTime 对象与 LocalDate对象组合以创建 LocalDateTime

LocalTime.now().atOffset(ZoneOffset.ofHoursMinutes(3, 45))       // 用于将此时间与偏移对象组合以创建OffsetTime对象
Offset Time:17:52:49+03:45

LocalTime.now().toSecondOfDay()                                  // 将时间转为所在当前的秒数
LocalTime.now().toNanoOfDay()                                    // 将时间转为毫秒数，从 1970年1月1日开始
LocalTime.now().compareTo(LocalTime other)                       // 比较时间大小
LocalTime.now().isAfter(LocalTime other)                         // 判断时间是否晚于指定时间
LocalTime.now().isBefore(LocalTime other)                        // 判读时间是否小于指定时间
```



## LocalDateTime

日期时间类，包含日期+时间 ，可以获取日期和时间字段；



## ZonedDateTime

日期时区类，包含时区





## Duration

Duration类表示秒或纳秒时间间隔，适合处理较短的时间，需要更高的精确性

**用于计算时间间隔**

```java
// 用于计算时间差
LocalDateTime localDateTime5 = LocalDateTime.now();
LocalDateTime localDateTime6 = localDateTime5.plusDays(1);
Duration between = Duration.between(localDateTime5, localDateTime6);
System.out.println(between.getSeconds());
```

输出结果：

```java
86400
```





## ChronoField

TemporalField接口的实现类，也是 TemporalUnit接口的实现类。

| 枚举                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| NANO_OF_SECOND               | 计算在秒内的纳秒，从0到999,999,999。 该字段对于所有日历系统具有相同的含义。 |
| OFFSET_SECONDS               | 与UTC / Greenwich的偏差                                      |
| PROLEPTIC_MONTH              | 基于预感月，从0年开始按月计数。                              |
| SECOND_OF_DAY                | 计算当天的秒数，从0到（24 * 60 * 60） - 1                    |
| SECOND_OF_MINUTE             | 计算分钟内的秒数，从0到59                                    |
| YEAR                         | 即将到来的一年，如2012年。                                   |
| YEAR_OF_ERA                  | 这个时代的一年。                                             |
| NANO_OF_DAY                  | 计算当天的纳秒，从0到（24 * 60 * 60 *1,000,000,000） - 1.该字段对于所有日历系统具有相同的含义 |
| MONTH_OF_YEAR                | 一年中的月份，例如三月。                                     |
| MINUTE_OF_HOUR               | 分钟，从0到59                                                |
| MINUTE_OF_DAY                | 一天中的分钟，从0到（24 * 60） - 1                           |
| MILLI_OF_SECOND              | 毫秒，从0到999.此字段对于所有日历系统具有相同的含义          |
| MILLI_OF_DAY                 | 当天的毫秒数，从0到（24 * 60 * 60 * 1,000） - 1              |
| MICRO_OF_SECOND              | 计算在秒内的微秒，从0到999,999。 该字段对于所有日历系统具有相同的含义 |
| MICRO_OF_DAY                 | 计算当天的微秒，从0到（24 * 60 * 60 * 1,000,000） - 1.此字段对于所有日历系统具有相同的含义 |
| INSTANT_SECONDS              | 即时纪元。                                                   |
| HOUR_OF_DAY                  | 一天中的小时，24小时制，从0到23。这是在标准的24小时数字时钟上观察到的小时 |
| HOUR_OF_AMPM                 | 计算AM / PM内的小时数，12小时制，从0到11                     |
| ERA                          | 时代。                                                       |
| EPOCH_DAY                    | 该纪元日，基于1970-01-01（ISO）的Java时代。                  |
| DAY_OF_YEAR                  | 天。当年第几天                                               |
| DAY_OF_WEEK                  | 星期几，例如星期二。                                         |
| DAY_OF_MONTH                 | 天。当月第几天                                               |
| CLOCK_HOUR_OF_DAY            | 小时，从1到24.这是在24小时模拟挂钟上观察到的小时             |
| CLOCK_HOUR_OF_AMPM           | 计算AM / PM内的小时数，从1到12.这是在标准的12小时模拟挂钟上观察到的小时数 |
| AMPM_OF_DAY                  | 当天的AM / PM，从0（AM）到1（PM）                            |
| ALIGNED_WEEK_OF_YEAR         | 一年内对齐的一周。                                           |
| ALIGNED_WEEK_OF_MONTH        | 一个月内对齐的一周。                                         |
| ALIGNED_DAY_OF_WEEK_IN_YEAR  | 一年内对齐的星期几。                                         |
| ALIGNED_DAY_OF_WEEK_IN_MONTH | 一个月内对齐的星期几。                                       |



## TemporalAdjuster

时间调节器，TemporalAdjuster是函数接口，可以执行复杂的日期操作。

| 方法                                                      | 说明                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| boolean isSupported(TemporalUnit unit);                   |                                                              |
| Temporal with(TemporalAdjuster adjuster);                 | DayOfWeek.SUNDAY 获取本周的星期日                            |
| Temporal with(TemporalField field, long newValue);        | ChronoField.YEAR, 2017 修改日期的年份                        |
| Temporal plus(TemporalAmount amount);                     | 参数可以是Period.ofDays(15) 表示添加指定的TemporalAmount返回LocalDate实例 |
| Temporal plus(long amountToAdd, TemporalUnit unit);       | 加上指定单位量的数值                                         |
| Temporal minus(TemporalAmount amount);                    |                                                              |
| Temporal minus(long amountToSubtract, TemporalUnit unit); |                                                              |
| until(Temporal endExclusive, TemporalUnit unit);          |                                                              |



## DateTimeFormatter

java.time.format.DateTimeFormatter 类似于 SimpleDateFormat 类。

| 符号 | 意义                                                         | 演示         | 样例                                              |
| ---- | ------------------------------------------------------------ | ------------ | ------------------------------------------------- |
| G    | era，纪元标记                                                | text         | AD; Anno Domini; A 都表示公元后<br>BC;            |
| u    | year，年（用负数表示公元前）                                 | year         | 2004; 04                                          |
| y    | year-of-era，年，公元（基督）纪念的年份                      | year         | 2004; 04                                          |
| Y    | week-based-year，年，如果本周跨年，那本周就算入下一年        | year         | 1996; 96                                          |
| M/L  | month-of-year，第几月（1-12）                                | number/text  | 7; 07; Jul; July; J                               |
| m    | minute-of-hour，分钟（0-59）                                 | number       | 30                                                |
| D    | day-of-year，一年中的第几天                                  | number       | 189                                               |
| d    | day-of-month，月份中的日期（1-31）                           | number       | 10                                                |
| h    | clock-hour-of-am-pm，12小时制， (1-12)                       | number       | 12                                                |
| H    | hour-of-day，24小时制（0-23）                                | number       | 0                                                 |
| s    | second-of-minute，秒（0-59）                                 | number       | 55                                                |
| S    | fraction-of-second，毫秒                                     | fraction     | 978                                               |
| Q/q  | quarter-of-year，日期属于哪个季度（1-4）                     | number/text  | 3; 03; Q3; 3rd quarter                            |
| w    | week-of-week-based-year，日期在本年中是第几周（1-53）        | number       | 27                                                |
| W    | week-of-month，月中的第几周（1-5）                           | number       | 4                                                 |
| E    | day-of-week，星期几                                          | text         | Tue; Tuesday; T                                   |
| e/c  | localized day-of-week，本地化星期几                          | number/text  | 2; 02; Tue; Tuesday; T                            |
| F    | week-of-month，月中的第几周                                  | number       | 3                                                 |
| a    | am-pm-of-day，上午或下午                                     | text         | AM;PM                                             |
| A    | milli-of-day，今天0点0分0秒0毫秒 到 当前时间的毫秒数         | number       | 1234                                              |
| K    | hour-of-am-pm，12小时制，(0-11)                              | number       | 0                                                 |
| k    | clock-hour-of-am-pm，24小时制，(1-24)                        | number       | 1                                                 |
| n    | nano-of-second，纳米秒（从 0 到 999,999,999）                | number       | 987654321                                         |
| N    | nano-of-day，一天的纳秒（从 0 到 24 * 60 * 60 * 1,000,000,000 - 1） | number       | 1234000000                                        |
| V    | time-zone ID，时区ID                                         | zone-id      | America/Los_Angeles; Z; -08:30                    |
| z    | time-zone name，时区名                                       | zone-name    | Pacific Standard Time; PST                        |
| O    | localized zone-offset（偏移量模式）                          | offset-O     | GMT+8; GMT+08:00; UTC-08:00;                      |
| X    | zone-offset 'Z' for zero（偏移量模式）                       | offset-X     | Z; -08; -0830; -08:30; -083015; -08:30:15;        |
| x    | zone-offset（偏移量模式）                                    | offset-x     | +0000; -08; -0830; -08:30; -083015; -08:30:15;    |
| Z    | zone-offset（偏移量模式）                                    | offset-Z     | +0000; -0800; -08:00;                             |
| p    | pad next                                                     | pad modifier | 1                                                 |
| '    | escape for text，文本可以使用单引号引起来，以免进行解释      | delimiter    |                                                   |
| "    | single quote，表达一个单引号                                 | literal      |                                                   |
| [    | optional section start，可选标记左侧标记                     |              | yyyy-MM-dd [ HH:mm:ss ] <br>表示可以没有HH:mm:ss  |
| ]    | optional section end，可选标记右侧标记                       |              | yyyy-MM-dd [ HH:mm:ss ] <br/>表示可以没有HH:mm:ss |
| #    | reserved for future use，保留字符                            |              |                                                   |
| {    | reserved for future use，保留字符                            |              |                                                   |
| }    | reserved for future use，保留字符                            |              |                                                   |

例如：

```java
public class JavaTimeTest1 {
	
	public static void main(String[] args) {
		LocalDateTime ldt = LocalDateTime.now();
		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		
		// 将日期时间转为字符串
		System.out.println(dtf.format(ldt));
		
		// 时间戳转为字符串
		System.out.println(dtf.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(1636370296330L), ZoneId.systemDefault())));
		
		// 将字符串转为日期时间
		System.out.println(LocalDateTime.parse("2021-07-03 05:33:30", dtf));
	}
}
```

输出结果：

```java
2023-02-05 00:18:31
2021-11-08 19:18:16
2021-07-03T05:33:30
```



## Instant

时间线上的一个瞬时点，被用来记录应用程序中的事件时间戳。

```java
public class JavaTimeTest6 {
	
	public static void main(String[] args) {
		// 日期变更子午线时间
		Instant instant = Instant.now();
		System.out.println(instant);
		
		// 添加偏移量(时区)： 添加时间的偏移量--东八区时区
		OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
		System.out.println(offsetDateTime);
		
		// 获取时间戳(从1970年1月1日0时0分0秒开始的毫秒数)
		long l = instant.toEpochMilli();
		System.out.println(l);
		
		// 根据毫秒时间戳返回Instant对象
		Instant instant1 = Instant.ofEpochMilli(l);
		System.out.println(instant1);
	}
}
```

输出结果：

```shell
2023-02-04T16:24:33.776Z
2023-02-05T00:24:33.776+08:00
1675527873776
2023-02-04T16:24:33.776Z
```



## Period

用于计算日期相对间隔（无法隔月计算）

```java
// 用于计算两个日期间隔
DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");
LocalDate startDate = LocalDate.parse("2019-03-04", fmt);
LocalDate endDate = LocalDate.parse("2018-02-01", fmt);
 
Period period = Period.between(startDate, endDate);
System.out.println("相差:" + period.getYears() + " 年 " + period.getMonths() + " 个月 " + period.getDays() + " 天");
```

输出结果：

```java
相差: -1 年 -1 个月 -3 天
```

隔月计算要用 toEpochDay 方法

```java
// 获取当前时间
LocalDate localDate1 = LocalDate.now();
LocalDate localDate2 = localDate1.plusDays(100);
// 无法隔月计算
System.out.println(Period.between(localDate1, localDate2).getDays());
System.out.println(localDate2.toEpochDay()-localDate1.toEpochDay());
```

输出结果：

```java
8
100
```

计算日期绝对间隔

```java
DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");
LocalDate startDate = LocalDate.parse("2019-03-01",fmt);
LocalDate endDate = LocalDate.parse("2020-07-08",fmt);
System.out.println("总相差的天数:" + startDate.until(endDate, ChronoUnit.DAYS));
System.out.println("总相差的月数:" + startDate.until(endDate, ChronoUnit.MONTHS));
System.out.println("总相差的年数:" + startDate.until(endDate, ChronoUnit.YEARS));
```

输出结果：

```java
总相差的天数:495
总相差的月数:16
总相差的年数:1
```

**常用日期获取**

```java
// 本周一
LocalDate.now().with(DayOfWeek.of(1));
// 下周一
LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.of(1)));
 
// 本月第一天
LocalDate.now().with(TemporalAdjusters.firstDayOfMonth());
 
//下月第一天
LocalDate.now().plusMonths(1).with(TemporalAdjusters.firstDayOfMonth())
```

输出结果：

```java
2021-07-05
2021-07-12
2022-03-01
2022-04-01
```

**String、Date、LocaDate、LocalTime、LocalDateTime 相互转换**

**String 与 Date 相互转换**

```java
// Date转String
Date date = new Date();
SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");
System.out.println(sdf1.format(date));
sdf1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
System.out.println(sdf1.format(date));
sdf1 = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
System.out.println(sdf1.format(date));

// String 转 Date
String string = "2016-10-24 21:59:06";
SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
System.out.println(sdf2.parse(string));
```

输出结果：

```java
2021-11-21
2021-11-21 20:41:05
2021年11月21日 20:41:05
Mon Oct 24 21:59:06 CST 2016
```

**String 与 LocaDate 相互转换**

```java
// LocalDate 转 String
DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd"); // 这里不能用 yyyy-MM-dd HH:mm:ss 原因是LocalDate本身不含时分秒
LocalDate now = LocalDate.now();
String localTime = df.format(now);
System.out.println(localTime);

// String 转 LocalDate
DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd");
LocalDate ldt = LocalDate.parse("2017-09-28", df);
System.out.println(ldt);

LocalDate ldt = LocalDate.parse("2017-09-28");
System.out.println(ldt);

如果用yyyy-MM-dd HH:mm:ss但是输出仍然只是年月日
DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
LocalDate ldt = LocalDate.parse("2017-09-28 11:11:11", df);
System.out.println(ldt);
```

输出结果：

```java
2021-11-21
2017-09-28
2017-09-28
2017-09-28
```

**String 与 LocaTime 相互转换**

```java
// LocalTime 转 String
DateTimeFormatter df = DateTimeFormatter.ofPattern("HH:mm:ss");
LocalTime now = LocalTime.now();
String localTime = df.format(now);
System.out.println(localTime);

// String 转 LocalTime
DateTimeFormatter df = DateTimeFormatter.ofPattern("HH:mm:ss");
LocalTime ldt = LocalTime.parse("21:11:01", df);
System.out.println(ldt);
```

输出结果：

```java
21:37:09
21:11:01
```

**String 与 LocalDateTime相互转换**

```java
// LocalTimeDate 转 String
DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
LocalDateTime now = LocalDateTime.now();
String localTime = df.format(now);
System.out.println(localTime);

// String 转 LocalTimeDate
DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); //这里不能用yyyy-MM-dd
LocalDateTime ldt = LocalDateTime.parse("2017-09-28 23:11:11", df);
System.out.println(ldt);
```

输出结果：

```java
2021-11-21 20:56:01
2017-09-28T23:11:11
```

**Date 与 LocalDate相互转换**

```java
// LocalDate 转 Date
LocalDate localDate = LocalDate.now();
ZoneId zoneId = ZoneId.systemDefault();
Date date = Date.from(localDate.atStartOfDay().atZone(zoneId).toInstant());
System.out.println(date);

// Date 转 LocalDate
Date date = new Date();
ZoneId zoneId = ZoneId.systemDefault();
LocalDate localDate = date.toInstant().atZone(zoneId).toLocalDate();
System.out.println(localDate);
```

输出结果：

```java
Sun Nov 21 00:00:00 CST 2021
2021-11-21
```

**Date 与 LocalTime 转换**

```java
// Date转LocalTime
Date date = new Date();
ZoneId zoneId = ZoneId.systemDefault();
LocalTime localTime = date.toInstant().atZone(zoneId).toLocalTime();
System.out.println(localTime);
```

输出结果：

```java
21:41:31.140
```

**Date 与 LocalDateTime相互转换**

```java
// LocalDateTime转Date
在LocalDateTime 转 Date 时，需要使用到 Java 8的几个类
 
ZoneId/ZoneOffset：表示时区
ZonedDateTime： 表示特定时区的日期和时间
Instant：表示时刻，不直接对应年月日信息，需要通过时区转换
 
LocalDateTime localDateTime = LocalDateTime.now();
//获取系统默认时区
ZoneId zoneId = ZoneId.systemDefault();
//时区的日期和时间
ZonedDateTime zonedDateTime = localDateTime.atZone(zoneId);
//获取时刻
Date date = Date.from(zonedDateTime.toInstant());
System.out.println(date);

// Date转LocalDateTime
Date date = new Date();
ZoneId zoneId = ZoneId.systemDefault();
LocalDateTime localDateTime = date.toInstant().atZone(zoneId).toLocalDateTime();
System.out.println(localDateTime);
```

输出结果：

```java
Sun Nov 21 21:25:20 CST 2021
2021-11-21T21:27:10.717
```

**LocalDate 与 LocalDateTime相互转换**

```java
// LocalDateTime转LocalDate
LocalDateTime localDateTime = LocalDateTime.now();
LocalDate localDate = localDateTime.toLocalDate();
ystem.out.println(localDate);

// LocalDate转LocalDateTime
LocalDate localDate = LocalDate.now();
LocalDateTime localDateTime1 = localDate.atStartOfDay();
LocalDateTime localDateTime2 = localDate.atTime(8,20,33);
LocalDateTime localDateTime3 = localDate.atTime(LocalTime.now());
System.out.println(localDateTime1);
System.out.println(localDateTime2);
System.out.println(localDateTime3);
```

输出结果：

```
2021-11-21
2021-11-21T00:00
2021-11-21T08:20:33
2021-11-21T21:31:07.340
```

**LocalTime 与 LocalDateTime转换**

```java
// LocalDateTime转LocalTime
LocalDateTime localDateTime = LocalDateTime.now();
LocalTime localTime = localDateTime.toLocalTime();
System.out.println(localTime);
```

输出结果：

```java
21:43:05.884
```

**LocalDateTime与Long转换**

```java
LocalDateTime 转 Long(毫秒时间戳)
ZoneId zone = ZoneId.systemDefault();
Instant instant = LocalDateTime.now().atZone(zone).toInstant();
System.out.println(instant.toEpochMilli());

Long(毫秒时间戳) 转 LocalDateTime
Instant instant = Instant.ofEpochMilli(1640444137993L);
ZoneId zone = ZoneId.systemDefault();
System.out.println(LocalDateTime.ofInstant(instant, zone));
```

输出结果：

```java
1640444452715
2021-12-25T22:55:37.993
```



------



# 线程池

是Java5新特性，线程池相关类在 java.util.concurrent包中，通过Executor框架可以创建不同的线程池；

线程池的创建分为两种方式：ThreadPoolExecutor 和 Executors；



## Future

表示异步计算的结果。提供了检查计算是否完成、等待其完成以及检索计算结果的方法。只有当计算完成时，才能使用get方法检索结果，如果需要，则进行阻塞，直到准备就绪。通过取消方法执行取消。提供了其他方法来确定任务是正常完成还是被取消。一旦计算完成，就不能取消计算。如果您希望为了可取消性而使用Future，但不提供可用的结果，则可以声明Future＜？＞形式的类型并作为基础任务的结果返回null。

|                                                 |         |                                                              |
| ----------------------------------------------- | ------- | ------------------------------------------------------------ |
| cancel(<br/>boolean mayInterruptIfRunning<br/>) | boolean | 尝试取消执行此任务。<br/>如果任务已完成、已取消或由于其他原因无法取消，则此尝试将失败。<br/>如果成功，并且在调用cancel时此任务尚未启动，则此任务不应运行。<br/>如果任务已启动，则mayInterruptIfRunning参数确定执行此任务的线程是否应中断以尝试停止任务。 |
| isCancelled()                                   | boolean | 如果此任务在正常完成之前被取消，则返回true。                 |
| isDone()                                        | boolean | 如果此任务已完成，则返回true。完成可能是由于正常终止、异常或取消——在所有这些情况下，此方法都将返回true。 |
| get()                                           | V       | 如果需要，等待计算完成，然后检索其结果。                     |
| get(<br/>long timeout, <br/>TimeUnit unit<br/>) | V       | 如果需要，最多等待给定的时间以完成计算，然后检索其结果（如果可用）。 |



## RunnableFuture

是指异步计算结果是可运行的，继承了[Future](##Future)和Runnable接口。



## ThreadFactory

线程工厂接口。

```java
public interface ThreadFactory {

    /**
     * 返回一个新线程，返回的线程可以先设置了：优先级、名称、守护进程状态、ThreadGroup等
     */
    Thread newThread(Runnable r);
}
```



## Executor

是Java5新特性，表示执行器，是用于运行任务的接口。

```java
public interface Executor {
    void execute(Runnable command);
}
```



## Executors

线程池工厂，Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 Callable 类提供了一些工具方法。

| 创建线程池方法                                     | 说明                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| newFixedThreadPool(<br/>int<br/>)                  | 创建线程数量固定的线程池，当线程处于空闲状态时，他们并不会被回收，除非线程池被关闭。当所有的线程都处于活动状态时，新的任务都会处于等待状态，直到有线程空闲出来。 |
| newSingleThreadExecutor()                          | 创建单个线程。它适用于需要保证顺序地执行各个任务;并且在任意时间点，不会有多个线程是活动的应用场景。 |
| newCachedThreadPool()                              | 创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程, 如果没有可用的线程，将创建一个新的线程并将其添加到该池中。 未使用六十秒的线程将被终止并从缓存中删除。 |
| newScheduledThreadPool(<br/>int corePoolSize<br/>) | 创建一个线程池，可以调度命令在给定的延迟之后运行，或定期执行, 支持执行定时性或周期性任务。 |
| newWorkStealingPool(<br/>int parallelism<br/>)     | 创建一个维护足够的线程以支持给定的并行级别的线程池，并且可以使用多个队列来减少争用。 ( jdk1.8版本新增的方法 ) |



## ExecutorService

是线程池接口，继承并扩展了[Executor](##Executor)接口，添加了用来管理执行器生命周期和任务生命周期的方法。

![f0644574eaac6edacc45b937ef518fc8](./01.Java_part1.assets/f0644574eaac6edacc45b937ef518fc8.png)

| 方法                                                         | 返回值           | 说明                                                         |
| ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ |
| shutdown()                                                   | void             | 关闭线程池，不再接受新任务，但会继续执行先前已提交的任务；<br/>如果线程池已经关闭，则没有效果；<br/>此方法不会阻塞当前线程，来等待已提交的任务运行完毕，而是会让当前线程继续向下运行；<br/>可以配合使用 `awaitTermination` 方法阻塞当前线程，等待所有任务执行完毕； |
| shutdownNow()                                                | List\<Runnable>  | 关闭线程池，不再接受新任务，但会继续执行先前已提交的任务；<br/>如果线程池已经关闭，则没有效果；<br/>此方法不会阻塞当前线程，来等待已提交的任务运行完毕，而是会让当前线程继续向下运行；<br/>可以配合使用 `awaitTermination` 方法阻塞当前线程，等待所有任务执行完毕；<br/>会通过对阻塞线程执行线程中断操作，但任务肯能不会响应中断，任务可能不会终止执行。 |
| isShutdown()                                                 | boolean          | 返回true，表示线程池已执行了关闭方法 shutdown()              |
| isTerminated()                                               | boolean          | 返回true，表示线程池已关闭，且所有任务都已完成；<br/>如果没有执行shutdown或shutdownNow方法，则isTerminated方法永远不返回true。 |
| awaitTermination(<br/>long timeout, <br/>TimeUnit unit<br/>) | boolean          | 阻塞当前线程，直到所有已提交的任务执行完毕、等待超时、被线程中断。<br/>timeout：等待超时时间；<br/>unit：等待超时时间的单位；<br/>如果连接池自然终止，返回true；如果是超时终止的，返回false |
| submit(<br/>Callable\<T> task<br/>)                          | Future\<T>       | 向线程池中提交一个 Callable的任务，并返回该任务的计算结果Future；<br/>Future的get方法可阻塞当前线程直到该任务运行完毕；<br/> |
| submit(<br/>Runnable task, <br/>T result<br/>)               | Future\<T>       | 向线程池中提交一个 Callable的任务，并返回该任务的计算结果Future；<br/>Future的get方法可阻塞当前线程直到该任务运行完毕，并返回第二个参数； |
| submit(<br/>Runnable task<br/>)                              | Future<?>        | 向线程池中提交一个 Runnable的任务，并返回该任务的计算结果Future；<br/>Future的get方法可阻塞当前线程直到该任务运行完毕；<br/> |
| invokeAll(<br/>Collection<? extends Callable\<T>> tasks<br/>) | List<Future\<T>> | 向线程池中提交一个 Callable任务的集合，当集合中所有任务完成时，返回保存其状态和结果的Future集合；<br/>请注意，集合中的任务可以是正常运行结束，也可能发生了异常；<br/>如果在执行此操作时修改了给定集合，则此方法的结果是未知的；<br/>返回任务的Futures集合，集合中的顺序与迭代第一个参数中元素的顺序相同，每个任务都已完成，<br/>即Future.isDone都为true |
| invokeAll(<br/>Collection<? extends Callable<T>> tasks,<br/>long timeout,<br/>TimeUnit unit<br/>) | List<Future\<T>> | 向线程池中提交一个 Callable任务的集合，当集合中所有任务完成或等待超时，返回保存其状态和结果的Future集合；<br/>如果是等待超时了，则此时未完成的任务会被取消；<br/>请注意，集合中的任务可以是正常运行结束，也可能发生了异常；<br/>如果在执行此操作时修改了给定集合，则此方法的结果是未知的；<br/>返回任务的Futures集合，集合中的顺序与迭代第一个参数中元素的顺序相同，每个任务都已完成，<br/>即Future.isDone都为true |
| invokeAny(<br/>Collection<? extends Callable<T>> tasks<br/>) | T                | 向线程池中提交一个 Callable任务的集合，随机返回一个已成功完成的任务结果（如果有）。<br/>返回一个值后，其余未完成的任务将被取消；<br>如果在执行此操作时修改了给定集合，则此方法的结果是未知的； |
| invokeAny(<br/>Collection<? extends Callable\<T>> tasks,<br/>long timeout, <br/>TimeUnit unit<br/>) | T                | 向线程池中提交一个 Callable任务的集合，在给定的超时时间内，随机返回一个已成功完成的任务结果（如果有）。<br/>返回一个值后，其余未完成的任务将被取消；<br/>如果在执行此操作时修改了给定集合，则此方法的结果是未知的； |



### ThreadPoolExecutor

默认使用 ThreadPoolExecutor类实现 ExecutorService接口。

ThreadPoolExecutor的作用是生产和管理线程池的，可以通过调用 execute 方法和 submit 方法执行多线程任务。

构造方法参数：

| 方法                                                         | 返回值                   | 说明                                                         |
| ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| ThreadPoolExecutor(<br/>int corePoolSize,<br/>int maximumPoolSize,<br/>long keepAliveTime,<br/>TimeUnit unit,<br/>BlockingQueue<Runnable> workQueue<br/>) |                          | 构造方法                                                     |
| ThreadPoolExecutor(<br/>int corePoolSize,<br/>int maximumPoolSize,<br/>long keepAliveTime,<br/>TimeUnit unit,<br/>BlockingQueue<Runnable> workQueue,<br/>ThreadFactory threadFactory<br/>) |                          | 构造方法                                                     |
| ThreadPoolExecutor(<br/>int corePoolSize,<br/>int maximumPoolSize,<br/>long keepAliveTime,<br/>TimeUnit unit,<br/>BlockingQueue\<Runnable> workQueue,<br/>RejectedExecutionHandler handler<br/>) |                          | 构造方法                                                     |
| ThreadPoolExecutor(<br/>int corePoolSize,<br/>int maximumPoolSize,<br/>long keepAliveTime,<br/>TimeUnit unit,<br/>BlockingQueue<Runnable> workQueue,<br/>ThreadFactory threadFactory,<br/>RejectedExecutionHandler handler<br/>) |                          | 构造方法                                                     |
| isTerminating()                                              | boolean                  | 如果此执行器在关机或关机后正在终止，但尚未完全终止，则返回true；<br/>此方法可能对调试有用。<br/>关闭后一段时间内报告的返回值为true<br/>可能表明提交的任务已忽略或抑制中断，导致此执行器无法正确终止。 |
| setThreadFactory(<br/>ThreadFactory threadFactory<br/>)      | void                     | 设置线程工厂                                                 |
| getThreadFactory()                                           | ThreadFactory            | 返回线程工厂                                                 |
| setRejectedExecutionHandler(<br/>RejectedExecutionHandler handler<br/>) | void                     | 设置拒绝策略                                                 |
| getRejectedExecutionHandler()                                | RejectedExecutionHandler | 返回拒绝策略                                                 |
| setCorePoolSize(int corePoolSize)                            | void                     | 设置核心线程数                                               |
| getCorePoolSize()                                            | int                      | 返回核心线程数                                               |
| prestartCoreThread()                                         | boolean                  | 启动一个核心线程，使其空闲运行，并等待分配的任务；<br/>覆盖默认策略：仅在提交第一个任务时启动核心线程的策略；<br/>如果所有核心线程都已启动，则此方法将返回false |
| prestartAllCoreThreads()                                     | int                      | 启动一个核心线程，使其空闲运行，并等待分配的任务；<br/>覆盖默认策略：仅在提交第一个任务时启动核心线程的策略；<br/>返回启动的核心线程个数 |
| allowsCoreThreadTimeOut()                                    | boolean                  | 如果此池允许核心线程超时并在keepAlive时间内没有任务到达时终止，则返回true；<br/>如果需要，在新任务到达时替换。如果为true，则应用于非核心线程的相同保活策略也适用于核心线程。如果为false（默认值），核心线程将不会因缺少传入任务而终止。 |
| allowCoreThreadTimeOut(boolean value)                        | void                     |                                                              |
| setMaximumPoolSize(int maximumPoolSize)                      | void                     |                                                              |
| getMaximumPoolSize()                                         | int                      |                                                              |
| setKeepAliveTime(long time, TimeUnit unit)                   | void                     |                                                              |
| getKeepAliveTime(TimeUnit unit)                              | long                     |                                                              |
| getQueue()                                                   | BlockingQueue\<Runnable> |                                                              |
| remove(Runnable task)                                        | boolean                  |                                                              |
| purge()                                                      | void                     |                                                              |
| getPoolSize()                                                | int                      |                                                              |
| getActiveCount()                                             | int                      |                                                              |
| getLargestPoolSize()                                         | int                      |                                                              |
| getTaskCount()                                               | long                     |                                                              |
| getCompletedTaskCount()                                      | long                     |                                                              |



#### 核心线程数

corePoolSize，核心线程数，是指长期存活的线程数。

有新任务提交时，首先检查核心线程数，如果核心线程都在工作，而且数量也已经达到最大核心线程数，则不会继续新建核心线程，而会将任务放入等待队列。

#### 最大线程数

maximumPoolSize，最大线程数（包括核心线程和非核心线程）

#### 线程空闲时间

keepAliveTime，线程池中空闲线程（仅适用于非核心线程）所能存活的最长时间，销毁的线程数 = maximumPoolSize - corePoolSize。long 类型。

#### 存活时间单位

unit，存活时间单位，与 keepAliveTime 参数搭配使用。

|         参数          | 含义 |
| :-------------------: | :--: |
|     TimeUnit.DAYS     |  天  |
|    TimeUnit.HOURS     | 小时 |
|   TimeUnit.MINUTES    | 分钟 |
|   TimeUnit.SECONDS    |  秒  |
| TimeUnit.MILLSECONDS  | 毫秒 |
| TimeUnit.MICROSECONDS | 微秒 |
| TimeUnit.NANOSECONDS  | 纳秒 |

#### 阻塞队列

参数名 workQueue，参数类型 BlockingQueue，关于队列大小与线程数量之间存在这样的关系：

- 如果线程数少于corePoolSize，对于提交的新任务会创建一个新的线程处理，并不会把任务放入队列；

- 如果线程数介于corePoolSize和maximumPoolSize之间，新提交的任务会被放入阻塞队列中；

- 如果线程池处于饱和状态，即无法创建线程也无法存放在阻塞队列，那么新任务将交由拒绝策略来处理；

|    阻塞队列实现类     |                             含义                             |
| :-------------------: | :----------------------------------------------------------: |
|  ArrayBlockingQueue   |               一个由数组结构组成的有界阻塞队列               |
|  LinkedBlockingQueue  |               一个由链表结构组成的有界阻塞队列               |
|   SynchronousQueue    |    一个不存储元素的阻塞队列，即直接提交给线程，不保持它们    |
| PriorityBlockingQueue |               一个支持优先级排序的无界阻塞队列               |
|      DelayQueue       | 一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素 |
|  LinkedTransferQueue  | 一个由链表结构组成的无界阻塞队列。与 SynchronousQueue 类似，还含有非阻塞方法 |
|  LinkedBlockingDeque  |               一个由链表结构组成的双向阻塞队列               |

#### 线程工厂

参数名 threadFactory，参数类型 ThreadFactory，可以设置线程的优先级、线程的命名规则以及线程的类型（用户线程还是守护线程）等。

```java
public static void main(String[] args) {
    // 创建线程工厂
    ThreadFactory threadFactory = new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            // 创建线程池中的线程
            Thread thread = new Thread(r);
            // 设置线程名称
            thread.setName("线程-" + r.hashCode());
            // 设置线程优先级
            thread.setPriority(Thread.MAX_PRIORITY);
            // 设置线程类型（守护线程、用户线程）, false-用户线程
            thread.setDaemon(false);
            return thread;
        }
    };
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 2,
            0, TimeUnit.SECONDS, new LinkedBlockingQueue<>(), threadFactory);
    threadPoolExecutor.submit(new Runnable() {
        @Override
        public void run() {
            Thread thread = Thread.currentThread();
            System.out.println(String.format("线程: %s, 线程优先级: %d",
                    thread.getName(), thread.getPriority()));
        }
    });
}
```

#### 拒绝策略

参数名 handler，参数类型 RejectedExecutionHandler，是指线程池处于满负荷状态下（即阻塞队列排已满），对新提交任务的拒绝策略。

| 参数                                   | 说明                                                 |
| :------------------------------------- | :--------------------------------------------------- |
| ThreadPoolExecutor.AbortPolicy         | 默认策略，拒绝并抛出异常                             |
| ThreadPoolExecutor.CallerRunsPolicy    | 在线程池和队列饱和的情况下，调用者的线程会执行该任务 |
| ThreadPoolExecutor.DiscardOldestPolicy | 抛弃队列头部（最先添加）的一个任务，并执行当前任务   |
| ThreadPoolExecutor.DiscardPolicy       | 忽略并抛弃当前任务                                   |



### ScheduledExecutorService

扩展了ExecutorService，支持Future和定期执行任务



### ForkJoinPool

线程池，是Java7新特性，实现了 ExecutorService线程池接口，根据字面意思Fork是分拆的意思，Join是合并的意思，就是可以把一个任务递归拆分成多个子任务，在线程池中并行运行，最后将子任务结果合并后返回。运用了工作窃取算法，可以让已完成任务的线程，从其他工作中的线程窃取任务来执行，这样可充分利用工作线程的计算能力，减少线程由于获取不到任务而造成的空闲浪费。

>**工作窃取算法：**
>
>是指把一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。其中某个线程会先把自己队列里的任务执行完毕，而其他线程的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是就去其他线程的队列里窃取一个任务来执行。这时2个线程可能会同步访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务线程永远从双端队列的尾部拿任务执行。

![在这里插入图片描述](./01.Java_part1.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX1_lpYvmlpfnmoTljaHljaE=,size_9,color_FFFFFF,t_70,g_se,x_16)

| 方法                                                         | 返回值                      | 说明                                                         |
| ------------------------------------------------------------ | --------------------------- | ------------------------------------------------------------ |
| ForkJoinPool()                                               |                             | 构造方法；<br/>                                              |
| ForkJoinPool(int parallelism)                                |                             | 构造方法；<br/>                                              |
| ForkJoinPool(<br/>int parallelism,<br/>ForkJoinWorkerThreadFactory factory,<br/>UncaughtExceptionHandler handler,<br/>boolean asyncMode<br/>) |                             | 构造方法；<br/>                                              |
| commonPool()                                                 | ForkJoinPool                | 静态方法；<br/>                                              |
| invoke(<br/>ForkJoinTask<T> task<br/>)                       | T                           | 执行给定任务，完成后返回其结果。<br/>如果计算遇到未选中的异常或错误，则会作为此调用的结果重新引发。<br/>重新抛出的异常的行为方式与常规异常相同，但在可能的情况下，包含当前线程以及实际遇到异常的线程的堆栈跟踪（例如，使用ex.printStackTrace（）显示）；至少只有后者。 |
| execute(<br/>ForkJoinTask<?> task<br/>)                      | void                        | 安排给定任务的（异步）执行。                                 |
| execute(<br/>Runnable task<br/>)                             | void                        | 安排给定任务的（异步）执行。                                 |
| submit(<br/>ForkJoinTask<T> task<br/>)                       | ForkJoinTask\<T>            |                                                              |
| submit(<br/>Callable<T> task<br/>)                           | ForkJoinTask\<T>            |                                                              |
| submit(<br/>Runnable task, <br/>T result<br/>)               | ForkJoinTask<T>             |                                                              |
| submit(<br/>Runnable task<br/>)                              | ForkJoinTask<?>             |                                                              |
| invokeAll(<br/>Collection<? extends Callable\<T>> tasks<br/>) | List<Future\<T>>            |                                                              |
| getFactory()                                                 | ForkJoinWorkerThreadFactory | 返回用于构建新工人的工厂。                                   |
| getUncaughtExceptionHandler()                                | UncaughtExceptionHandler    | 返回由于执行任务时遇到不可恢复错误而终止的内部工作线程的处理程序。 |
| getParallelism()                                             | int                         | 返回此池的目标并行级别。                                     |
| getCommonPoolParallelism()                                   | int                         | 返回公共池的目标并行级别。                                   |
| getPoolSize()                                                | int                         | 返回已启动但尚未终止的工作线程数。当创建线程以在其他线程被协作阻止时保持并行性时，此方法返回的结果可能与getParallelism不同。 |
| getAsyncMode()                                               | boolean                     | 如果此池对从未加入的分叉任务使用本地先进先出调度模式，则返回true。 |
| getRunningThreadCount()                                      | int                         | 返回等待加入任务或其他托管同步而未被阻止的工作线程数的估计值。此方法可能会高估正在运行的线程数。 |
| getActiveThreadCount()                                       | int                         | 返回当前正在窃取或执行任务的线程数的估计值。此方法可能会高估活动线程的数量。 |
| isQuiescent()                                                | boolean                     | 如果所有工作线程当前都处于空闲状态，则返回true。空闲工作线程是指无法获得要执行的任务的工作线程，因为没有任务可从其他线程中窃取，并且没有向池提交的挂起提交。这种方法是保守的；当所有线程空闲时，它可能不会立即返回true，但如果线程保持非活动状态，它最终会变为true。 |
| getStealCount()                                              | long                        | 返回另一个线程从一个线程的工作队列中窃取的任务总数的估计值。报告的值低估了池不静止时的实际总抢断次数。这个值对于监视和调优fork/join程序可能很有用：通常，窃取计数应该足够高，以保持线程繁忙，但足够低，以避免开销和线程之间的争用。 |
| getQueuedTaskCount()                                         | long                        | 返回工作线程当前保存在队列中的任务总数的估计值（但不包括提交到池中尚未开始执行的任务）。该值只是一个近似值，通过在池中的所有线程之间迭代获得。此方法可用于调整任务粒度。 |
| getQueuedSubmissionCount()                                   | int                         | 返回提交到此池但尚未开始执行的任务数的估计值。这种方法可能需要与提交数量成比例的时间。 |
| hasQueuedSubmissions()                                       | boolean                     | 如果提交到此池的任何任务尚未开始执行，则返回true。           |
| isTerminating()                                              | boolean                     | 如果终止过程已开始但尚未完成，则返回true。此方法可能对调试有用。关机后一段时间内报告的返回值为true可能表明提交的任务已忽略或抑制中断，或正在等待I/O，导致此执行器无法正确终止。（请参阅ForkJoinTask类的咨询说明，说明任务通常不应包含阻塞操作。但如果需要，则必须在中断时中止它们。） |
| awaitQuiescence(<br/>long timeout, <br/>TimeUnit unit<br/>)  | boolean                     | 如果由在此池中运行的ForkJoinTask调用，则等效于ForkJoinTask.helpQuiesce。否则，将等待和/或尝试协助执行任务，直到此池处于Quiesce状态或经过指定的超时。 |
| managedBlock(ManagedBlocker blocker)                         | void                        | 静态方法；<br/>运行给定的可能阻塞的任务。在ForkJoinPool中运行时，如果需要，该方法可能会安排激活一个备用线程，以确保在blocker.block（）中阻塞当前线程时有足够的并行性。 |



#### ForkJoinTask

是一个抽象类，表示一个 ForkJoinPool线程池的任务，ForkJoinTask有三个抽象子类：RecusiveAction、RecusiveTask、CountedCompleter。



#### RecursiveTask

带有返回值的 ForkJoinPool任务。

例如：

```java
/**
 * 一个ForkJoin任务
 */
class TestForkJoinTask extends RecursiveTask<Long> {
	private static final long serialVersionUID = 1L;
	private long[] array;
	private int begin; // 数组的其实位置，从0开始
	private int end; // 数组的终止位置，从0开始
	private int forksize; // 拆分多任务的阀值
	
	public TestForkJoinTask(long[] array, int begin, int end, int forksize) {
		super();
		this.array = array;
		this.begin = begin;
		this.end = end;
		this.forksize = forksize;
		System.out.println(this.begin + " - " + this.end);
	}
	
	/**
	 * 拆分ForkJoin任务，注意任务拆分是否合理会影响整体效率
	 */
	@Override
	protected Long compute() {
		long total = 0;
		if ((this.end - this.begin + 1) <= this.forksize) { // 如果数组个数小于阀值的话，不使用ForkJoin策略
			for (int i = this.begin; i <= this.end; i++) {
				total += this.array[i];
			}
		} else { // 将一个大任务切分成多个小任务
			List<TestForkJoinTask> list = new ArrayList<TestForkJoinTask>();
			for (int i = this.begin; i <= this.end; i++) {
				int end = Math.min(i + this.forksize - 1, this.end); // 子任务的结束位置
				TestForkJoinTask task = new TestForkJoinTask(this.array, i, end, this.forksize);
				list.add(task);
				task.fork();
				i = end;
			}
			
			for (TestForkJoinTask t : list) {
				total += t.join();
			}
		}
		return total;
	}
}

public class TestForkJoinTaskPool {
	
	public static void main(String[] args) {
		long[] a = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };
		ForkJoinPool pool = new ForkJoinPool(); // pool = ForkJoinPool.commonPool()
		Long result = pool.invoke(new TestForkJoinTask(a, 0, a.length - 1, 5)); // 执行一个任务
		pool.shutdown();
		System.out.println("计算结果是：" + result);
	}
}
```



#### RecusiveAction

不带返回值的任务。

例如：

```java
/**
 * 一个ForkJoin任务
 */
class TestForkJoinAction extends RecursiveAction {
	private static final long serialVersionUID = 1L;
	private long[] array;
	private int begin; // 数组的其实位置，从0开始
	private int end; // 数组的终止位置，从0开始
	private int threshold; // 拆分多任务的阀值
	long total = 0; // 最终结果
	
	public TestForkJoinAction(long[] array, int begin, int end, int threshold) {
		super();
		this.array = array;
		this.begin = begin;
		this.end = end;
		this.threshold = threshold;
		System.out.println(this.begin + " - " + this.end);
	}
	
	/**
	 * 拆分ForkJoin任务，注意任务拆分是否合理会影响整体效率
	 */
	@Override
	protected void compute() {
		if ((this.end - this.begin + 1) <= this.threshold) { // 如果数组个数小于阀值的话，不使用ForkJoin策略
			for (int i = this.begin; i <= this.end; i++) {
				this.total += this.array[i];
			}
		} else { // 将一个大任务切分成多个小任务
			List<TestForkJoinAction> list = new ArrayList<TestForkJoinAction>();
			for (int i = this.begin; i <= this.end; i++) {
				int end = Math.min(i + this.threshold - 1, this.end); // 子任务的结束位置
				TestForkJoinAction task = new TestForkJoinAction(this.array, i, end, this.threshold);
				list.add(task);
				task.fork();
				i = end;
			}
			
			for (TestForkJoinAction t : list) {
				this.total += t.value();
			}
		}
	}
	
	public long value() {
		return this.total;
	}
}

public class TestForkJoinActionPool {
	
	public static void main(String[] args) {
		long[] a = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };
		ForkJoinPool pool = new ForkJoinPool(); // pool = ForkJoinPool.commonPool()
		TestForkJoinAction task = new TestForkJoinAction(a, 0, a.length - 1, 5);
		pool.invoke(task); // 执行一个任务
		pool.shutdown();
		System.out.println("计算结果是：" + task.value());
	}
}
```



#### CountedCompleter

是Java8新特性，只有一个任务需要join操作且任务间并不阻塞线程池内部的调用，任务间的联系需要通过相应回调来触发，其通过完成回调方法合并其依赖的结果；

？？？？？



## CompletableFuture

CompletableFuture实现了Future接口和CompletionStage，因此CompletableFuture是对Futrue的功能增强包含了Future的功能。从继承的另一个CompletionStage的名称来看完成阶段性的接口。



## CompletionStage

接口定义了任务编排的方法，执行某一阶段，可以向下执行后续阶段。异步执行的，默认线程池是ForkJoinPool.commonPool()，但为了业务之间互不影响，且便于定位问题，强烈推荐使用自定义线程池。





Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。更多详细信息请点击这里。



什么是FutureTask?

FutureTask包装器是一种非常便利的机制，可将Callable转换成Future和Runnable，它同时实现两者的接口。

FutureTask类是Future 的一个实现，并实现了Runnable，所以可通过Excutor(线程池) 来执行。也可传递给Thread对象执行。如果在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。





什么是Callable和Future?

Java 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。

Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。



异步多线程任务执行且返回有结果，三个特点：多线程/有返回/异步任务

1. 工厂和工具方法Executor ， ExecutorService ， ScheduledExecutorService ， ThreadFactory和Callable在此包中定义的类；





# 网络编程

![JavaNetWork_0](./01.Java_part1.assets/JavaNetWork_0.jpeg)

OSI模型的上面三层（应用层、表示层、会话层）与TCP/IP模型的应用层是面向用户应用的，OSI模型的下面4层（传输层、网络层、数据链路层、物理层）与TCP/IP模型的传输层、网际层、网络接口层是面向数据通信的；

- 物理层

  - 定义了通信网络之间物理链路的电气或机械特性；
  - 将0，1比特流与电压或光等传输方式之间的互换，实现计算机节点之间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异；
  - 设备：中继器、网线、集线器等等；

- 数据链路层

  负责物理层上的互连的，节点间的同学，利用物理层的服务，在通信的实体间透明地传输，以“帧”为单位的数据单元。通过一些数据链路层协议和链路控制规程，实现可靠的数据传输；

  设备：网卡、网桥、交换机；

- 网络层

  负责分组传送、路由选择、流量控制，主要用于实现端到端通信系统中，中间结点的路由选择；

  设备：路由器、防火墙、多层交换机；

- 传输层

  定义传输数据的协议端口号，以及流控和差错校验，协议有TCP、UDP，数据包一旦离开网卡即进入网络传输层；

- 会话层

  负责通信管理、建立、断开通信以及数据分割等数据传输相关管理；

- 表示层

  表示层的作用是负责数据加密：对称加密、非对称加密、HASH 256加密、光密；

- 应用层

  直接向用户提供服务，完成用户希望在网络上完成得各种工作；

  同时还包括建立与结束使用者之间得联系、监督、管理相互连接起来的应用系统和所使用得应用资源；



## TCP

TCP是基于连接的，而UDP是基于非连接，三次握手，运输确认，四次挥手；

- 三次握手
  - 当客户端向服务端发起连接时，会先发一包连接请求数据过去询问，能否与你建立连接，这包数据我们称为SYN包；
  - 如果对端同意连接则回复一包SYN+ACK包；
  - 客户端收到之后回复一包ACK包，连接建立；
  - 因为这个过程中互相发送了三包数据，所以称之为三次握手；

- 四次挥手
  - 处于连接状态的客户端和服务端，都可发起关闭连接请求，此时需要四次挥手来进行连接关闭；
  - 假设客户端主动发起连接关闭的请求，需要向服务端发起FIN包，表示要关闭连接，自己进入终止等待1状态，这是第一次挥手；
  - 服务端收到FIN包，发送ACK包，表示自己进入了关闭等待状态，客户端进入终止等待2状态，这是第二次挥手；
  - 服务端此时还可以发送未发送的数据，而客户端还可以接收数据，待服务端发送完数据以后，发送一包FIN包，进入最后确认状态，这是第三次挥手；
  - 客户端收到之后回复ACK包，进入超时等待状态，经过超时时间互关闭连接，而服务端收到ACK包后，立即关闭连接，这是第四次挥手；



## UDP

UDP协议是基于非连接的，发送数据就是简单的把数据包简单的封装一下，然后从网卡发出去就可以了，数据包之间并没有状态上的联系，正因为UDP这种简单的数据处理模式，导致他们的性能损耗非常少，对于CPU内存资源的占用也远小于TCP，但是对于网络传输过程中产生的丢包，UDP协议并不能保证，所以UDP在传输稳定性上要弱于TCP；

- 区别

  - TCP：稳定可靠（适用于要求较高的场景，需要准确无误的传输给对方，比如传输文件，发送邮件，浏览网页等）；

  - UDP：速度快，但是可能产生丢包，所以适用于对实时性要求较高，但是对少量丢包，并没有太大要求的场景，比如域名查询，电话通信，视频直播等；

    UDP还有重要的应用场景：即隧道网络（即常用的VPN，以及在SDN中用到的VXLAN也是一种）；



## URI

统一资源标识符（Uniform Resource Identifier），是一种标准，包含URL、URN，对应**java.net.URI**类；

```java
public class TestURI {

	public static void main(String[] args) throws MalformedURLException, URISyntaxException {
		URI u1 = new URI("http://www.baidu.com");
		URI u2 = new URI("http", "//www.baidu.com", null);
		URI u3 = new URI("http", "//www.baidu.com", "today");
		URI u4 = new URI(null, "//www.baidu.com", "today");// 创建一个相对URI
		URI u5 = new URI("http", "//www.baidu.com", "<");// 片段标识赋符中禁止的字符自动转义
		URI u6 = new URI("http", "//www.baidu.com", "/javafaq/index.html", "referrer=cnet&date=2014-02-23", "<");
		URI u7 = new URI("ftp", "anoymous:elharo#ibiblio.org", "ftp.oreilly.com", 21, "/javafaq/index.html", null, null);
		System.out.println(u1);
		System.out.println(u2);
		System.out.println(u3);
		System.out.println(u4);
		System.out.println(u5);
		System.out.println(u6);
		System.out.println(u7);
	}
}
```

输出结果：

```http
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com#today
//www.baidu.com#today
http://www.baidu.com#%3C
http://%2F%2Fwww.baidu.com/javafaq/index.html?referrer=cnet&date=2014-02-23#%3C
ftp://anoymous:elharo%23ibiblio.org@ftp.oreilly.com:21/javafaq/index.html
```



## URL

统一资源定位符（Uniform Resource Locator）编码是浏览器发送数据给服务器时使用的编码；

例如：https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87

- URL编码

  因为出于兼容性考虑，很多服务器只识别**ASCII**字符，需要将中文字符转换为ASCII字符；

  如果字符是`A-Z`，`a-z`，`0-9`以及`-_.*` 则无需转码；

  如果是非**ASCII**码，则转为UTF-8编码，且对每个字节以`%XX`表示；

  URL编码中英文字母总是大写；

  URLEncoder把空格字符编码成+，而URL编码标准要求空格被编码为%20，字符串UTF-8的编码是0xe4b8ad，对应的URL编码是%E4%B8%AD；

  案例：

  ```java
  public class TestURL1 {
  	
  	public static void main(String[] args) throws Exception { // 下载网络图片
  		URL url = new URL("https://alifei04.cfp.cn/creative/vcg/veer/1600water/veer-152280783.jpg"); // 网络图片连接
  //		URL url = new URL("https", "alifei04.cfp.cn", 443, "/creative/vcg/veer/1600water/veer-152280783.jpg");
  		java.net.URLConnection connection = url.openConnection();
  		try (InputStream is = connection.getInputStream();) {
  			File pic = new File(System.getProperty("user.home"), "xxx.jpg");
  			pic.delete();
  			System.out.println(pic.getAbsolutePath());
  			Files.copy(is, Paths.get(pic.getAbsolutePath()));
  		} catch (Exception e) {
  			e.printStackTrace();
  		}
  	}
  }
  ```

- URLEncoder编码

  ```java
  public class TestURL {
  	public static void main(String[] args) throws UnsupportedEncodingException {
  		String encoded = URLEncoder.encode("中文!", "UTF-8");
  		String decoded = URLDecoder.decode("%E4%B8%AD%E6%96%87%21", "UTF-8");
  		System.out.println(encoded);
  		System.out.println(decoded);
  	}
  }
  ```

  输出结果：

  ```http
  %E4%B8%AD%E6%96%87%21
  中文!
  ```

  中的URL编码是%E4%B8%AD，文的URL编码是%E6%96%87，!是ASCII字符，也要对其编码为%21；

- Base64编码

  Base64编码可以把任意长度的二进制数据变为纯文本，且只包含A-Z、a-z、0-9、+、/、=这些字符；

  原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。

  举个例子：3个byte数据分别是e4、b8、ad，按6bit分组得到39、0b、22和2d：
  ![img](./01.Java_part1.assets/JavaBase64_0-2600799.png)

  因为6位整数的范围总是0-63，所以能用64个字符表示：字符A-Z对应索引0-25，字符a-z对应索引26-51，字符0-9对应索引52-61，最后两个索引62、63分别用字符+和/表示；

  例如：

  ```java
  public class TestBase64 {
      public static void main(String[] args) {
          byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad };
          String b64encoded = Base64.getEncoder().encodeToString(input); // 编码
          byte[] output = Base64.getDecoder().decode("5Lit"); // 解码
          System.out.println(b64encoded);
          System.out.println(Arrays.toString(output)); // [-28, -72, -83]
      }
  }
  ```

  如果输入的byte[]数组长度不是3的整数倍，则需要对输入的末尾补一个或两个0x00，编码后在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，去掉末尾补充的一个或两个0x00即可；

  Base64编码可以用withoutPadding()方法去掉=，例如：

  ```java
  public class TestBase642 {
  	public static void main(String[] args) {
  		byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad, 0x21 };
  		String b64encoded = Base64.getEncoder().encodeToString(input);
  		String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);
  		System.out.println(b64encoded);
  		System.out.println(b64encoded2);
  		byte[] output = Base64.getDecoder().decode(b64encoded2);
  		System.out.println(Arrays.toString(output));
  	}
  }
  ```

  

## URN

统一资源命名（uniform resource name），是通过名字来标识，通过名称来标识位置。但是其流行还需要假以时日，因为他需要更精密软件支持；

```ini
urn:example:mammal:monotreme:echidna
协议方案名(scheme)：urn
路径(path)：example:mammal:monotreme:echidna
```



## HTTPS机制

HTTPS通过使⽤对称加密、⾮对称加密、数字证书等⽅式来保证数据的安全传输；

客户端向服务端发送数据之前，需要先建⽴TCP连接，所以需要先建⽴TCP连接，建⽴完TCP连接后，服务端会先给客户端发送公钥，客户端拿到公钥后就可以⽤来加密数据了，服务端到时候接收到数据就可以⽤私钥解密数据，这种就是通过⾮对称加密来传输数据；

不过⾮对称加密⽐对称加密要慢，所以不能直接使⽤⾮对称加密来传输请求数据，所以可以通过⾮对称加密的⽅式来传输对称加密的秘钥，之后就可以使⽤对称加密来传输请求数据了；

但是仅仅通过⾮对称加密+对称加密还不⾜以能保证数据传输的绝对安全，因为服务端向客户端发送公钥时，可能会被截取；

所以为了安全的传输公钥，需要⽤到数字证书，数字证书是具有公信⼒、⼤家都认可的，服务端向客户端发送公钥时，可以把公钥和服务端相关信息通过Hash算法⽣成消息摘要，再通过数字证书提供的私钥对消息摘要进⾏加密⽣成数字签名，在把没进⾏Hash算法之前的信息和数字签名⼀起形成数字证书，最后把数字证书发送给客户端，客户端收到数字证书后，就会通过数字证书提供的公钥来解密数字证书，从⽽得到⾮对称加密要⽤到的公钥；

在这个过程中，就算有中间⼈拦截到服务端发出来的数字证书，虽然它可以解密得到⾮对称加密要使⽤的公钥，但是中间⼈是办法伪造数字证书发给客户端的，因为客户端上内嵌的数字证书是全球具有公信⼒的，某个⽹站如果要⽀持HTTPS，都是需要申请数字证书的私钥的，中间⼈如果要⽣成能被客户端解析的数字证书，也是要申请私钥的，所以是⽐较安全了；



## 网络IO模型

![JavaIOFrame_BIO_NIO_AIO_0](./01.Java_part1.assets/JavaIOFrame_BIO_NIO_AIO_0.png)

### BIO

全称是Blocking IO，在JDK1.4之前是唯一的选择，是同步阻塞式，一个线程对应一个线程；

缺点：阻塞式IO、弹性伸缩能力强、多线程消耗资源；

**服务端**

```java
public class TestBIOServer {
	public static void main(String[] args) {
		System.out.println("启动服务器端 ..");
		ServerSocket serverSocket = null;
		try {
			serverSocket = new ServerSocket(8080); // 创建服务端
			Socket socket = null;
			while (true) {
				socket = serverSocket.accept();
				new Thread(new Handler(socket)).start(); // 获得到socket连接之后，分配线程任务进行处理
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (serverSocket != null) {
				try {
					serverSocket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
				serverSocket = null;
			}
		}
	}
}

class Handler implements Runnable {
	private Socket socket;
	
	public Handler(Socket socket) {
		this.socket = socket;
	}
	
	@Override
	public void run() {
		BufferedReader in = null;
		PrintWriter out = null;
		try {
			in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); // 输入流：接收数据
			String receive = null; // 接收数据
			out = new PrintWriter(this.socket.getOutputStream(), true); // 输出流：发送数据
			while (true) {
				receive = in.readLine();
				if (receive == null) {
					break;
				}
				out.println("收到请求: " + receive);
			}
		} catch (IOException e) {
			e.printStackTrace();
			if (in != null) {
				try {
					in.close();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
			}
			
			if (out != null) {
				out.close();
				out = null;
			}
		}
	}
}
```

**客户端**

```java
public class TestBIOClient {
	public static void main(String[] args) {
		Socket socket = null;
		BufferedReader in = null;
		PrintWriter out = null;
		try {
			socket = new Socket("127.0.0.1", 8080); // 创建连接
			out = new PrintWriter(socket.getOutputStream(), true); // 输出流：发送数据
			out.println("发送数据");
			
			in = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 输入流：接收数据
			String resp = in.readLine(); // 阻塞：未收到数据就等在这里
			System.out.println("服务器端回应：\n" + resp);
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				socket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			try {
				in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			out.close();
			out = null;
		}
	}
}
```



### NIO

全称Non-blocking IO，是同步非阻塞的IO模型，是JDK1.4新特性，支持面向缓冲区的、基于通道的IO，是高并发、高I/O的解决方案；

线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势；

accept/read/write方法的内核IO操作都会阻塞当前线程；

优点：非阻塞式IO模型、弹性伸缩能力强、单线陈节省资源；

缺点：使用复杂、多路复用器空轮询导致CPU高；

![JavaIOFrame_NIO_0](./01.Java_part1.assets/JavaIOFrame_NIO_0.png)

- 处理流程

  1. 每个 Channel 对应一个 Buffer；
  2. Selector 对应一个线程，一个线程对应多个 Channel；
  3. 该图反应了有三个 Channel 注册到该 Selector；
  4. 程序切换到那个 Channel 是由事件决定的（Event）；
  5. Selector 会根据不同的事件，在各个通道上切换；
  6. Buffer 就是一个内存块，底层是有一个数组；
  7. 数据的读取和写入是通过 Buffer，但是需要flip()切换读写模式，而 BIO 是单向的，要么输入流要么输出流；

- 核心组件

  1. Channel（通道）

     Channel 是 NIO 的核心概念，表示一个打开的连接，这个连接可以连接到 I/O 设备（例如：磁盘文件，Socket）或者一个支持 I/O 访问的应用程序，Java NIO 使用缓冲区和通道来进行数据传输；

     FileChannel类，本地文件IO通道，用于读取、写入、映射和操作文件的通道，使用文件通道操作文件的一般流程为：

     - 获取通道

       文件通道通过 FileChannel 的静态方法 open() 来获取，获取时需要指定文件路径和文件打开方式；

       ```java
       // 获取文件通道
       FileChannel.open(Paths.get(fileName), StandardOpenOption.READ);
       ```

     - 创建字节缓冲区

       文件相关的字节缓冲区有两种，一种是基于堆的 HeapByteBuffer，另一种是基于文件映射，放在堆外内存中的 MappedByteBuffer；

       ```java
       // 分配字节缓存
       ByteBuffer buf = ByteBuffer.allocate(10);
       ```

     - 读写操作

       读取数据：一般需要一个循环结构来读取数据，读取数据时需要注意切换 ByteBuffer 的读写模式；

       ```java
       while (channel.read(buf) != -1){ // 读取通道中的数据，并写入到 buf 中
           buf.flip(); // 缓存区切换到读模式
           while (buf.position() < buf.limit()){ // 读取 buf 中的数据
               text.append((char)buf.get());
           }
           buf.clear(); // 清空 buffer，缓存区切换到写模式
       }
       ```

       写入数据：

       ```java
       for (int i = 0; i < text.length(); i++) {
           buf.put((byte)text.charAt(i)); // 填充缓冲区，需要将 2 字节的 char 强转为 1 自己的 byte
           if (buf.position() == buf.limit() || i == text.length() - 1) { // 缓存区已满或者已经遍历到最后一个字符
               buf.flip(); // 将缓冲区由写模式置为读模式
               channel.write(buf); // 将缓冲区的数据写到通道
               buf.clear(); // 清空缓存区，将缓冲区置为写模式，下次才能使用
           }
       }
       ```

     - 持久化数据

       FileChannel的force(boolean metaData) 方法可以确保对文件的操作能够更新到磁盘；

       ```java
       channel.force(false);
       ```

     - 关闭通道

       ```java
       channel.close();
       ```

     **SocketChannel**类

     网络套接字IO通道，TCP协议，针对面向流的连接套接字的可选择通道（一般用在客户端）；

     TCP 客户端使用 SocketChannel 与服务端进行交互的流程为：

     - 打开通道

       连接到服务端

       ```java
       SocketChannel channel = SocketChannel.open(); // 打开通道，此时还没有打开 TCP 连接
       channel.connect(new InetSocketAddress("localhost", 9090)); // 连接到服务端
       ```

     - 分配缓冲区

       ```java
       ByteBuffer buf = ByteBuffer.allocate(10); // 分配一个 10 字节的缓冲区，不实用，容量太小
       ```

     - 配置是否为阻塞方式（默认阻塞方式）

       ```java
       channel.configureBlocking(false); // 配置通道为非阻塞模式
       ```

     - 与服务端进行数据交互

     - 关闭连接

       ```java
       channel.close(); // 关闭通道
       ```

     **ServerSocketChannel**类

     网络通信IO操作，TCP协议，针对面向流的监听套接字的可选择通道（一般用于服务端），流程如下：

     - 打开一个通道

       ```java
       ServerSocketChannel server = ServerSocketChannel.open(); // 打开通道
       ```

     - 绑定端口

       ```java
       server.bind(new InetSocketAddress(9090)); // 绑定端口
       ```

     - 阻塞等待客户端连接

       有新连接时会创建一个 SocketChannel 通道，服务端可以通过这个通道与连接过来的客户端进行通信。等待连接到来的代码一般放在一个循环结构中

       ```java
       SocketChannel client = server.accept(); // 阻塞，直到有连接过来
       ```

     - 通过 SocketChannel 与客户端进行数据交互

     - 关闭 SocketChannel

       ```java
       client.close();
       ```

  2. Buffer（缓冲区）

     在读取和写入数据时，都是先将数据保存到缓冲区，只要是访问NIO中的数据，都是放到缓冲区中；

     ![JavaIOFrame_NIO_Buffer_0](./01.Java_part1.assets/JavaIOFrame_NIO_Buffer_0.png)

     从上图可以看到，7种数据类型对应7种子类，这些名字是Heap开头子类，数据是存放在JVM堆中的；

     **MappedByteBuffer**类

     MappedByteBuffer类是存放在堆外的直接内存中，可以映射到文件。允许Java程序直接从内存中读取文件内容，通过将整个或部分文件映射到内存，由操作系统来处理加载请求和写入文件，应用只需要和内存打交道，这使得IO操作非常快；

     mmap内存映射和普通标准IO操作的本质区别在于，并不需要将文件中的数据先拷贝至OS的内核IO缓冲区，而是可以直接将用户进程私有地址空间中的一块区域与文件对象建立映射关系，这样程序就好像可以直接从内存中完成对文件读/写操作一样；

     只有当缺页中断发生时，直接将文件从磁盘拷贝至用户态的进程空间内，只进行了一次数据拷贝，对于容量较大的文件来说（文件大小一般需要限制在1.5~2G以下），采用Mmap的方式其读/写的效率和性能都非常高，大家熟知的RocketMQ就使用了该技术；

     **1）put():存入数据到缓冲区**

     - put(byte b)：将给定单个字节写入缓冲区的当前位置；
     - put(byte[] src)：将 src 中的字节写入缓冲区的当前位置；
     - put(int index, byte b)：将指定字节写入缓冲区的索引位置（不会移动 position）；

     **2）get():获取缓冲区的数据**

     - get() ：读取单个字节；
     - get(byte[] dst)：批量读取多个字节到 dst 中；
     - get(int index)：读取指定索引位置的字节（不会移动 position）；

     下面是读写结合的例子，执行三个基本操作：创建Buffer，然后从源文件读取数据到缓冲区，然后再将缓冲区写入目标文件；

     ```java
     public class TestNIO {
     	public static void test(String src, String dst) throws IOException {
     		FileInputStream fi = new FileInputStream(new File(src)); // 声明源文件和目标文件
     		FileOutputStream fo = new FileOutputStream(new File(dst));
     		FileChannel infc = fi.getChannel(); // 获得传输通道channel
     		FileChannel otfc = fo.getChannel();
     		ByteBuffer buffer = ByteBuffer.allocate(1024); // 获得容器buffer
     		while (true) {
     			int eof = infc.read(buffer); // 判断是否读完文件
     			if (eof == -1) {
     				break;
     			}
     			buffer.flip(); // 重设一下buffer的position=0，limit=position
     			otfc.write(buffer); // 开始写
     			buffer.clear(); // 写完要重置buffer，重设position=0,limit=capacity
     		}
     		infc.close();
     		otfc.close();
     		fi.close();
     		fo.close();
     	}
     }
     ```

  3. Selector（选择器）

     Selector可以注册到很多个Channel上，监听各个Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样就可以通过一个线程管理多个Channel，可以处理大量网络连接了；

     **选择器使用步骤**

     - 获取选择器

       与通道和缓冲区的获取类似，选择器的获取也是通过静态工厂方法 open() 来得到的；

       ```java
       Selector selector = Selector.open(); // 获取一个选择器实例
       ```

     - 获取可选择通道

       能够被选择器监控的通道必须实现了 SelectableChannel 接口，并且需要将通道配置成非阻塞模式，否则后续的注册步骤会抛出 IllegalBlockingModeException；

       ```java
       // 打开 SocketChannel 并连接到本机 9090 端口
       SocketChannel sc = SocketChannel.open(new InetSocketAddress("localhost", 9090));
       cs.configureBlocking(false); // 配置通道为非阻塞模式
       ```

     - 将通道注册到选择器

       通道在被指定的选择器监控之前，应该先告诉选择器，并且告知监控的事件，即：将通道注册到选择器；

       通道的注册通过 SelectableChannel.register(Selector selector, int ops) 来完成，ops 表示关注的事件，如果需要关注该通道的多个 I/O 事件，可以传入这些事件类型或运算之后的结果。这些事件必须是通道所支持的，否则抛出 IllegalArgumentException；

       ```java
       // 将套接字通过到注册到选择器，关注 read 和 write 事件
       socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);
       ```

     - 轮询 select 就绪事件

       通过调用选择器的 Selector.select() 方法可以获取就绪事件，该方法会将就绪事件放到一个 SelectionKey 集合中，然后返回就绪的事件的个数。这个方法映射多路复用 I/O 模型中的 select 系统调用，它是一个阻塞方法。正常情况下，直到至少有一个就绪事件，或者其它线程调用了当前 Selector 对象的 wakeup() 方法，或者当前线程被中断时返回；

       ```java
       while (selector.select() > 0){ // 轮询，且返回时有就绪事件
       Set<SelectionKey> keys = selector.selectedKeys(); // 获取就绪事件集合
       ...
       }
       ```

       有三种方式可以select就绪事件：

       - select()

         阻塞方法，有一个就绪事件，或者其他线程调用了wakeup()或者当前线程被中断时返回；

       - select(long timeout)

         阻塞方法，有一个就绪事件，或者其他线程调用了wakeup()，或者当前线程被中断，或者阻塞时长达到了超时限制时返回，不抛出超时异常；

       - selectNode()

         非阻塞方法，如果无就绪事件，则返回 0；如果有就绪事件，则将就绪事件放到一个集合，返回就绪事件的数量；

     - 处理就绪事件

       每次可以select出一批就绪的事件，需要对这些事件进行迭代：

       ```java
       for(SelectionKey key : keys) {
         if(key.isWritable()) { // 可写事件
           if("Bye".equals((line = scanner.nextLine()))) {
             socketChannel.shutdownOutput();
             socketChannel.close();
             break;
           }
           buf.put(line.getBytes());
           buf.flip();
           socketChannel.write(buf);
           buf.compact();
         }
       }
       ```

       SelectionKey代表这个通道在此Selector上注册，当某个Selector通知某个传入事件时，这是通过提供对应于该事件的 SelectionKey 来实现的；

       SelectionKey还可以用于取消通道的注册；

       SelectionKey中包含如下属性：

       - The interest set

         就像我们在前面讲到的把Channel注册到Selector来监听感兴趣的事件，interest set就是你要选择的感兴趣的事件的集合。你可以通过SelectionKey对象来读写interest set:

         ```java
         int interestSet = selectionKey.interestOps();
         boolean isInterestedInAccept  = interestSet & SelectionKey.OP_ACCEPT;
         boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;
         boolean isInterestedInRead    = interestSet & SelectionKey.OP_READ;
         boolean isInterestedInWrite   = interestSet & SelectionKey.OP_WRITE; 
         ```

         通过上面例子可以看到，我们可以通过用AND 和SelectionKey 中的常量做运算，从SelectionKey中找到我们感兴趣的事件；

       - The ready set

         ready set 是通道已经准备就绪的操作的集合。在一次选Selection之后，你应该会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合；

         ```java
         int readySet = selectionKey.readyOps();
         ```

         可以用像检测interest集合那样的方法，来检测Channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：

         ```java
         selectionKey.isAcceptable();
         selectionKey.isConnectable();
         selectionKey.isReadable();
         selectionKey.isWritable();
         ```

       - The Channel

         可以通过SelectionKey获得Selector和注册的Channel：

         ```java
         Channel  channel  = selectionKey.channel();
         ```

       - The Selector

         可以通过SelectionKey获得Selector和注册的Channel：

         ```java
         Selector selector = selectionKey.selector();
         ```

       - An attached object (optional)

         可以将一个对象或者更多信息attach 到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：

         ```java
         selectionKey.attach(theObject);
         Object attachedObj = selectionKey.attachment();
         ```

         还可以在用register()方法向Selector注册Channel的时候附加对象。如：

         ```java
         SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
         ```

       - 关于SelectedKeys()

         生产系统中一般会额外进行就绪状态检查

         一旦调用了select()方法，它就会返回一个数值，表示一个或多个通道已经就绪，然后你就可以通过调用selector.selectedKeys()方法返回的SelectionKey集合来获得就绪的Channel。请看演示方法：

         ```java
         Set<SelectionKey> selectedKeys = selector.selectedKeys();
         ```

         当你通过Selector注册一个Channel时，channel.register()方法会返回一个SelectionKey对象，这个对象就代表了你注册的Channel。这些对象可以通过selectedKeys()方法获得。你可以通过迭代这些selected key来获得就绪的Channel，下面是演示代码：

         ```java
         Set<SelectionKey> selectedKeys = selector.selectedKeys();
         Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
         while(keyIterator.hasNext()) { 
           SelectionKey key = keyIterator.next();
           if(key.isAcceptable()) {
           	// a connection was accepted by a ServerSocketChannel.
           } else if (key.isConnectable()) {
           	// a connection was established with a remote server.
           } else if (key.isReadable()) {
           	// a channel is ready for reading
           } else if (key.isWritable()) {
           	// a channel is ready for writing
           }
           keyIterator.remove();
         }
         ```

         这个循环遍历selected key的集合中的每个key，并对每个key做测试来判断哪个Channel已经就绪；

         请注意循环中最后的keyIterator.remove()方法，Selector对象并不会从自己的selected key集合中自动移除SelectionKey实例；

         需要在处理完一个Channel的时候自己去移除，当下一次Channel就绪的时候，Selector会再次把它添加到selected key集合中；

         SelectionKey.channel()方法返回的Channel需要转换成具体要处理的类型，比如是ServerSocketChannel或者SocketChannel等等；

- 实例

  **NIOServer**

  ```java
  public static void main(String[] args) throws Exception{
    // 创建 ServerSocketChannel -->> ServerSocket
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    InetSocketAddress inetSocketAddress = new InetSocketAddress(5555);
    serverSocketChannel.socket().bind(inetSocketAddress);
    serverSocketChannel.configureBlocking(false); // 设置成非阻塞
  
    // 开启 selector, 并注册 accept 事件
    Selector selector = Selector.open();
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
  
    while(true) {
      selector.select(2000); // 监听所有通道
      Set<SelectionKey> selectionKeys = selector.selectedKeys(); // 遍历selectionKeys
      Iterator<SelectionKey> iterator = selectionKeys.iterator();
      while (iterator.hasNext()) {
        SelectionKey key = iterator.next();
        if(key.isAcceptable()) {  // 处理连接事件
          SocketChannel socketChannel = serverSocketChannel.accept();
          socketChannel.configureBlocking(false);  // 设置为非阻塞
          System.out.println("client:" + socketChannel.getLocalAddress() + " is connect");
          socketChannel.register(selector, SelectionKey.OP_READ); // 注册客户端读取事件到selector
        } else if (key.isReadable()) {  // 处理读取事件
          ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
          SocketChannel channel = (SocketChannel) key.channel();
          channel.read(byteBuffer);
          System.out.println("client:" + channel.getLocalAddress() + " send " + new String(byteBuffer.array()));
        }
        iterator.remove(); // 事件处理完毕，要记得清除
      }
    }
  }
  ```

  **NIOClient**

  ```java
  public class NIOClient {
    public static void main(String[] args) throws Exception {
      SocketChannel socketChannel = SocketChannel.open();
      socketChannel.configureBlocking(false);
      InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 5555);
  
      if(!socketChannel.connect(inetSocketAddress)) {
          while (!socketChannel.finishConnect()) {
              System.out.println("客户端正在连接中，请耐心等待");
          }
      }
  
      ByteBuffer byteBuffer = ByteBuffer.wrap("mikechen的互联网架构".getBytes());
      socketChannel.write(byteBuffer);
      socketChannel.close();
    }
  }
  ```





### AIO

Asynchronous I/O，是**JDK1.7**新特性，集成在**nio**包（因此也叫**NIO2.0**），是异步非阻塞的IO模型，对socket和I/O起作用；

异步操作指的是对read/write/accept/connection等方法实现异步操作，完成后会执行回调接口CompletionHandler<V,A>中的方法；

read，write方法的返回类型都是Future对象。而Future模型是异步的；

在java.nio.channels包下增加了下面四个异步通道：

- AsynchronousSocketChannel
- AsynchronousServerSocketChannel
- AsynchronousFileChannel
- AsynchronousDatagramChannel

| CompletionHandler方法               | 返回值 | 说明                                                         |
| ----------------------------------- | ------ | ------------------------------------------------------------ |
| completed(V result, A attachment)   | void   | 异步IO执行成功时调用的方法<br>result：I/O操作的结果；<br>attachment：启动I/O操作时附加到该操作的对象； |
| failed(Throwable exc, A attachment) | void   | 异步IO执行失败时调用的方法<br/>exc：指示I/O操作失败原因的异常；<br/>attachment：启动I/O操作时附加到该操作的对象； |

服务器端：

```java
public class TestAIOServer {
	public static void main(String[] args) {
		TestAIOServer server = new TestAIOServer();
		server.start(8888);
	}
	
	private ExecutorService pool; // 线程池
	private AsynchronousChannelGroup group; // 通道组
	public AsynchronousServerSocketChannel channel; // 服务器通道
	
	public void start(int port) {
		try {
			this.pool = Executors.newCachedThreadPool(); // 创建一个缓存池
			this.group = AsynchronousChannelGroup.withCachedThreadPool(pool, 1); // 创建通道组
			this.channel = AsynchronousServerSocketChannel.open(this.group); // 创建服务器通道
			this.channel.bind(new InetSocketAddress(port)); // 进行绑定
			System.out.println("启动服务器, 端口: " + port);
			this.channel.accept(this, new TestAIOServerHandler()); // 等待客户端请求
			Thread.sleep(Integer.MAX_VALUE); // 一直阻塞 不让服务器停止，真实环境是在tomcat下运行，所以不需要这行代码
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class TestAIOServerHandler implements CompletionHandler<AsynchronousSocketChannel, TestAIOServer> {
	private final Integer BUFFER_SIZE = 1024;
	
	private Function<String, Integer> func = (s) -> {
		Pattern p = Pattern.compile("^(\\d+)([\\+|\\-|\\*|\\/])(\\d+)$", Pattern.MULTILINE);
		Matcher m = p.matcher(s); // 获取 matcher 对象
		if (m.find()) {
			int s1 = Integer.parseInt(m.group(1));
			String s2 = m.group(2);
			int s3 = Integer.parseInt(m.group(3));
			
			switch (s2) {
				case "+":
					return s1 + s3;
				case "-":
					return s1 - s3;
				case "*":
					return s1 * s3;
				case "/":
					return s1 / s3;
				default:
					throw new UnsupportedOperationException(s2);
			}
		} else {
			throw new RuntimeException(s);
		}
	};
	
	public TestAIOServerHandler() {
		super();
	}
	
	@Override
	public void completed(AsynchronousSocketChannel channel, TestAIOServer attachment) {
		attachment.channel.accept(attachment, this); // 保证多个客户端都可以阻塞
		this.read(channel);
	}
	
	// 读取数据
	private void read(AsynchronousSocketChannel channel) {
		ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);
		channel.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {
			
			@Override
			public void completed(Integer size, ByteBuffer buf) {
				buf.flip(); // 进行读取之后,重置标识位
				String data = new String(buf.array()).trim(); // 获取读取的数据
				System.out.println("Server -> 收到客户端的数据信息为: " + data);
				
				// 写入数据
				try {
					String response = data + " = " + func.apply(data);
					ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE); // 把数据写入到缓冲区中
					buffer.put(response.getBytes());
					buffer.flip();
					channel.write(buffer).get(); // 在从缓冲区写入到通道中
				} catch (InterruptedException e) {
					e.printStackTrace();
				} catch (ExecutionException e) {
					e.printStackTrace();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			
			@Override
			public void failed(Throwable e, ByteBuffer attachment) {
				e.printStackTrace();
			}
		});
	}
	
	@Override
	public void failed(Throwable e, TestAIOServer attachment) {
		e.printStackTrace();
	}
}
```

客户端：

```java
public class TestAIOClient implements Runnable {
	private AsynchronousSocketChannel channel;
	
	public TestAIOClient() throws Exception {
		this.channel = AsynchronousSocketChannel.open(); // 打开通道
	}
	
	public void connect() {
		this.channel.connect(new InetSocketAddress("127.0.0.1", 8888)); // 创建连接 和NIO一样
	}
	
	public void write(String request) {
		try {
			this.channel.write(ByteBuffer.wrap(request.getBytes())).get();
			ByteBuffer buffer = ByteBuffer.allocate(1024);
			this.channel.read(buffer).get();
			buffer.flip();
			byte[] respByte = new byte[buffer.remaining()];
			buffer.get(respByte); // 将缓冲区的数据放入到 byte数组中
			System.out.println(new String(respByte, "utf-8").trim());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	@Override
	public void run() {
		while (true) {
		}
	}
	
	public static void main(String[] args) throws Exception {
		for (int i = 0; i < 10; i++) {
			TestAIOClient client = new TestAIOClient();
			client.connect();
			new Thread(client, "AIO_Client").start();
			Random random = new Random(System.currentTimeMillis());
			String[] operators = { "+", "-", "*", "/" };
			String expression = random.nextInt(10) + operators[random.nextInt(4)] + (random.nextInt(10) + 1);
			client.write(expression);
		}
	}
}
```



------



# RPC协议

全称 Remote Procedure Call，即远程服务调用协议，允许像调用本地服务一样调用远程服务，且RPC协议是与语言无关的。

可以有不同的实现方式：RMI（远程方法调用）、Hessian、Http invoker等；

常见的RPC框架：Dubbo、SpringCloud、Thrift、Motan、gRPC；

RPC架构分三部分：

- 服务提供者

  运行在服务器端，提供服务接口定义与服务实现；

- 服务中心

  主要是服务的注册和客户端服务的发现，常见的服务中心：zookeeper，Redis；

- 服务消费者

  运行在客户端，通过远程代理对象调用远程服务；



------



# RMI技术

远程方法调用（Remote Method Invocation），是RPC的纯java实现方式，由以下三个部分组成：

- Client（客户端）

  客户端会从Registry取得服务端注册的服务，从而调用服务端的远程方法；

- Registry（服务端）

  服务端在注册中心注册服务时，需要提供一个key以及一个value，这个value是一个远程对象，Registry会对这个远程对象进行封装，使其转为一个远程代理对象。在低版本的JDK中，Server与Registry是可以不在一台服务器上的，而在高版本的JDK中，Server与Registry只能在一台服务器上，否则无法注册成功；

- Server（注册中心）

  可以把他理解成一个字典，一个负责网络传输的模块；

**例子：**

先注册一个远程对象：

```java
interface RmiFunc extends Remote {
	public String execute(String name) throws RemoteException;
}

class RmiFuncImpl extends UnicastRemoteObject implements RmiFunc {
	private static final long serialVersionUID = 1L;
	
	public RmiFuncImpl() throws RemoteException {
		super();
	}
	
	@Override
	public String execute(String name) throws RemoteException {
		return "Hello " + name;
	}
}

public class RmiFuncService {
	public static void main(String[] args) throws Exception {
		RmiFunc obj = new RmiFuncImpl(); // 使用RMISocketFactory类创建一个套接字服务器
		Registry registry = LocateRegistry.createRegistry(1099); // 将套接字服务绑定到 1099 端口
		registry.bind("rmifunc", obj);
		System.out.println("已将 " + RmiFunc.class.getName() + " 对象绑定到端口 1099!");
	}
}
```

调用远程对象的方法：

```java
public class RmiFuncServiceCaller {
	public static void main(String[] args) throws NamingException, RemoteException {
		Properties env = new Properties();
		env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
		env.put(Context.PROVIDER_URL, "rmi://localhost:1099");
		Context ctx = new InitialContext(env);
		RmiFunc obj = (RmiFunc) ctx.lookup("rmi://localhost:1099/rmifunc");
		System.out.println(obj.execute("test"));
	}
}
```



------



# SPI机制

服务供应发现机制（Service Provider Interface），是Java6新特性，实现了服务的动态发现与替换，达到了将API和其实现分离的目的。Java中基于SPI机制的技术有： JDBC、JCE、JNDI、JAXP、JBI等，SPI机制需要如下四个步骤：



## 定义服务接口

```java
public interface SpiFunc {
	void execute();
}
```



## 定义服务实现

实现类必须有一个无参构造器。

```java
public class SpiFuncA implements SpiFunc {
	@Override
	public void execute() {
		System.out.println("Hello A");
	}
}

public class SpiFuncB implements SpiFunc {
	@Override
	public void execute() {
		System.out.println("Hello B");
	}
}
```



## 关联接口与实现

在 resources 目录下新建 `META-INF/services` 目录，在这个目录下新建一个文件（文件名就是接口的全限定名），文件内容是实现类的全限定名。

新建文件 `META-INF/services/indi.lvzhaojun.test.spi.SpiFunc` 内容如下：

```ini
indi.lvzhaojun.test.spi.SpiFuncA
indi.lvzhaojun.test.spi.SpiFuncB
```



## 调用服务

```java
public class SpiFuncTest {
	public static void main(String[] args) {
		ServiceLoader<SpiFunc> sl = ServiceLoader.load(SpiFunc.class);
		for (SpiFunc u : sl) {
			System.out.println(u.getClass().getName());
			u.execute();
		}
	}
}
```



------



# JNDI技术

Java名称和目录服务（Java Naming and Directory Interface），包含了DataSource、JDBC、LDAP、RMI、DNS、NIS、CORBA；

![JNDIFrame](./01.Java_part1.assets/JNDIFrame.png)

## Naming

命名服务，可通过服务名称查找服务实现；

- Bindings

  表示一个名称和一个对象的绑定关系，比如：

  - 在文件系统中指的是将文件名绑定到对应的文件；
  - 在DNS中指的是将域名绑定到对应的IP；
  - 在RMI中指的是将远程对象绑定到对应的name；

- Context

  是指上下文信息，维护着一组名称到一组对象的绑定关系；

- Reference

  可通过Reference类来绑定一个外部的远程对象；



## Directory

是一种特殊的命名服务，允许存储和搜索目录对象，目录对象可以与属性相关联。一个目录是一个类似树的分层结构库；

常见的目录服务有：

- LDAP：轻型目录访问协议；
- Active Directory：为Windows域网络设计，包含多个目录服务，比如域名服务、证书服务等；
- 其他基于X.500（分布式名录服务系统协议）实现的目录服务；



## Interface

提供所有服务的接口API，可以通过这些API调用具体的服务实现；



## 包和类

| 包名                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| javax.naming           | 命名操作，包含命名服务的类和接口，该包定义了Context接口和InitialContext类 |
| javax.naming.directory | 目录操作，包含DirContext接口和InitialDirContext类            |
| javax.naming.event     | 在命名目录服务器中请求事件通知                               |
| javax.naming.ldap      | 提供LDAP支持                                                 |
| javax.naming.spi       | SPI机制相关的接口与实现类                                    |

| 类          | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| Context接口 | 表示命名上下文信息，由一组名称与对象绑定组成                 |
| Name接口    | 表示通用名称 - 有序的组件序列                                |
| Reference   | 在JNDI服务中允许使用系统以外的对象，比如在某些目录服务中直接引用远程的Java对象，但遵循一些安全限制； |

| Context方法                                                  | 返回值            | 说明                                                         |
| ------------------------------------------------------------ | ----------------- | ------------------------------------------------------------ |
| lookup(String name)                                          | Object            | 返回指定名字绑定的对象                                       |
| bind(<br/>String sName,<br/>Object object<br/>)              | void              | 绑定：把对象绑定关联到指定名称上的过程                       |
| rebind(<br/>String sName,<br/>Object object<br/>)            | void              | 重新绑定：用来把对象同一个已经存在的名称重新绑定。<br>注意不要用bind()，bind()会报异常； |
| unbind(<br/>String sName<br/>)                               | void              | 释放指定名称与绑定的对象从目录中                             |
| lookup(<br/>String sName,<br/>Object object<br/>)            | void              | 查找：返回目录总的一个对象                                   |
| rename(<br/>String sOldName,<br/>String sNewName<br/>)       | void              | 重命名：用来修改对象名称绑定的名称                           |
| listBindings(String sName)                                   | NamingEnumeration | 返回清单：返回绑定在特定上下文中指定属性名对象的清单列表；<br>返回名字、类和对象本身，用于那些需要对对象进行实际操作的应用 |
| list(String sName)                                           | NamingEnumeration | 只返回一系列名字/类映射，主要是用于上下文浏览应用            |
| destroySubcontext(String name)                               | void              | 销毁命名上下文并将其从命名空间中删除<br>name：要销毁的上下文的名称; 可能不是空的 |
| createSubcontext(String name)                                | Context           | 创建并绑定新的上下文<br>name：要创建的上下文的名称; 可能不是空的 |
| lookupLink(String name)                                      | Object            | 返回命名对象，除了名称的终端原子组件以外的链接               |
| getNameParser(String name)                                   | NameParser        | 返回与命名上下文关联的解析器<br>在命名空间联盟中，不同的命名系统会以不同的方式解析名称。 |
| composeName(<br/>String name,<br/>String prefix<br/>)        | String            | 使用相对于该上下文的名称组合此上下文的名称<br>               |
| addToEnvironment(<br/>String propName,<br/>Object propVal<br/>) | Object            | 在此上下文的环境中添加一个新的环境属性；<br/>如果属性已经存在，则其值将被覆盖；<br/>有关环境属性的更多详细信息，请参阅类描述； |
| removeFromEnvironment(<br/>String propName<br/>)             | Object            | 从环境环境中删除环境属性<br/>有关环境属性的更多详细信息，请参阅类描述 |
| getEnvironment()                                             | Hashtable\<?,?>   | 返回检上下文中有效的环境                                     |
| close()                                                      | void              | 关闭此上下文                                                 |
| getNameInNamespace()                                         | String            | 在其自己的命名空间中查找此上下文的全名；<br/>许多命名服务对于各自的命名空间中的对象都有一个“全名”概念。 <br/>例如，LDAP条目具有可分辨名称，DNS记录具有完全限定名称。 <br/>此方法允许客户端应用程序检索此名称。 <br/>此方法返回的字符串不是JNDI组合名称，不应直接传递给上下文方法。 <br/>在命名系统中，全名概念没有意义， `OperationNotSupportedException`被抛出 |

使用 Context.lookup() 方法时，没有指定初始化工厂名称，会根据URL协议中类型动态查找内置的工厂类，支持自动转换的协议：

| 协议名           | 协议URL      | Context类                                             |
| ---------------- | ------------ | ----------------------------------------------------- |
| DNS协议          | dns://       | com.sun.jndi.url.dns.dnsURLContext                    |
| RMI协议          | rmi://       | com.sun.jndi.url.rmi.rmiURLContext                    |
| LDAP协议         | ldap://      | com.sun.jndi.url.ldap.ldapURLContext                  |
| LDAP协议         | ldaps://     | com.sun.jndi.url.ldaps.ldapsURLContextFactory         |
| IIOP请求代理协议 | iiop://      | com.sun.jdni.url.iiop.iiopURLContext                  |
| IIOP请求代理协议 | iiopname://  | com.sun.jndi.url.iiopname.iiopnameURLContextFactory   |
| IIOP请求代理协议 | corbaname:// | com.sun.jndi.url.corbaname.corbanameURLContextFactory |



## JNDI地址

- 标准方式

  标准的J2EE环境查找规则是 `java:comp/env`，表示环境命名上下文信息（Environment Naming Context，缩写ENC）；

  ```ini
  java:comp/env/jdbc/testDS
  ```

  | 引用               | 说明                     |
  | ------------------ | ------------------------ |
  | java:comp/env/jdbc | JDBC数据源引用声明       |
  | java:comp/env/jms  | JMS连接工厂引用声明      |
  | java:comp/env/mail | JavaMail连接工厂引用声明 |
  | java:comp/env/url  | URL连接工厂引用声明      |

- 硬引用

  ```ini
  jdbc/testDS
  ```



## 案例



### JNDI+Tomcat+DataSource

在 Tomcat的 server.xml中 GlobalNamingResources节点下，添加一个全局数据源。

```xml
<Resource
    name="jdbc/mysql"
    scope="Shareable"
    type="javax.sql.DataSource"
    factory="org.apache.tomcat.dbcp.dbcp.BasicDataSourceFactory"
    url="jdbc:mysql://localhost:3306/test"
    driverClassName ="com.mysql.jdbc.Driver"
    username="root"
    password="root"
/>
```

```java
Connection conn = null;
try {
	Context ctx = new InitialContext();
	DataSource ds = (Datasource) ctx.lookup("java:comp/env/jdbc/mysql");
	conn = ds.getConnection();
	……
	conn.close();
} finally {
	if(conn != null) {
			conn.close();
	}
}
```



### JNDI+Tomcat+Spring配置方式

在 Tomcat的 server.xml工程的 Context节点下，添加一个私有数据源，如下：

```xml
<Context docBase="WebApp" path="/WebApp" reloadable="true" source="org.eclipse.jst.jee.server:WebApp">
<Resource
    name="jdbc/mysql"
    scope="Shareable"
    type="javax.sql.DataSource"
    factory="org.apache.tomcat.dbcp.dbcp.BasicDataSourceFactory"  
    url="jdbc:mysql://localhost:3306/test"
    driverClassName ="com.mysql.jdbc.Driver"
    username="root"
    password="root"
/>
</Context>
```

```xml
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
    <property name="jndiName" value="jdbc/mysql"/> <!-- 第一步中所配置的JNDI名称 -->
    <property name="resourceRef" value="true"/> <!-- 可以让我们指定jndiName时，省略前缀 java:comp/env/ -->
</bean>
```



### JNDI+Spring注解配置方式

```java
@Configuration
public class DataSourceConfig {
    @Bean(destroyMethod="shutdown")
    @Profile("development")
    public DataSource embeddedDataSource() {
        return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.H2)
        .addScript("classpath:schema.sql")
        .addScript("classpath:test-data.sql")
        .build();
    }

    @Bean
    @Profile("production")
    public DataSource jndiDataSource() {
        JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();
        jndiObjectFactoryBean.setJndiName("jdbc/myDS");
        jndiObjectFactoryBean.setResourceRef(true);
        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);
        return (DataSource) jndiObjectFactoryBean.getObject();
    }
}
```



### JNDI+LDAP

引入依赖

```xml
<dependency>
  <groupId>com.unboundid</groupId>
  <artifactId>unboundid-ldapsdk</artifactId>
  <version>2.3.8</version>
</dependency>
```

创建LDAP服务端

```java
public class LDAPSeriServer {
  private static final String LDAP_BASE = "dc=example,dc=com";
  public static void main(String[] args) throws IOException {
    int port = 1389;
    try {
      InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
      config.setListenerConfigs(new InMemoryListenerConfig(
        "listen", //$NON-NLS-1$
        InetAddress.getByName("0.0.0.0"), //$NON-NLS-1$
        port,
        ServerSocketFactory.getDefault(),
        SocketFactory.getDefault(),
        (SSLSocketFactory) SSLSocketFactory.getDefault())
      );
      config.setSchema(null);
      config.setEnforceAttributeSyntaxCompliance(false);
      config.setEnforceSingleStructuralObjectClass(false);
      InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
      ds.add("dn: " + "dc=example,dc=com", "objectClass: top", "objectclass: domain");
      ds.add("dn: " + "ou=employees,dc=example,dc=com", "objectClass: organizationalUnit", "objectClass: top");
      ds.add("dn: " + "uid=longofo,ou=employees,dc=example,dc=com", "objectClass: ExportObject");

      System.out.println("Listening on 0.0.0.0:" + port); //$NON-NLS-1$
      ds.startListening();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```

客户端访问LDAP服务

```java
public class LDAPClient {
  public static void main(String[] args) throws NamingException {
    System.setProperty("com.sun.jndi.ldap.object.trustURLCodebase","true");
    Context ctx = new InitialContext();
    Object object =  ctx.lookup("ldap://127.0.0.1:1389/uid=longofo,ou=employees,dc=example,dc=com");
    System.out.println(object);
  }
}
```



### JNDI_Reference+RMI

```java
public class RMIServer {
    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException {
        Registry registry = LocateRegistry.createRegistry(9999);
        Reference refObj = new Reference( // 创建一个远程对象的引用
          "ExportObject",
          "indi.lvzhaojun.remoteclass.ExportObject",
          "http://127.0.0.1:8000/"
        );
        ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); // 创建一个包装类，转换为RMI引用对象
        registry.bind("refObj", refObjWrapper); // 将服务绑定到服务名
    }
}
```

```java
public class RMIClient {
    public static void main(String[] args) throws RemoteException, NotBoundException, NamingException {
        Properties env = new Properties();
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory"); // 工厂类名
        env.put(Context.PROVIDER_URL, "rmi://localhost:9999");
        Context ctx = new InitialContext();
        ctx.lookup("rmi://localhost:9999/refObj");
    }
}
```



### JNDI+CORBA

```java
public org.omg.CORBA.Object read_Object(Class clz)  { // In any case, we must first read the IOR
    IOR ior = IORFactories.makeIOR(parent);     
    if (ior.isNil()) {
      return null;
    }

    PresentationManager.StubFactoryFactory sff = ORB.getStubFactoryFactory();
    String codeBase = ior.getProfile().getCodebase();
    PresentationManager.StubFactory stubFactory = null; 
    if (clz == null) {          
        RepositoryId rid = RepositoryId.cache.getId(ior.getTypeId());
        String className = rid.getClassName();          
        boolean isIDLInterface = rid.isIDLType();
 
        if (className == null || className.equals("")) {
        	stubFactory = null;
        } else {
            try {
                stubFactory = sff.createStubFactory(className,  isIDLInterface, codeBase, (Class)null, (ClassLoader)null);  
            } catch (Exception exc) {
                stubFactory = null;
            }
        } else if (StubAdapter.isStubClass( clz )) {
        	stubFactory = PresentationDefaults.makeStaticStubFactory(clz);      
        } else { // clz is an interface class
					boolean isIDL = IDLEntity.class.isAssignableFrom(clz);
          stubFactory = sff.createStubFactory( clz.getName(),isIDL, codeBase, clz, clz.getClassLoader());
        }
    }

    return internalIORToObject( ior, stubFactory, orb ) ;   
}
```



### JNDI+DNS

```java
public class JndiDNSTest {
	
	public static void main(String[] args) {
		Hashtable<String, String> env = new Hashtable<String, String>();
		env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.dns.DnsContextFactory"); // 设置初始化工厂类名
		env.put(Context.PROVIDER_URL, "dns://114.114.114.114"); // DNS服务器地址
		
		try {
			DirContext cxt = new InitialDirContext(env); // 创建JNDI目录服务对象
			Attributes a1 = cxt.getAttributes("baidu.com", new String[] { "A" }); // 获取DNS解析记录测试
			Attributes a2 = cxt.getAttributes("qq.com", new String[] { "A" }); // 获取DNS解析记录测试
			
			System.out.println(a1);
			System.out.println(a2);
		} catch (NamingException e) {
			e.printStackTrace();
		}
	}
}
```



